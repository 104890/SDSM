# Теория

Рассмотрим его работу на примере вот такой упрощённой сети:

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da12_d1d6fb5c_XL.jpg)

Для начала надо сказать, что для того, чтобы между маршрутизаторами завязалась дружба \(отношения смежности\) должны выполниться следующие условия:

1\) в OSPF должны быть настроены одинаковые **Hello Interval** на тех маршрутизаторах, что подключены друг к другу. По умолчанию это 10 секунд в Broadcast сетях, типа Ethernet. Это своего рода KeepAlive сообщения. То есть каждые 10 секунд каждый маршрутизатор отправляет Hello пакет своему соседу, чтобы сказать: “Хей, я жив”,  
2\) Одинаковыми должны быть и **Dead Interval** на них. Обычно это 4 интервала Hello — 40 секунд. Если в течение этого времени от соседа не получено Hello, то он считается недоступным и начинается ПАНИКА процесс перестроения локальной базы данных и рассылка обновлений всем соседям,  
3\) Интерфейсы, подключенные друг к другу, должны быть в **одной подсети**,  
4\) OSPF позволяет снизить нагрузку на CPU маршрутизаторов, разделив Автономную Систему на зоны. Так вот **номера зон** тоже должны совпадать,  
5\) У каждого маршрутизатора, участвующего в процессе OSPF есть свой **уникальный** индентификатор — **Router ID**. Если вы о нём не позаботитесь, то маршрутизатор выберет его автоматически на основе информации о подключенных интерфейсах \(выбирается высший адрес из интерфейсов, активных на момент запуска процесса OSPF\). Но опять же у хорошего инженера всё под контролем, поэтому обычно создаётся Loopback интерфейс, которому присваивается адрес с маской /32 и именно он назначается Router ID. Это бывает удобно при обслуживании и траблшутинге.  
6\) Должен совпадать размер MTU

Далее пьеса в восьми частях.

1\) Штиль. Состояние OSPF — **DOWN**  
В это короткое мгновение в сети ничего не происходит — все молчат.

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da15_c2a85553_XL.jpg)

2\) Поднимается ветер: маршрутизатор рассылает Hello-пакеты на мультикастный адрес [224.0.0.5](http://en.wikipedia.org/wiki/Multicast_address) со всех интерфейсов, где запущен OSPF. [TTL](http://ru.wikipedia.org/wiki/Time_to_live) таких сообщений равен одному, поэтому их получат только маршрутизаторы, находящиеся в том же сегменте сети. R1 переходит в состояние **INIT**.

![](http://img-fotki.yandex.ru/get/6422/83739833.1f/0_9da19_bcc4c3f8_XL.jpg)

В пакеты вкладывается следующая информация:

* Router ID
* Hello Interval
* Dead Interval
* Neighbors
* Subnet mask
* Area ID
* Router Priority
* Адреса DR и BDR маршрутизаторов
* Пароль аутентификации

Нас интересуют пока первые четыре или точнее вообще только Router ID и Neighbors.  
Сообщение Hello от маршрутизатора R1 несёт в себе его Router ID и не содержит Neighbors, потому что у него их пока нет.  
После получения этого мультикастного сообщения маршрутизатор R2 добавляет R1 в свою таблицу соседей \(если совпали все необходимые параметры\).

![](http://img-fotki.yandex.ru/get/6521/83739833.1f/0_9da1c_13dc8099_XL.jpg)

И отправляет на R1 уже юникастом новое сообщение Hello, где содержится Router ID этого маршрутизатора, а в списке Neigbors перечислены все его соседи. В числе прочих соседей в этом списке есть Router ID R1, то есть R2 уже считает его соседом.

![](http://img-fotki.yandex.ru/get/6620/83739833.1f/0_9da20_235302c3_XL.jpg)

3\) Дружба. Когда R1 получает это сообщение Hello от R2, он пролистывает список соседей и находит в нём свой собственный Router ID, он добавляет R2 в свой список соседей.

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da26_46263e45_XL.jpg)

Теперь R1 и R2 друг у друга во взаимных соседях — это означает, что между ними установлены отношения смежности и маршрутизатор R1 переходит в состояние **TWO WAY**.

![](http://img-fotki.yandex.ru/get/6421/83739833.1f/0_9da23_99cc98b_XL.jpg)

Далее происходит выбор [DR и BDR](http://ru.wikipedia.org/wiki/OSPF#.D0.92.D1.8B.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BC.D0.B0.D1.80.D1.88.D1.80.D1.83.D1.82.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80_.28DR.29_.D0.B8_.D1.80.D0.B5.D0.B7.D0.B5.D1.80.D0.B2.D0.BD.D1.8B.D0.B9_.D0.B2.D1.8B.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BC.D0.B0.D1.80.D1.88.D1.80.D1.83.D1.82.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80_.28BDR.29), но мы не будем на этом останавливаться, хоть это и довольно важные вещи.

4\) Затишье перед бурей. Далее все переходят в состояние **EXSTART**. Здесь все соседи решают между собой, кто босс. Им становится маршрутизатор с наибольшим Router ID — R2.

5\) Когда выбран _Батька_, соседи переходят в состояние **Exchange** и обмениваются DBD-сообщениями \(или DD\) — Data Base Description, которые содержат описание LSDB \(Link State Data Base\), мол, я знаю про вот такие подсети.  
Тут надо пояснить, что такое LSDB. Если перевести на русский дословно: база данных о состоянии линков. В изначальном состоянии маршрутизатор знает только о тех линках \(интерфейсах\), на которых запущен процесс OSPF. По ходу пьесы, каждый маршрутизатор собирает всю информацию о сети и составляет топологию. Именно она и будет являться LSDB, которая должна быть одинакова на всех членах зоны.  
Первым отсылает свою DBD маршрутизатор, выбранный главным на данном интерфейсе — 2.2.2.2. Следом за ним то же делает и 1.1.1.1.

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da2a_2882c479_XL.jpg)

6\) Получив сообщение, маршрутизаторы R1 и R2 отправляют подтверждение о приёме DBD \(LSAck\), а затем сравнивают новую информацию с той, что содержится у них в LSDB и, если есть отличия, посылают LSR \(Link State Request\) друг другу, тем самым переходя в новое состояние **LOADING**. В LSR они говорят — “Я про вот эту сеть ничего не знаю. Расскажи мне подробнее”.

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da2e_7c726edb_XL.jpg)

7\) R2, получив LSR от R1, высылает LSU \(Link State Update\), которые содержат в себе LSA \(Link State Advertisement\) c детальной информацией о нужных подсетях.

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da32_4552fd75_XL.jpg)

И вот, как только R1 получит последнюю порцию данных о всех подсетях и сформирует свою LSDB, он переходит в своё конечное состояние **FULL STATE**.

![](http://img-fotki.yandex.ru/get/6623/83739833.1f/0_9da36_d2c831e1_XL.jpg)

К тому моменту, как все маршрутизаторы зоны придут к состоянию Full State на всех на них должна быть полностью одинаковая LSDB — они же одну и ту же сеть изучали. То есть фактически это означает, что маршрутизатор знает всю вашу сеть, что, как и куда подключено.

> Авторы осознают, что понять и запомнить все эти аббревиатуры и правила довольно сложно, но прочитав это 5 -7 раз в разных местах с некоторой периодичностью, можно будет составить представление о том, как OSPF работает.

8\) Итак, сейчас у нас все маршрутизаторы знают всё о сети, но это знание не помогает в маршрутизации.  
Следующим шагом OSPF, используя алгоритм Дейкстры \(или его ещё называют SPF — Shortest Path First\), вычисляет кратчайший маршрут до каждого маршрутизатора в зоне — он ведь знает всю топологию. В этом ему помогают метрики. Чем она ниже, тем маршрут лучше. Метрика — это стоимость движения по маршруту.

![](http://img-fotki.yandex.ru/get/6422/83739833.1f/0_9da0e_4fc28d4_XL.jpg)

Например, в такой сети из R1 в R3 можно добраться напрямую или через R2.  
Естественно первый вариант будет стоить меньше. Но это при условии, что у вас везде одинаковый тип интерфейсов. А если, например, между R1 и R3 у вас модемное соединение в 56к или крайне нестабильный GPRS линк? Тогда у них будет очень высокая стоимость и OSPF предпочтёт более длинный, но быстрый путь.  
Найденный путь потом добавляется в таблицу маршрутизации.

Теперь каждые 10 секунд каждый маршрутизатор будет отправлять Hello-пакеты, а каждые 30 минут рассылаются LSA — это типа данные уже считаются устаревшими, надо бы обновить, даже если изменений не было.

В идеальном мире на этом бы и установилось равновесие. Но мы живём в мире жестоком и равнодушном, где инженер — это итшник, а то и компьютерщик вообще, а лифты научились ездить вниз всего [три выпуска](https://linkmeup.ru/blog/14.html) назад. И в этом будничном мире кипят страсти: рвут оптику, вырубают питание, мыши перегрызают ножки процессоров \(или это не в этом мире?\) — иными словами, топология непрестанно меняется. И чем больше сеть, тем чаще и глобальнее изменения.

Разумеется, было бы несколько странно ждать 40 секунд \(Dead Interval\) и только потом начинать перестраивать таблицу. Это было бы простительно ещё RIP’у, но не протоколу, который используется в огромном количестве современных сетей. Итак, как только падает какой-либо из линков \(или несколько\), маршрутизатор изменяет свою LSDB и генерирует LSU, присваивая ей номер больше, чем он был прежде \(у каждой LSDB есть номер, который берётся из последнего полученного LSA\).

Это LSU сообщение рассылается на мультикастовый адрес 224.0.0.5. Маршрутизаторы получившие его, проверяют номер LSA, содержащихся в LSU.  
1\) Если номер больше, чем номер текущей LSA маршрутизатора — LSDB меняется. \(Версия LSDB старая, информация новая\),  
2\) Если номер такой же, ничего не происходит. Этот маршрутизатор уже получил данный LSA по какому-то другому пути,  
3\) Если номер полученного LSA меньше локальной LSDB, это означает, что у маршрутизатора уже более актуальная информация, и он посылает новый LSA \(на основе своей LSDB\) отправителю прежнего.

После произведённых \(или непроизведённых\) действий соседу, от которого пришёл LSU пересылаются LSAck \(мол, «посылку получили — всё в порядке»\), а другим соседям отправляется изначальный LSU без изменений. На данном маршрутизаторе снова запускается алгоритм SPF и, при необходимости, обновляется таблица маршрутизации.

В общем, всё это происходит в целях поддержания актуальности информации на всех устройствах — LSDB должна быть одинаковой у всех.

> Тут надо оговориться, что маршрутизатор замечает изменения только при прямом подключении к своему соседу. Если между ними будет, например, коммутатор, то устройство не обнаружит падения физического интерфейса и ничего не будет делать. Для таких ситуаций есть два решения.  
> 1\) Настроить таймеры. Для OSPF их можно уменьшить до уровня миллисекунд.  
> 2\) Использовать очень крутой протокол BFD \([Bidirectional Forwarding Detection](http://en.wikipedia.org/wiki/Bidirectional_Forwarding_Detection)\). Он позволяет отслеживать состояние линков также на миллисекундном уровне. В конфигурации BFD связывается с другими протоколами и позволяет очень быстро сообщить кому надо, что есть проблемы на сети. Конкретно с BFD мы будем разбираться в другой части.

Как вы заметили, на все сообщения есть подтверждения: либо это LSAck, либо ответ Hello на Hello. Это плата за отказ от TCP — как-то ведь надо убеждаться в успешной доставке.

> Всего существует 7 типов LSA, которые тесно завязаны на зоны, коих тоже 5 штук. Маршрутизаторы тоже бывают четырёх типов. А так же есть понятия Designated Router \(DR\) и Backup DR \(BDR\), ABR и ASBR. Есть формулы расчёт метрик и прочее, прочее. Оставляем это на самостоятельное изучение.

### Практика OSPF

Помните, как мы мучились, настраивая маршрутизацию в прошлый раз: на каждом устройстве до каждой сети и не дай бог что-нибудь забыть. Теперь это в прошлом — да здравствуют IGP!  
Не будем терять время, объясняя отдельно команды, а сразу окунёмся в удивительный мир конфигурации.  
Такс, имеет место сейчас следующая логическая схема:

![](http://img-fotki.yandex.ru/get/6611/83739833.1f/0_9c86f_a16926ef_XL.jpg)

Пока нас интересует вот это большое Сибирское кольцо через Красноярск, Хабаровск и Владивосток. Здесь и на нашей уже построенной сети мы запустим OSPF. Там, где прежде была статика, нам придётся от неё отказаться и плавно перейти на динамические протоколы.  
Предположим, что Красноярск у нас так же подключен через «Балаган телеком», как и предыдущие точки, а далее через разных провайдеров нам организованы линки к другим городам. Кольцо замыкается в Москве через провайдера “Филькин сертификат”. Предположим, что везде между городами у нас куплен L2-VPN и IP-трафик ходит прозрачно.

Что внедрение IGP даст конкретно нашей сети?  
1\) Простоту конфигурации, разумеется. На каждом узле нужно знать только локальные сети, вопросом их распространения озадачится OSPF.  
2\) Избыточные линки, которые обеспечат нам резервирование каналов связи. Если, например, бомжи срежут оптику между Москвой и Красноярском, ни один филиал не останется без связи: весь трафик пойдёт через Владивосток

![](http://img-fotki.yandex.ru/get/6410/83739833.1f/0_9cae9_6c74cdad_XL.jpg)

3\) Автоматическое обнаружение проблем, перестроение топологии и изменение таблицы маршрутизации. Именно это обеспечивает возможность выполнения пункта 2.  
4\) Нет опасности создать петлю маршрутизации, когда пакет у нас будет метаться между двумя узлами, пока TTL не истечёт. При статической настройке такая ситуация более, чем возможна.  
5\) Удобство расширения. Представьте, что вам нужно добавить новый филиал, например в Томске и подключать его будете через Кемерово. Тогда статические маршруты вам придётся прописывать в Москве, Кемерово и в самом Томске. При использовании динамики вы настраиваете только новый маршрутизатор… и всё.

IP-план подсетей филиалов и линков Point-to-Point мы уже [подготовили](https://docs.google.com/spreadsheet/pub?key=0AooexOHebRpTdGc1eFhvZHdBa0ZrTUljRG5lYVVQM0E&output=html). Предположим, что и все начальные настройки тоже выполнили на всех узлах:

* hostname
* параметры безопасности \(пароли на телнет, ssh\)
* IP-адреса линковых интерфейсов
* IP адреса подсетей LAN
* IP-адреса Loopback-интерфейсов.

> Мы тут вводим новое понятие Loopback-интерфейса. Он будет сконфигурирован на каждом маршрутизаторе. Для этого выделена специальная подсеть 172.16.255.0/24. Нужно оно нам сейчас для OSPF, а в будущем может понадобиться для BGP, MPLS.  
> Положа руку на сердце, сам долгое время не понимал значения этих интерфейсов. Вообще говоря, это виртуальный интерфейс, состояние которого всегда UP, независимо от состояния физических интерфейсов \(если только на нём самом shutdown не выполнили\). Попытаемся объяснить одну из его ролей:  
> Вот, к примеру, есть у вас сервер мониторинга Nagios. В нём вы завели для наблюдения маршрутизатор R1 и для связи с ним использовали адрес интерфейса FE0/0 — 10.1.0.1.  
>   
> ![](http://img-fotki.yandex.ru/get/6511/83739833.1f/0_9c863_4dcd7246_XL.jpg)  
>   
> На первый взгляд все прекрасно — всё работает. Но предположим теперь, что этот кабель порвали.  
>   
> ![](http://img-fotki.yandex.ru/get/6411/83739833.1f/0_9c864_4d813b1e_XL.jpg)  
>   
> Благодаря динамической маршрутизации, связь до роутера А не нарушится, и он будет доступен через FE0/1. А в Nagios’е у вас будет авария, всё будет красное, повалятся смс и почта. При падении линка, IP-адрес этого интерфейса \(10.1.0.1\) становится недоступен.  
> А вот если вы настроите в Nagios’е адрес Loopback-интерфейса, то тем или иным путём он всегда будет доступен, опять же благодаря динамической маршрутизации.  
>   
> В качестве маски IP-адреса Loopback-интерфейса практически всегда выбирается /32, то есть 11111111.11111111.11111111.1111111 — один единственный адрес — а больше и не надо.

Поскольку все приготовления уже закончились, перед нами стоит очень простая задача: пройтись по всем маршрутизаторам и активировать процесс OSPF.

1\) Первое, что нам нужно сделать — запустить процесс OSPF маршрутизаторе:

```text
msk-arbat-gw1(config)# router OSPF 1
```

Первым словом указываем, что запускаем протокол динамической маршрутизации, далее указываем какой именно и в последнюю очередь номер процесса \(теоретически их может быть несколько на одном роутере\).

Сразу после этого автоматически назначается router ID. По умолчанию это наибольший адрес Loopbaсk-интерфейсов.

2\) Не оставляем это дело на самотёк. Главное правило: Router ID обязан быть уникальным. Нет, вы, конечно, можете их сделать и одинаковыми, но в этом случае у вас начнутся странности.

> Одна из моих заявок была такой: на оборудовании заканчиваются метки LDP. Из 8 с гаком тысяч осталась только одна свободная. Никакие новые VPN не создавались и не работали. Разбирались, разбирались и в итоге увидели что процесс OSPF создаёт и удаляет тысячи записей в минуту в таблице маршрутизации. Топология постоянно перестраивается и на каждое такое перестроение выделяются новые метки LDP, после чего не освобождаются. А всё дело в случайно настроенных одинаковых Router ID.

Настраивать его можно, в принципе, как угодно, можно даже не настраивать, маршрутизатор назначит его сам, но для порядку мы это сделаем — в будущем обслуживать будет проще. Назначаем его в соответствии с адресом Loopback-интерфейса.

```text
msk-arbat-gw1(config-router)#router-id 172.16.255.1
```

3\) Теперь мы объявляем, какие сети мы будем анонсировать \(передавать соседям OSPF\). Обратите внимание, что в этой команде используется wildcard-маска, как в ACL

```text
msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0
```

Тут остановимся подробно. Командой **network** мы задаём не ту сеть, что будет вещать наш маршрутизатор, мы определяем интерфейсы, участвующие в процессе.  
Все интерфейсы маршрутизатора, IP адреса которых попадают в настроенный диапазон 172.16.0.0 0.0.255.255 \(172.16.0.0-172.16.255.255\), включатся в процесс.  
Это означает следующее:  
а\) с данных интерфейсов будут рассылаться Hello-сообщения, через них будут устанавливаться отношения соседства и отправляться обновления о топологии сети.  
б\) OSPF изучает подсети данных интерфейсов и именно их будет аносировать и следить за их состоянием. То есть не 172.16.0.0 0.0.255.255, как мы настроили, а те, что удовлетворяют этому диапазону

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9cf8c_547f90dd_XL.jpg)

В нашем случае не имеет значения как мы настроим:

```text
msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0
```

или

```text
msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.15.255 area 0
```

или

```text
msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0 
msk-arbat-gw1(config-router)#network 172.16.1.0 0.0.255.255 area 0 
msk-arbat-gw1(config-router)#network 172.16.2.0 0.0.255.255 area 0 
…..
msk-arbat-gw1(config-router)#network 172.16.15.0 0.0.255.255 area 0
```

Все эти команды сработают одинаково в нашем случае.  
Поскольку у нас все локальные сети имеют адреса из сети 172.16.0.0/16, то мы будем использовать наиболее общую запись. При этом туда, разумеется, не попадёт внешний интерфейс в интернет FastEthernet0/1.6, потому что его адрес — 198.51.100.2 — не из этого диапазона.  
При такой настройке любой новый интерфейс, на котором вы укажете адрес из диапазона 172.16.0.0 — 172.16.255.255, автоматически становится участником процесса OSPF. Плохо это или хорошо, зависит от ваших желаний.  
**area 0** означает принадлежность данных подсетей зоне с номером ноль \(в наших примерах только такая и будет\).

> Area 0 это не простая зона — это так называемая Backbone-area. Это означает, что она объединяет все остальные зоны, т.е. пакет, идущий от любой ненулевой зоны в любую ненулевую, обязан проходить через area 0

Как только вы задали команду **network** с правильных интерфейсов слетают слова приветствия, но отвечать на них пока некому — соседей нет:

```text
msk-arbat-gw1#sh ip OSPF neighbor 
msk-arbat-gw1#
```

Теперь пропишем настройки OSPF в Кемерово \(router ID=IP адрес Loopback интерфейса, взятый из IP-плана\):

```text
kmr-gorka-gw1(config)#router OSPF 1
kmr-gorka-gw1(config-router)#router-id 172.16.255.48
kmr-gorka-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0
```

И сразу после этого вы видите в консоли сообщение

```text
02:27:33: %OSPF-5-ADJCHG: Process 1, Nbr 172.16.255.1 on FastEthernet0/0.5 from LOADING to FULL, Loading Done
```

Такое же показывает и маршрутизатор в Москве:

```text
02:27:33: %OSPF-5-ADJCHG: Process 1, Nbr 172.16.255.48 on FastEthernet0/1.5 from LOADING to FULL, Loading Done.
```

Здесь вы можете видеть, что были успешно установлены отношения смежности и произошёл обмен LSA. Каждый маршрутизатор построил свою LSDB.

Подробная информация по соседу:

> msk-arbat-gw1\#sh ip OSPF neighbor detail  
> Neighbor **172.16.255.48**, interface address **172.16.2.18**  
> In the area 0 via interface **FastEthernet0/1.5**  
> Neighbor priority is 1, State is **FULL**, 4 state changes  
> DR is 172.16.2.17 BDR is 172.16.2.18  
> Options is 0x00  
> **Dead timer due in 00:00:38**  
> Neighbor is up for 00:02:51  
> Index 1/1, retransmission queue length 0, number of retransmission 0  
> First 0x0\(0\)/0x0\(0\) Next 0x0\(0\)/0x0\(0\)  
> Last retransmission scan length is 0, maximum is 0  
> Last retransmission scan time is 0 msec, maximum is 0 msec

Тут вся ключевая информация о состоянии соседа:  
Его router-id \(172.16.255.48\), который суть loopback, адрес интерфейса удалённой стороны, через который установлено соседство \(172.16.2.18\), тип и номер физического интерфейса \(FastEthernet0/1.5\), текущий статус \(FULL\) и Dead timer. Последний не доходит до нуля, если вы за ним понаблюдаете. Его значение уменьшается, уменьшается, а потом Оп! и снова 40. Это потому что каждые 10 секунд маршрутизаторы получают сообщения Hello и обсороколяют обнуляют Dead-интервал.

Командой **show ip route** мы можем посмотреть, как изменилась таблица маршрутизации:

> msk-arbat-gw1\#show ip route  
> Codes: C — connected, S — static, I — IGRP, R — RIP, M — mobile, B — BGP  
> D — EIGRP, EX — EIGRP external, O — OSPF, IA — OSPF inter area  
> N1 — OSPF NSSA external type 1, N2 — OSPF NSSA external type 2  
> E1 — OSPF external type 1, E2 — OSPF external type 2, E — EGP  
> i — IS-IS, L1 — IS-IS level-1, L2 — IS-IS level-2, ia — IS-IS inter area
>
> * — candidate default, U — per-user static route, o — ODR  
>   P — periodic downloaded static route
>
>   Gateway of last resort is 198.51.100.1 to network 0.0.0.0
>
>   172.16.0.0/16 is variably subnetted, 17 subnets, 5 masks  
>   C 172.16.0.0/24 is directly connected, FastEthernet0/0.3  
>   C 172.16.1.0/24 is directly connected, FastEthernet0/0.2  
>   C 172.16.2.0/30 is directly connected, FastEthernet0/1.4  
>   S 172.16.2.4/30 \[1/0\] via 172.16.2.2  
>   C 172.16.2.16/30 is directly connected, FastEthernet0/1.5  
>   C 172.16.2.32/30 is directly connected, FastEthernet0/1.7  
>   C 172.16.2.128/30 is directly connected, FastEthernet0/1.8  
>   C 172.16.2.196/30 is directly connected, FastEthernet1/0.911  
>   C 172.16.3.0/24 is directly connected, FastEthernet0/0.101  
>   C 172.16.4.0/24 is directly connected, FastEthernet0/0.102  
>   C 172.16.5.0/24 is directly connected, FastEthernet0/0.103  
>   C 172.16.6.0/24 is directly connected, FastEthernet0/0.104  
>   S 172.16.16.0/21 \[1/0\] via 172.16.2.2  
>   S 172.16.24.0/22 \[1/0\] via 172.16.2.18  
>   **O 172.16.24.0/24 \[110/2\] via 172.16.2.18, 00:13:03, FastEthernet0/1.5**  
>   C 172.16.255.1/32 is directly connected, Loopback0  
>   **O 172.16.255.48/32 \[110/2\] via 172.16.2.18, 00:13:03, FastEthernet0/1.5**  
>   198.51.100.0/28 is subnetted, 1 subnets  
>   C 198.51.100.0 is directly connected, FastEthernet0/1.6  
>   S\* 0.0.0.0/0 \[1/0\] via 198.51.100.1

Кроме известных ранее сетей \(C — directly connected и S — Static\) у нас появились два новых маршрута с пометкой O \(OSPF\). Тут всё должно быть понятно, но наблюдательный читатель спросит: “почему в таблице маршрутизации присутствуют два маршрута в сеть 172.16.24.0. Почему не останется более предпочтительный статический?” и будет прав. Вообще говоря, в таблицу маршрутизации попадает только лучший маршрут до сети — по умолчанию один. Но обратите внимание, что статический Bidirectional Forwarding Detectionмаршрут идёт до подсети 172.16.24.0/22, а полученный от OSPF до 172.16.24.0/24. Это разные подсети, поэтому обеим им нашлось место до солнцем. Дело в том, что OSPF понятия не имеет чего вы там напланировали и какой диапазон выделили — он оперирует реальными данными, то есть IP-адресом и маской:

```text
interface FastEthernet0/0.2
ip address 172.16.24.1 255.255.255.0
```

Что у нас творится в Кемерово:

> kmr-gorka-gw1\#sh ip route  
>   
> Gateway of last resort is 172.16.2.17 to network 0.0.0.0  
>   
> 172.16.0.0/16 is variably subnetted, 14 subnets, 3 masks  
> **O 172.16.0.0/24 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.1.0/24 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.2.0/30 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5**  
> C 172.16.2.16/30 is directly connected, FastEthernet0/0.5  
> **O 172.16.2.32/30 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.2.128/30 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.2.196/30 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.3.0/24 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.4.0/24 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.5.0/24 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.6.0/24 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5**  
> C 172.16.24.0/24 is directly connected, FastEthernet0/0.2  
> **O 172.16.255.1/32 \[110/2\] via 172.16.2.17, 00:32:42, FastEthernet0/0.5**  
> C 172.16.255.48/32 is directly connected, Loopback0  
> S\* 0.0.0.0/0 \[1/0\] via 172.16.2.17

Как видим, помимо настроенного прежде маршрута по умолчанию, тут появились все подсети из Москвы.  
Обратите внимание на цифры в квадратных скобках:

> S _0.0.0.0/0 \[**1/0**\]  
> O 172.16.6.0/24 \[\*110/2_\]

Первая цифра — это административная дистанция, которая у OSPF значительно больше, чем у статики и, соответственно, приоритет ниже.

На самом деле до подсети 172.16.24.0/24 трафик уже пошёл по маршруту предоставленному OSPF, потому что у него более узкая маска \(24 против 22\).  
Но попробуем удалить статические маршруты и посмотрим, что получится.

Совершенно предсказуемо всё работает:

```text
msk-arbat-gw1#ping 172.16.24.1

Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 172.16.24.1, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 8/10/15 ms
```

И это прекрасно.  
Настроим OSPF в Питере:

```text
spb-vsl-gw1(config)#router OSPF 1
spb-vsl-gw1(config-router)#router-id 172.16.255.32
spb-vsl-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0
```

Настройки, как видите, везде предельно простые. При этом замечу, что номер процесса OSFP на разных маршрутизаторах не обязательно должен быть одинаковым, но лучше, если это будет так.

На msk-arbat-gw1 у нас теперь два соседа

```text
msk-arbat-gw1#sh ip OSPF neighbor 

Neighbor ID Pri State Dead Time Address Interface
172.16.255.32 1 FULL/DROTHER 00:00:39 172.16.2.2 FastEthernet0/1.4
172.16.255.48 1 FULL/DROTHER 00:00:31 172.16.2.18 FastEthernet0/1.5
```

А вот в Питере \(и в Кемерово\) один:

```text
spb-vsl-gw1#sh ip OSPF neighbor 

Neighbor ID Pri State Dead Time Address Interface
172.16.255.1 1 FULL/DR 00:00:34 172.16.2.1 FastEthernet1/0.4
```

Дело в том, что отношения смежности устанавливаются только между непосредственно подключенными устройствами \(коммутаторы между ними не считаются\), а spb-vsl-gw1 коммуницирует с kmr-gorka-gw1 через msk-arbat-gw1, поэтому их нет в соседях друг у друга.

Последний оплот консерватизма — spb-ozerki-gw1 сдастся вам без особых проблем, как и три маршрутизатора Сибирского кольца. Делается всё по аналогии — по сути меняется только Router ID. И не забудьте удалить статические маршруты.

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg) **Задача №1**](https://linkmeup.ru/blog/17.html)  
Между маршрутизаторами в Питере надо уменьшить время обнаружения пропажи соседа. Маршрутизаторы должны отправлять сообщения Hello каждые 3 секунды, и считать друг друга недоступными, если 12 секунд не было сообщение Hello от соседа.  
[Ответ](https://linkmeup.ru/blog/17.html)

**Общий совет по всем задачам:**

> Даже если Вы сразу не знаете ответа и решения, постарайтесь подумать к чему относится условие задачи:  
> — К каким особенностям, настройкам протокола?  
> — Глобальные эти настройки или привязаны к конкретному интерфейсу?  
> Если Вы не знаете или забыли команду, такие размышления, скорее всего, приведут Вас к правильному контексту, где Вы просто, с помощью подсказки в командной строке, можете догадаться или вспомнить как настроить то, что требуется в задании.  
> Постарайтесь поразмышлять в таком ключе прежде чем пойдете в гугл или на какой-то сайт в поиске команд.

На реальной сети при выборе диапазона анонсируемых подсетей нужно руководствоваться регламентом и насущными потребностями.

Прежде чем мы перейдём к тестированию резервных линков и скорости, сделаем ещё одну полезную вещь.  
Если бы у нас была возможность отловить трафик на интерфейсе FE0/0.2 msk-arbat-gw1, который смотрит в сторону серверов, то мы бы увидели, что каждые 10 секунд в неизвестность улетают сообщения Hello. Ответить на Hello некому, отношения смежности устанавливать не с кем, поэтому и пытаться рассылать отсюда сообщения смысла нет.  
Выключается это очень просто:

```text
msk-arbat-gw1(config)#router OSPF 1
msk-arbat-gw1(config-router)#passive-interface fastEthernet 0/0.2
```

Такую команду нужно дать для всех интерфейсов, на которых точно нет соседей OSPF \(в том числе в сторону интернета\).  
В итоге картина у вас будет такая:

![](http://img-fotki.yandex.ru/get/6423/83739833.1f/0_9da8b_920c7b5b_XL.jpg)  
_Не представляю, как вы до сих пор не запутались_

Кроме того, эта команда повышает безопасность — никто из этой сети не прикинется маршрутизатором и не будет пытаться поломать нас полностью.

Теперь займёмся самым интересным — тестированием.  
Ничего сложного нет в настройке OSPF на всех маршрутизаторах в Сибирском кольце — сделаете сами.  
И после этого картина должна быть следующей:

```text
msk-arbat-gw1#sh ip OSPF neighbor 

Neighbor ID Pri State Dead Time Address Interface
172.16.255.32 1 FULL/DR 00:00:31 172.16.2.2 FastEthernet0/1.4
172.16.255.48 1 FULL/DR 00:00:31 172.16.2.18 FastEthernet0/1.5
172.16.255.80 1 FULL/BDR 00:00:36 172.16.2.130 FastEthernet0/1.8
172.16.255.112 1 FULL/BDR 00:00:37 172.16.2.197 FastEthernet1/0.911
```

Питер, Кемерово, Красноярск и Владивосток — непосредственно подключенные.

> msk-arbat-gw1\#show ip route  
>   
> Gateway of last resort is 198.51.100.1 to network 0.0.0.0  
>   
> 172.16.0.0/16 is variably subnetted, 25 subnets, 6 masks  
> C 172.16.0.0/24 is directly connected, FastEthernet0/0.3  
> C 172.16.1.0/24 is directly connected, FastEthernet0/0.2  
> C 172.16.2.0/30 is directly connected, FastEthernet0/1.4  
> S 172.16.2.4/30 \[1/0\] via 172.16.2.2  
> C 172.16.2.16/30 is directly connected, FastEthernet0/1.5  
> C 172.16.2.32/30 is directly connected, FastEthernet0/1.7  
> C 172.16.2.128/30 is directly connected, FastEthernet0/1.8  
> O 172.16.2.160/30 \[110/2\] via 172.16.2.130, 00:05:53, FastEthernet0/1.8  
> O 172.16.2.192/30 \[110/2\] via 172.16.2.197, 00:04:18, FastEthernet1/0.911  
> C 172.16.2.196/30 is directly connected, FastEthernet1/0.911  
> C 172.16.3.0/24 is directly connected, FastEthernet0/0.101  
> C 172.16.4.0/24 is directly connected, FastEthernet0/0.102  
> C 172.16.5.0/24 is directly connected, FastEthernet0/0.103  
> C 172.16.6.0/24 is directly connected, FastEthernet0/0.104  
> S 172.16.16.0/21 \[1/0\] via 172.16.2.2  
> S 172.16.24.0/22 \[1/0\] via 172.16.2.18  
> O 172.16.24.0/24 \[110/2\] via 172.16.2.18, 00:24:03, FastEthernet0/1.5  
> O 172.16.128.0/24 \[110/2\] via 172.16.2.130, 00:07:18, FastEthernet0/1.8  
> O 172.16.129.0/26 \[110/2\] via 172.16.2.130, 00:07:18, FastEthernet0/1.8  
> C 172.16.255.1/32 is directly connected, Loopback0  
> O 172.16.255.32/32 \[110/2\] via 172.16.2.2, 00:24:03, FastEthernet0/1.4  
> O 172.16.255.48/32 \[110/2\] via 172.16.2.18, 00:24:03, FastEthernet0/1.5  
> O 172.16.255.80/32 \[110/2\] via 172.16.2.130, 00:07:18, FastEthernet0/1.8  
> O 172.16.255.96/32 \[110/3\] via 172.16.2.130, 00:04:18, FastEthernet0/1.8  
> \[110/3\] via 172.16.2.197, 00:04:18, FastEthernet1/0.911  
> O 172.16.255.112/32 \[110/2\] via 172.16.2.197, 00:04:28, FastEthernet1/0.911  
> 198.51.100.0/28 is subnetted, 1 subnets  
> C 198.51.100.0 is directly connected, FastEthernet0/1.6  
> S\* 0.0.0.0/0 \[1/0\] via 198.51.100.1

Все обо всех всё знают.  
Каким маршрутом трафик доставляется из Москвы в Красноярск? Из таблицы видно, что krs-stolbi-gw1 подключен напрямую и это же видно из трассировки:

![](http://img-fotki.yandex.ru/get/6511/83739833.1f/0_9c868_9702fcf4_XL.jpg)

```text
msk-arbat-gw1#traceroute 172.16.128.1
Type escape sequence to abort.
Tracing the route to 172.16.128.1

1 172.16.2.130 35 msec 8 msec 5 msec
```

Теперь рвём интерфейс между Москвой и Красноярском и смотрим, через сколько линк восстановится.  
Не проходит и 5 секунд, как все маршрутизаторы узнали о происшествии и пересчитали свои таблицы маршрутизации:

```text
msk-arbat-gw1(config-subif)#do sh ip ro 172.16.128.0
Routing entry for 172.16.128.0/24
Known via "OSPF 1", distance 110, metric 4, type intra area
Last update from 172.16.2.197 on FastEthernet1/0.911, 00:00:53 ago
Routing Descriptor Blocks:
* 172.16.2.197, from 172.16.255.80, 00:00:53 ago, via FastEthernet1/0.911
Route metric is 4, traffic share count is 1

vld-gw1#sh ip route 172.16.128.0
Routing entry for 172.16.128.0/24
Known via "OSPF 1", distance 110, metric 3, type intra area
Last update from 172.16.2.193 on FastEthernet1/0, 00:01:57 ago
Routing Descriptor Blocks:
* 172.16.2.193, from 172.16.255.80, 00:01:57 ago, via FastEthernet1/0
Route metric is 3, traffic share count is 1

msk-arbat-gw1#traceroute 172.16.128.1
Type escape sequence to abort.
Tracing the route to 172.16.128.1

1 172.16.2.197 4 msec 10 msec 10 msec 
2 172.16.2.193 8 msec 11 msec 15 msec 
3 172.16.2.161 15 msec 13 msec 6 msec
```

То есть теперь Красноярска трафик достигает таким путём:

![](http://img-fotki.yandex.ru/get/6613/83739833.1f/0_9c869_7d771721_XL.jpg)

Как только вы поднимете линк, маршрутизаторы снова вступают в связь, обмениваются своими базами, пересчитываются кратчайшие пути и заносятся в таблицу маршрутизации.  
На видео всё это более наглядно. Рекомендую [ознакомиться](http://www.youtube.com/watch?v=8zxdW6ag8Us).  
[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №2**](https://linkmeup.ru/blog/20.html)  
После настройки OSPF на маршрутизаторах в сибирском кольце, все сети, которые находятся за маршрутизатором в центральном офисе в Москве \(msk-arbat-gw1\), для Хабаровска доступны по двум маршрутам \(через Красноярск и через Владивосток\). Но, так как канал через Красноярск лучше, то надо изменить настройки по умолчанию таким образом, чтобы Хабаровск использовал канал через Красноярск, когда он доступен. И переключался на Владивосток только если что-то случилось с каналом на Красноярск.  
[Ответ](https://linkmeup.ru/blog/20.html)

Как любой хороший протокол, OSPF поддерживает аутентификацию — два соседа перед установлением соотношений соседства могут проверять подлинность полученных OSPF-сообщений. Оставляем на самостоятельное изучение — довольно просто.

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №3**](https://linkmeup.ru/blog/24.html)  
С провайдером «Филькин сертификат» случилась неприятная история. Из-за их ошибки в настройках VPN на маршрутизатор во Владивостоке начали приходить какие-то непонятные маршруты, вероятно, от другого клиента или внутренние самого сети провайдера. Некоторые сети пересекались с локальными сетями и была потеряна связь с некоторыми участками сети. После этого случая было решено защититься на будущее от подобных ситуаций.  
Ситуация, вообще говоря, надуманная и маловероятная, но в качестве задачки подойдёт.  
На участке между Москвой и Владивостоком необходимо настроить маршрутизаторы таким образом, чтобы они, при установке отношений соседства, проверяли ещё и установленный пароль. Пароль должен быть: MskVladPass и передаваться он должен в виде хеша md5 \(номер ключа 1\).  
[Ответ](https://linkmeup.ru/blog/24.html)
