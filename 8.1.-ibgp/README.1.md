# IBGP

Теперь обратимся к настройке маршрутизаторов нашей AS с точки зрения IBGP.  

Во-первых, как мы говорили ранее, IBGP обычно устанавливается между Loopback-интерфейсами для повышения доступности, поэтому в первую очередь создадим их:  

На всех маршрутизаторах на интерфейсе Loopback0 настраиваем IP-адрес X.X.X.X, где Х — номер маршрутизатора (это исключительно для примера и не вздумайте такое делать на реальной сети):  

**R1**  

```text
interface Loopback0
ip address 1.1.1.1 255.255.255.255
```

**R2**  

```text
interface Loopback0
ip address 2.2.2.2 255.255.255.255
```

**R3**  

```text
interface Loopback0
ip address 3.3.3.3 255.255.255.255
```

**R4**  

```text
interface Loopback0
ip address 4.4.4.4 255.255.255.255
```

Они станут Router ID и для OSPF и для BGP.  

Кстати, об OSPF. Как правило, IBGP «натягивается» поверх существующего на сети IGP. IGP обеспечивает связность всех маршрутизаторов между собой по IP, быструю реакцию на изменения в топологии и перенос маршрутной информации о внутренних сетях.  

## Настройка внутренней маршрутизации. OSPF

Собственно к этому и перейдём.  

Наша задача, чтобы все знали обо всех линковых подсетях, адресах Loopback-интерфейсов и, естественно, о наших белых адресах.  

Конфигурация OSPF:  
**R1**  

```text
router ospf 1
network 1.1.1.1 0.0.0.0 area 0
network 10.0.0.0 0.255.255.255 area 0
network 100.0.0.0 0.0.1.255 area 0
```

**R2**  

```text
router ospf 1
network 2.2.2.2 0.0.0.0 area 0
network 10.0.0.0 0.255.255.255 area 0
network 100.0.0.0 0.0.1.255 area 0
```

**R3**  

```text
router ospf 1
network 3.3.3.3 0.0.0.0 area 0
network 10.0.0.0 0.255.255.255 area 0
network 100.0.0.0 0.0.1.255 area 0
```

**R4**  

```text
router ospf 1
network 4.4.4.4 0.0.0.0 area 0
network 10.0.0.0 0.255.255.255 area 0
network 100.0.0.0 0.0.1.255 area 0
```

После этого появляется связность со всеми Loopback-адресами.  

![](http://img-fotki.yandex.ru/get/9092/83739833.2f/0_c70ab_6eca16b1_XL.png)  

## Настраиваем BGP

На каждом узле нужно настроить всех соседей вручную:  

**R1**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 2.2.2.2 remote-as 64500
neighbor 2.2.2.2 update-source Loopback0
neighbor 3.3.3.3 remote-as 64500
neighbor 3.3.3.3 update-source Loopback0
neighbor 4.4.4.4 remote-as 64500
neighbor 4.4.4.4 update-source Loopback0
```

Команда вида **neighbor 2.2.2.2 remote-as 64500** объявляет соседа и сообщает, что он находится в AS 64500, BGP понимает, что это та же AS, в которой он сам работает и далее считает 2.2.2.2 своим IBGP-партнёром.  

Команда вида **neighbor 2.2.2.2 update-source Loopback0** сообщает, что соединение будет устанавливаться с адреса интерфейса Loopback. Дело в том, что на другой стороне (на 2.2.2.2) сосед настроен, как 1.1.1.1 и именно с этого адреса ждёт все BGP-сообщения.  

Такую настройку применяем на всех узлах нашей AS:  

**R2**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 1.1.1.1 remote-as 64500
neighbor 1.1.1.1 update-source Loopback0
neighbor 3.3.3.3 remote-as 64500
neighbor 3.3.3.3 update-source Loopback0
neighbor 4.4.4.4 remote-as 64500
neighbor 4.4.4.4 update-source Loopback0
```

**R3**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 1.1.1.1 remote-as 64500
neighbor 1.1.1.1 update-source Loopback0
neighbor 2.2.2.2 remote-as 64500
neighbor 2.2.2.2 update-source Loopback0
neighbor 4.4.4.4 remote-as 64500
neighbor 4.4.4.4 update-source Loopback0
```

**R4**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 1.1.1.1 remote-as 64500
neighbor 1.1.1.1 update-source Loopback0
neighbor 2.2.2.2 remote-as 64500
neighbor 2.2.2.2 update-source Loopback0
neighbor 3.3.3.3 remote-as 64500
neighbor 3.3.3.3 update-source Loopback0
```

Сейчас мы можем проверить, что отношения соседства установились благополучно  

![](http://img-fotki.yandex.ru/get/9118/83739833.2f/0_c70ac_86f7c863_XL.png)  

Все маршруты есть в нашей таблице BGP.  

Сеть 130.0.0.0/24 видно на R1:  

![](http://img-fotki.yandex.ru/get/9320/83739833.2f/0_c70ae_d3183447_XL.png)  

Сеть 103.0.0.0/22 видно на R4:  

![](http://img-fotki.yandex.ru/get/9165/83739833.2f/0_c70af_f10a38e1_XL.png)  

Пора проверить сквозной пинг c R7 (нашего клиента) в Интернет (103.0.0.1)?  

![](http://img-fotki.yandex.ru/get/6721/83739833.2f/0_c70b0_908ebe44_XL.png)  

Приехали.  
Не будем долго мучить читателя и сразу посмотрим в таблицу маршрутизации, R4.  

![](http://img-fotki.yandex.ru/get/9115/83739833.2f/0_c70b1_2b85bee2_XL.png)  

А на R7 при этом:  

![](http://img-fotki.yandex.ru/get/9352/83739833.2f/0_c70b5_9c45d017_XL.png)  

А? Где мои маршруты? Где все мои маршруты? R4 ничего не знает про сети Балаган-Телекома, Филькина Сертификата, Интернета, соответственно нет их и на R7.  

Помните, мы выше говорили про Next-Hop? Мол, он не меняется при передаче по IBGP?  

Обратите внимание на Next-Hop полученных R4 маршрутов:  

![](http://img-fotki.yandex.ru/get/9250/83739833.2f/0_c70b2_df866348_XL.png)  

Несмотря на то, что они пришли на R4 от R1 и R2, адреса Next-Hop на них стоят R5 и R6 — то есть не менялись.  

Это значит, что трафик в сеть 103.0.0.0/22 R4 должен отправить на адрес 101.0.0.1, ну, либо на 102.0.0.1\. Где они в таблице маршрутизации? Нету их в таблице маршрутизации. Ну, и это естественно — откуда им там взяться.  

Для решения этой проблемы у нас есть 3 пути:  
1) Настроить статические маршруты до этих адресов — то ещё удовольствие, даже если это шлюз последней надежды.  
2) Добавить эти интерфейсы (в сторону провайдеров) в домен IGP-маршрутизации. Тоже вариант, но, как известно, внешние сети не рекомендуется добавлять в IGP.  
3) Менять адрес Next-Hop при передаче IBGP-соседям. Красиво и масштабируемо. А ситуации, которая нам помешает это реализовать, просто не может быть.  

В итоге добавляем в BGP ещё такую команду: **neghbor 2.2.2.2 Next-Hop-self**. Для каждого соседа, на каждом узле.  
После этого мы видим следующую ситуацию,  

![](http://img-fotki.yandex.ru/get/9348/83739833.2f/0_c70b3_3d1d6423_XL.png)  

А уж, как добраться до адреса 1.1.1.1 — мы знаем благодаря OSPF:  

![](http://img-fotki.yandex.ru/get/6722/83739833.2f/0_c70b4_dfe10b83_XL.png)  

Как видите в таблице R7 уже появилась все интересные нам сети.  

![](http://img-fotki.yandex.ru/get/9349/83739833.2f/0_c70b6_8ef133b9_XL.png)  

Теперь пинг успешной проходит:  

![](http://img-fotki.yandex.ru/get/6705/83739833.2f/0_c70b7_fb43e5e3_XL.png)  

![](http://img-fotki.yandex.ru/get/6712/83739833.2f/0_c70b8_b6a5ffa4_L.png)  

> Очень простой вопрос: откуда такие гигантские задержки в трассировке? А ещё часто и такая ситуация бывает:  
>   
> ![](http://img-fotki.yandex.ru/get/9348/83739833.2f/0_c70b9_3536f5f2_XL.png)

[Конфигурация устройств](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub)  


[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 4**](https://linkmeup.ru/blog/96.html)  
Необходимо настроить такие правила работы с соседними AS:  
— от всех соседних AS принимаются префиксы только если в них количество автономных систем в пути не более 10 (в реальной жизни порядок этого значения может быть около 100).  
— все префиксы, которые принимаются от клиентов, должны быть с маской не более 24 бит.  
Конфигурация и схема: [базовые](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub).  
Подробности задачи [тут](https://linkmeup.ru/blog/96.html).  


### Что мы можем улучшить?

Разумеется, процесс настройки BGP. Всё-таки это трудозатраты — сделать весьма похожие настройки на каждом узле. Для упрощения вводится понятие peer-group, которая исходя из названия позволяет объединять соседей в группы и одной командой задавать нужные параметры сразу всем.  
Дабы не быть голословными, внедрим это на нашей сети:  

**R1**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor AS64500 peer-group
neighbor AS64500 remote-as 64500
neighbor AS64500 update-source Loopback0
neighbor AS64500 Next-Hop-self
neighbor 2.2.2.2 peer-group AS64500
neighbor 3.3.3.3 peer-group AS64500
neighbor 4.4.4.4 peer-group AS64500
```

Команда **neighbor AS64500 peer-group** создаёт группу соседей AS64500\.  
Команда **neighbor AS64500 remote-as 64500** сообщает, что все соседи находятся в AS 64500.  
Команда **neighbor AS64500 update-source Loopback0** указывает, что со всеми соседями соединение будет устанавливаться с адреса Loopback-интрефейса.  
Команда **neighbor AS64500 Next-Hop-self** заставляет маршрутизатор менять адрес Next-Hop на свой при передаче анонсов всем соседям.  
Дальше, собственно, мы добавляем соседей в эту группу.  

Причём мы можем запросто копировать команды конфигурации группы соседей на другие маршрутизаторы, меняя только адреса соседей.  

> Пара замечаний по Peer-group:  
> 1) Для всех участников группы политики должны быть идентичны.  
> 2) На самом деле cisco уже давно использует динамические Update-группы. Это позволяет сэкономить ресурсы процессора, так как обработка проводится не по разу на каждого члена группы, а один раз на всю группу. Фактические Peer-группы только облегчают конфигурацию, а оптимизация отдана на откуп Update-групп.

> Наверняка, у молодых зелёных инженеров возник вопрос: почему нельзя информацию про публичные адреса передавать по IBGP? Он же, вроде бы, для этого и предназначен? И даже более общий вопрос, почему нельзя обойтись вообще одним BGP, без OSPF или IS-IS, например? (Нет, серьёзно, на форумах иногда вскипают холивары на тему BGP vs OSPF). Ну, по сути ведь тоже протокол маршрутизации — какая разница, передавать информацию между AS или между маршрутизаторами — есть же Internal BGP.  
> На это я хочу сказать, что достаточно вам будет поработать немного с BGP на реальной сети, чтобы понять всю безумность такой затеи.  
>   
> **Самое главное препятствие — Full Mesh**. Придётся устанавливать соседство со всеми всеми маршрутизаторами вручную. OMG, мне дороги моя жизнь и здоровье. (Да, даже не смотря на наличие Route Reflector’ов и скриптов — это лишние операции)  
> **Другая проблема — медленная реакция и Дистанционно-Векторный подход** к распространению маршрутной информации.  
> Да и тут можно резонно возразить, что, дескать, существует BFD. Однако он уменьшит время обнаружение проблемы, но сходимость/восстановление связности всё равно будет медленным.  
> **Третий тонкий момент — отсутствие возможности автоматического изучения соседей.** Что ведёт к ручной их конфигурации.  
> Из всего вышеуказанного вытекают проблемы масштабируемости и обслуживания.  
>   
> Просто попробуйте сами использовать BGP вместо IGP на сети из 10 маршрутизаторов, и всё станет ясно.  
>   
> То же самое касается и распространения белых адресов — IBGP с этим справится, но на каждом маршрутизаторе придётся вручную прописывать все подсети.  
> Ну например, наша сеть 100.0.0.0/23\. Допустим, к маршрутизатору R3 подключены 3 клиента по линковым адресам: 100.0.0.8/30, 100.0.0.12/30 и 100.0.0.16/0\.  
> Так вот эти 3 подсети вам нужно будет ввести в BGP тремя командами **network**, в то время как в IGP достаточно активировать протокол на интерфейсе.  
> Можно, конечно, прибегнуть к хитрой редистрибуции маршрутов из IGP, но это попахивает уже костылями и ещё менее прозрачной конфигурацией.  
>   
> К чему всё это мы ведём? eBGP — протокол маршрутизации, без дураков. В то же время iBGP — не совсем. Он больше похож на приложение верхнего уровня, организующее распространение маршрутной информации по всей сети. В неизменном виде, а не сообщая при каждой итерации соседу «вон туда через меня». У IGP такое поведение тоже иногда встречается, но там это исключение, а тут — норма.  
> Я хочу подчеркнуть ещё раз, IGP и IBGP работают в паре, в связке, каждый из них выполняет свою работу.  
> IGP обеспечивает внутреннюю IP-связность, быструю (читай мгновенную) реакцию на изменения в сети, оповещение всех узлов об этом как можно быстрее. Он же знает о публичных адресах **нашей** AS.  
> IBGP занимается обработкой Интернетных маршрутов в нашей AS и их транзитом от Uplink’a к клиентам и обратно. Обычно он ничего не знает о структуре внутренней сети.  
>   
> Если вам пришёл в голову вопрос «что лучше BGP или IS-IS?» — это хорошо, значит у вас пытливый ум, но вы должны отчётливо понимать, что верный ответ тут только один — это принципиально разные вещи, их нельзя сравнивать и выбирать мисс “технология маршрутизации 2013”. **IBGP работает поверх IGP**.


[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 5**](https://linkmeup.ru/blog/97.html)  
Вышестоящая AS 604503 агрегирует несколько сетей, в том числе и нашу, в один диапазон 100.0.0.0/6\. Но этот суммарный префикс вернулся в нашу автономную систему, хотя и не должен был.  
Настроить R8 так, чтобы агрегированный префикс не попадал в таблицу BGP маршрутизаторов, которые анонсируют подсети этого префикса. Не использовать фильтрацию для этого.  

Конфигурация и схема: [базовые](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub).  

Подробности задачи [тут](https://linkmeup.ru/blog/97.html).  


## Проблема Эн квадрат

На этом месте тему IBGP можно было бы закрыть, если бы не одно «НО» — Full Mesh. Мы говорили о проблемах полносвязной топологии, когда обсуждали [OSPF](https://linkmeup.ru/blog/33.html). Там выходом являлись DR — Designated Router, позволяющие сократить количество связей между маршрутизаторам с n*(n-1)/2 до n-1\. Но, если в случае OSPF такая топология была, скорее, исключением, потому что больше 2-3 маршрутизаторов в одном L2-сегменте бывает довольно редко, то для IBGP — это самая обычная практика. У «больших» счёт BGP-маршрутизаторов внутри AS идёт на десятки. А уже для 10 устройств на **каждом** узле нужно будет прописать 9 соседей, то есть всего 45 связей и 90 команд **neighbor** как минимум. Не хило так.  
Итак, мы подошли к таким понятиям, как _Route Reflector_ и _Confederation_. Уж не знаю почему, но эта тема меня всегда пугала какой-то надуманной сложностью.  

### Route Reflectror

В чём суть понятия Route Reflector? Это специальный IBGP-маршрутизатор, который, исходя из дословного его перевода, выполняет функцию отражения маршрутов — ему присылает маршрут один сосед, а он рассылает его всем другим. То есть фактически на IBGP-маршрутизаторах вам нужно настроить сессию только с одним соседом — с Route Reflector'ом, а не с девятью. Всё довольно просто и тут прямая аналогия с тем самым DR OSPF.  

Чуть больше о правилах работы RR.  
Во-первых введём понятия _клиент RR_ и _не-клиент RR_.  

Для данного маршрутизатора клиент — iBGP сосед, который специально объявлен, как RR client, и для которого действуют особые правила. Не-клиент — iBGP сосед, который не объявлен, как RR client  
RR серверов может быть (и должно быть в плане отказоустойчивости) несколько. И понятия клиент/не-клиент строго локальны для каждого RR-сервера.  
RR-сервер (или несколько) в совокупности с со своими клиентами формируют _кластер_.  

![](http://img-fotki.yandex.ru/get/6721/83739833.2f/0_c7086_f2403a85_XL.png)  

#### Правила работы RR

*   Если RR получил маршрут от клиента, он отправляет его всем своим клиентам, не-клиентам-соседям и внешним (EBGP) соседям.  

    ![](http://habrastorage.org/storage3/d8e/ef1/72e/d8eef172ea5a66f7c7336659fd36c90c.gif)  

*   Если RR получил маршрут от не-клиента, он отправляет его всем клиентам и EBGP-соседям. Не-клиентам маршруты НЕ отправляются (потому что они эти маршруты уже получили напрямую от исходного маршрутизатора).  

    ![](http://habrastorage.org/storage3/935/7b0/709/9357b070908dee13d1ee17aeb37541d8.gif)  

*   Если RR получил маршрут от EBGP-соседа, он отправляет его всем своим клиентам, не-клиентам-соседям и внешним соседям.  

    ![](http://habrastorage.org/storage3/849/16c/5de/84916c5de42918394c999fdea5aad280.gif)  

*   Если клиент получил маршрут от RR, он его может отправить только EBGP-соседу.

Как мы сказали выше, в сети может быть несколько Route-reflector’ов. Это нормально, это не вызовет образование петли, потому что существует атрибут Originator ID — как только RR получит маршрут, где указан он сам, как отправитель этого маршрута, он его отбросит. Каждый RR в таком случае будет иметь таблицу маршрутов BGP точно такую же, как у других. Это вынужденная избыточность, позволяющая значительно увеличить стабильность, но при этом у вас должна быть достаточная производительность самих устройств, чтобы, например, поддерживать по паре Full View на каждом.  
Но несколько RR могут собираться в кластеры и <s>разрушать деревни</s> обеспечивать экономию ресурсов — таблица BGP будет делиться между несколькими RR.  
Принадлежность к одному кластеру настраивается на каждом RR и определяется атрибутом Cluster ID.  

> И вот тут тонкий момент — считается, что Best Practice — это настройка одинакового Cluster-ID на всех RR, но на самом деле это не всегда так. Выбирать нужно, исходя из дизайна вашей сети. Более того, часто рекомендуют даже намеренно разделять Route Reflector’ы — как ни странно, это увеличивает стабильность сети.  
> Дабы не растекаться мысью по древу, просто [дам ссылку](http://blog.ipexpert.com/2012/02/20/understanding-bgp-originator-id-and-cluster-id/) на материал об этом.

Вот так выглядит обычная схема с RR:  

![](http://img-fotki.yandex.ru/get/9112/83739833.2f/0_c7087_53b1a2bd_XL.png)  

Схема с основным и резервным RR:  

![](http://img-fotki.yandex.ru/get/9110/83739833.2f/0_c7088_2e99d4d4_XL.png)  

Внутри кластера между всему RR должна быть полная связность.  
Кластеров может быть несколько и между ними также следует создавать Full-Mesh сеть:  

![](http://img-fotki.yandex.ru/get/9169/83739833.2f/0_c7089_aae089f8_XL.png)  

Повторимся, что кластер: это Рут-рефлектор (один или несколько) вместе со всеми своими клиентами.  
Кроме того, часто практикуют иерархические RR. Например, так:  

![](http://img-fotki.yandex.ru/get/9104/83739833.2f/0_c708a_5c5cb964_XL.png)  

RR1 получает маршруты от удалённой AS и раздаёт их своим дочерним RR (Client/RR1), которые в свою очередь раздают их клиентам.  
Это имеет смысл только в достаточно крупных сетях.  

Относительно Route Reflector'ов важно понимать, что сам маршрутизатор, выполняющий функции RR не обязательно участвует в передаче данных. Более того, часто RR специально выносят за пределы пути передачи трафика, чтобы он выполнял исключительно обязанности по передаче маршрутов, чтобы не увеличивать нагрузку на него.  

### Практика RR

Для примера предположим, что в нашей сети в качестве RR будет выступать R1.  
Вот конфигурация самого простого случая RR — одинокого, без кластера.  

**R1**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor AS64500 peer-group
neighbor AS64500 remote-as 64500
neighbor AS64500 update-source Loopback0
neighbor AS64500 route-reflector-client
neighbor AS64500 Next-Hop-self
neighbor 2.2.2.2 peer-group AS64500
neighbor 3.3.3.3 peer-group AS64500
neighbor 4.4.4.4 peer-group AS64500
neighbor 101.0.0.1 remote-as 64501
```

**R2**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 1.1.1.1 remote-as 64500
neighbor 1.1.1.1 update-source Loopback0
neighbor 1.1.1.1 Next-Hop-self
neighbor 102.0.0.1 remote-as 64502
```

**R3**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 1.1.1.1 remote-as 64500
neighbor 1.1.1.1 update-source Loopback0
neighbor 1.1.1.1 Next-Hop-self
```

**R4**  

```text
router bgp 64500
network 100.0.0.0 mask 255.255.254.0
neighbor 1.1.1.1 remote-as 64500
neighbor 1.1.1.1 update-source Loopback0
neighbor 1.1.1.1 Next-Hop-self
neighbor 100.0.0.6 remote-as 64504
```

Обратите внимание на команду "**neighbor AS64500 route-reflector-client**", добавившуюся в настройку R1 и то, что конфигурация BGP на всех других устройствах полностью идентична, за исключением внешних соседей (102.0.0.1 для R2 и 100.0.0.6 для R4).  

В общем-то внешне ничего не поменяется. R4, например, всё будет видеть точно также, за исключением количества соседей:  

![](http://img-fotki.yandex.ru/get/9355/83739833.2f/0_c70ba_e4ae5372_XL.png)  

Обратите внимание на то, что Route Reflector не меняет Next-Hop отражённых маршрутов на свой, несмотря на наличие параметра _Next-Hop-self_.  

На самом Route Reflector'е отличие будет выглядеть так:  

![](http://img-fotki.yandex.ru/get/9323/83739833.2f/0_c70bb_247e7307_XL.png)  

Если смотреть по конкретным маршрутам:  

![](http://img-fotki.yandex.ru/get/6717/83739833.2f/0_c70bc_79d6da08_L.png)  

Здесь видно полную подсеть, количество путей до неё, какой из них лучший, в какую таблицу он добавлен, куда передаётся (update-group 2 — как раз наш кластер).  
Далее перечисляются все эти пути, содержащие такие важные параметры, как AS-Path, Next-Hop, Origin итд, а также информацию о том, что например, первый маршрут был получен от RR-клиента.  

Эту информацию можно успешно использовать для траблшутинга. Вот так, например выглядит её вывод, когда не настроен Next-Hop-self:  

![](http://img-fotki.yandex.ru/get/9112/83739833.2f/0_c70bd_c6003183_L.png)  

[Конфигурация устройств](https://docs.google.com/document/d/1LUf-RSx62_QUN5KNARufwSDz8duq1D9fCRa6u6pZlPk/pub).  

#### Проблема резервирования

Какая сейчас с рут-рефлектором есть проблема? У всех маршрутизаторов связи установлены только с ним. И если R1 вдруг выйдет из строя, пиши пропало — сеть ляжет.  
Для этих целей, давайте настроим кластер и в качестве второго RR выберем R2\.  
То есть теперь на R3 и R4 нужно поднимать соседства не только с R1, но и с R2.  

Теперь sh ip bgp update-group выглядит так:  

![](http://img-fotki.yandex.ru/get/9515/83739833.2f/0_c70be_1692e555_XL.png)  

Один внешний, один внутренний — не RR-клиент и два внутренних RR-клиента.  
Аналогично на R2:  

![](http://img-fotki.yandex.ru/get/9492/83739833.2f/0_c70bf_ea7346a7_XL.png)  

На клиентах у нас теперь два соединения с RR:  

![](http://img-fotki.yandex.ru/get/9171/83739833.2f/0_c70c0_e5d51188_XL.png)  

Обратите внимание, в сообщениях Update теперь появились два новых атрибута: Cluster-List и Originator-ID. Исходя из названия, они несут в себе номер RR-кластера и идентификатор отправителя анонса:  

R1<->R2  
[![](http://img-fotki.yandex.ru/get/9263/83739833.2f/0_c70c1_6fbf2b26_XXXL.png)](http://fotki.yandex.ru/users/ait-it/view/815297/)  

Эти параметры добавляются только маршрутам, передающимся по IBGP.  

Они необходимо для того, чтобы избежать образования петель. Если, например, маршрут прошёл несколько кластеров и вернулся в исходный, то в параметре Cluster-List среди всех прочих, маршрутизатор увидит номер своего кластера, и после этого удалит маршрут.  

![](http://img-fotki.yandex.ru/get/9107/83739833.30/0_c756a_1f83ff6b_XXL.png)  

> Попробуйте ответить на вопрос, зачем нужен атрибут Originator-ID? Разве Cluster-List не исчерпывает все варианты?

Если сейчас даже сжечь R1, то связь частично ляжет только на время обнаружения проблемы и перестроения таблиц маршрутизации (в худшем случае это 3 минуты ожидания Keepalive сообщения BGP и ещё какое-то время на изучение новых маршрутов).  
Но, если дизайн сети у вас предполагал, что RR — это самостоятельные железки, и через них не ходил трафик (то есть они занимались исключительно распространением маршрутов), то, вполне вероятно, что перерыва трафика не будет вовсе. Во-первых, отправитель только через 3 минуты заметит, что что-то не так с RR — в течение этого времени маршрут у него всё-равно будет, а поскольку он ведёт не через бесславно погибший RR, трафик будет ходить вполне благополучно. По прошествии этих трёх минут отправитель переключится на резервный RR и получит от него новый актуальный маршрут. Таким образом связь не будет прервана.  

Суть иерархических рут-рефлекторов лишь в том, что один из них является клиентом другого. Это помогает выстроить более понятную и прозрачную схему работы, которую будет проще траблшутить далее.  
На нашей сети это лишено какого бы то ни было смысла, поэтому данный случай рассматривать не будем.  

## Конфедерации

Другой способ решения проблемы Full-Mesh — это конфедерации или иначе их называют sub-AS, под-АС. По сути — это маленькая виртуальная АС внутри большой настоящей АС.  

Каждая конфедерация ведёт себя как взрослая AS — внутри полная связность, снаружи, как Лейбниц на душу положит — IBGP работает тут по принципу EBGP (с некоторыми оговорками), граничные маршрутизаторы конфедераций, ведут себя как EBGP-соседи, должны быть подключены напрямую.  

Пример топологии:  

![](http://img-fotki.yandex.ru/get/9355/83739833.2f/0_c70c5_b355126f_XXL.png)  

Когда маршруты передаются внутри АС между конфедерациями в их AS-Path добавляется номер конфедерации (сегменты AS_CONFED_SEQ и AS_CONFED_SET) для избежания петель. Как только маршрут покидает AS, удаляются все эти номера, чтобы внешний мир о них не знал.  

Встречается он довольно редко из-за своей слабой масштабируемости и непрозрачности, поэтому рассматривать мы его не будем.  
Более подробно можно почитать на [xgu.ru](http://xgu.ru/wiki/BGP_%D0%B2_Cisco#.D0.9A.D0.BE.D0.BD.D1.84.D0.B5.D0.B4.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.28confederation.29).  

____________________________  

# Атрибуты BGP

Последняя тема, которую мы затронем касательно BGP — это его атрибуты. Мы их уже начали рассматривать в основной статье (AS-Path и Next-Hop, например). Теперь же имеющиеся знания систематизируем и дополним.  

Они делятся на четыре типа:  

*   Хорошо известные обязательные (Well-known Mandatory)
*   Хорошо известные необязательные (Well-known Discretionary)
*   Опциональные передаваемые/транзитивные (Optional Transitive)
*   Опциональные непередаваемые/нетранзитивные (Optional Non-transitive)

#### Хорошо известные обязательные (Well-known Mandatory)

Это атрибуты, которые должны присутствовать в анонсах **всегда**, и **каждый** BGP-маршрутизатор должен их знать.  
Следующие три атрибута и только они принадлежат к этому типу.  
_**Next-Hop**_ говорит маршрутизатору, получающему анонс, о том, куда отправлять пакет.  
При передаче маршрута между различными AS значение Next-Hop меняется на адрес отправляющего маршрутизатора. Внутри AS атрибут Next-Hop по умолчанию не меняется при передаче от одного IBGP-оратора другому. Выше мы уже рассматривали почему.  

_**AS-path**_ несёт в себе список всех Автономных Систем, которые нужно преодолеть для достижения цели. Используется для выбора лучшего пути и для исключения петель маршрутизации. Когда маршрут передаётся из одной AS в другую, в AS-path вставляется номер **отправляющей** AS. При передаче внутри AS параметр не меняется.  

_**Origin**_ сообщает, как маршрут зародился — командой network (IGP — значение 0) или редистрибуцией (Incomplete — значение 2). Значение 1 (EGP) — уже не встречается ввиду того, что протокол EGP не используется. Назначается единожды маршрутизатором-папой, сгенерировавшим маршрут, и более нигде не меняется. По сути означает степень надёжности источника. IGP — самый крутой.  
[![](http://img-fotki.yandex.ru/get/9513/83739833.30/0_c757f_39674162_XXXL.png)](http://fotki.yandex.ru/users/ait-it/view/816511/)  

#### Хорошо известные необязательные (Well-known Discretionary)

Эти атрибуты должны знать все BGP-маршрутизаторы, но их присутствие в анонсе не требуется. Хочешь — есть, не хочешь — не есть.  

Примеры:  
_**Local Preference**_ помогает выбрать один из нескольких маршрутов в одну сеть. Данный атрибут может передаваться лишь в пределах одной AS. Если анонс с Local Preference приходит от EBGP-партнёра, атрибут просто игнорируется — мы не можем с помощью Local Preference управлять маршрутами чужой AS.  

_**Atomic Aggregate**_ говорит о том, что префикс был получен путём агрегирования более мелких.  

#### Опциональные передаваемые/транзитивные (Optional Transitive)

Атрибуты, которые не обязательно знать всем. Кто знает — использует, кто не знает — передаёт их дальше.  

Примеры:  
_**Aggregator**_. Указывает на Router ID маршрутизатора, где произошло агрегирование.  

_**Community**_. Про этот атрибут мы подробно поговорим далее, в заключительной части статьи.  

#### Опциональные непередаваемые/нетранзитивные (Optional Non-transitive)

Атрибуты, которые не обязательно знать всем. Но маршрутизатор, который их не поддерживает, их отбрасывает и никуда дальше не передаёт.  

Пример:  
_**MED — Multi-exit Descriminator**_. Этим атрибутом мы можем попытаться управлять приоритетами в чужой AS. Можем попытаться, но вряд ли что-то получится :) Часто этот атрибут фильтруется, он имеет значение только при наличии как минимум двух линков в одну AS, он проверяется после многих очень сильных атрибутов (Local Preference, AS-Path), да и разные вендоры могу по-разному трактовать MED.  
[![](http://img-fotki.yandex.ru/get/9349/83739833.30/0_c7580_71b1f56d_XXXL.png)](http://fotki.yandex.ru/users/ait-it/view/816512/)  
Упомянутые прежде _**Cluster List**_ и _**Originator-ID**_. Естественно, они являются опциональными, и естественно, передавать их куда-то за пределы AS нет смысла, поэтому и непередаваемые.  


[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 6***](https://linkmeup.ru/blog/98.html)  

Необходимо изменить стандартную процедуру выбора лучшего маршрута на маршрутизаторах в AS64500:  
— маршрутизаторы R1 и R2 должны выбирать маршруты eBGP, а не iBGP, независимо от длины AS path,  
— маршрутизаторы R3 и R4 внутри автономной системы должны выбирать маршруты на основании метрики OSPF.  

Конфигурация и схема: [базовые](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub).  

Подробности задачи [тут](https://linkmeup.ru/blog/98.html).  


### Community

Вот он — один из самых интересных аспектов BGP, вот где проявляется его гибкость — возможность помимо самих маршрутов, передавать дополнительную информацию.  
С помощью атрибута Community можно из своей AS управлять поведением маршрутизаторов другой AS.  
Я долгое время по непонятной сейчас для себя причине недооценивал мощь этого инструмента.  
Управление своими анонсами в чужой AS с помощью community поддерживается подавляющим большинством вендоров. Но на самом деле говорить тут надо не о вендорах, а, скорее, о операторах/провайдерах — именно от них зависит, от их конфигурации, сможете ли вы управлять или нет.  

Начнём с теории, Community, как было сказано выше, — это опциональный передаваемый атрибут (Optional Transitive) размером 4 байта. Он представляет из себя запись вида AA:NN, где AA — двухбайтовый номер AS, NN — номер коммьюнити (например, 64500:666).  

Существует 4 так называемых **Well-Known community** (**хорошо известные**):  
_**Internet**_ — Нет никаких ограничений — передаётся всем.  
_**No-export**_ — Нельзя экспортировать маршрут в другие AS. При этом за пределы конфедерации передавать их можно.  
_**No-export-subconfed**_ (называется также **_Local AS_**) — Как No-export, только добавляется ограничение и по конфедерациям — между ними уже тоже не передаётся.  
_**No-advertise**_ — Не передавать этот маршрут никому — только сосед будет знать о нём.  


[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 7**](https://linkmeup.ru/blog/99.html)  
Наш новый клиент AS 64504 подключен к нашей сети. И пока что не планирует подключение к другому провайдеру. На данном этапе клиент может использовать номер автономной системы из приватного диапазона. Блок адресов, который использует клиент, будет частью нашего диапазона сетей.  
Задание: Так как сеть клиента является частью нашего блока адресов, надо чтобы сеть клиента не анонсировалась соседним провайдерам.  
Не использовать фильтрацию префиксов или фильтрацию по AS для решения этой задачи.  
Конфигурация и схема: [Community](https://docs.google.com/document/d/1WFjksUR5aD2KhuN_ypA1IOMFavRzOX6p5ledbhyAN8o/pub).  
Отличия только в том, что сеть, которую анонсирует AS64504: 100.0.1.0/28, а не 130.0.0.0/24  

Подробности задачи [тут](https://linkmeup.ru/blog/99.html).  


В сети тысячи примеров настройки таких базовых коммьюнити и крайне мало примеров реального использования.  
А меж тем одно из самых интересных применений этого атрибута — блэкхоулинг от старославянского black hole — способ борьбы с DoS-атаками. Очень подробно с примером настройки о нём уже [было](http://habrahabr.ru/post/91574/) рассказано на хабре.  
Суть в том, что когда началась атака на какой-то из адресов вашей AS, вы этот адрес передаёте вышестоящему провайдеру с комьюнити 666, и он отправляет такой маршрут в NULL — блэкхолит его. То есть до вас уже этот паразитный трафик не доходит. Провайдер может передать такой маршрут дальше, и так, шаг за шагом, трафик от злоумышленника или системы ботов будет отбрасываться уже на самых ранних этапах, не засоряя Интернет.  
Достигается такой эффект расширяющейся чёрной дыры именно благодаря коммьюнити. То есть в обычном случае вы анонсируете этот адрес в составе большой сети /22, например, а в случае DoS’а передаёте самый специфичный маршрут /32, который будет, естественно, более приоритетным.  

> О таких атаках вы, кстати, можете послушать в [шестом выпуске](https://linkmeup.ru/blog/86.html) нашего подкаста linkmeup.

Другие примеры — управление атрибутом Local Preference в чужой AS, сообщать ему, что анонсу нужно увеличить AS-path (AS-path prepending) или не передавать маршрут каким-либо соседям.  
Насчёт последнего. Как, например, вы решите следующую задачу?  
Имеется сеть, представленная на рисунке ниже. Вы хотите отдавать свои маршруты соседям из AS 100 и 200 и не хотите 300.  
![](http://img-fotki.yandex.ru/get/9165/83739833.30/0_c72ea_96f67a37_XXL.png)  
Без использования коммьюнити силами только своей AS сделать это не представляется возможным.  
Кстати, как бы это ни было прискорбно, но такие ограничения реально используются в нашей жизни. Распространены ситуации, когда несколько провайдеров устанавливают между собой пиринговые отношения — трафик между их сетями не ходит через вышестоящих провайдеров, не даёт круг через пол-России, но кого-то не пускают — кому-то свои сети не анонсируют.  
Интереснейшие статьи об [Интернете и BGP](http://habrahabr.ru/post/186282/) и о [пиринговых войнах](http://nag.ru/articles/article/19954/depir-vo-imya-status-kvo-cdn-platejey-comcast-protiv-level3.html).  

#### Практика Community

Мы же в качестве примера рассмотрим следующую ситуацию.  

Основная схема статьи дополняется ещё одним маршрутизатором клиента и двумя линками.  

![](http://img-fotki.yandex.ru/get/9166/83739833.2f/0_c72dc_b5f04e3a_XXL.png)  

R7 и R9 разнесены территориально — так называемое георезервирование. Главным является его правый сайт, левый — резервный.  
Внутри своей AS он без проблем настроил передачу исходящего трафика в нужном месте — через R3\. А вот со входящим посложнее — MED не позволяет использовать религия, да и доверия ему нет.  

Поэтому мы разработали схему взаимодействия, используя community. На самом деле она будет общая для всех. Например, ниже мы установим правило — если получили маршрут с коммьюнити 64500:150, увеличить Local Preference для него до 150\. А потом такую политику применяем к нужным нам маршрутам.  

На нашем оборудовании (на всём) мы определяем ip community-list:  

    ip community-list 1 permit 64500:150

Задаём правило обработки:  

    route-map LP150 permit 10
    match community 1
    set local-preference 150

Это общий блок, который будет одинаков для всех устройств. После этого клиент может сказать, что хочет воспользоваться этой функцией и мы применяем карту на BGP-соседа:  
Применяем карту к BGP-соседу на R3:  

    router bgp 64500
    neighbor 100.0.0.10 remote-as 64504
    neighbor 100.0.0.10 route-map LP150 in

Итак, если в анонсе от соседа 100.0.0.10 community совпадает со значением в условии, установить Local Preference для этих маршрутов в 150.  

> Часто такие политики (route-map) применяются по умолчанию на всех внешних соседей. Клиентам остаётся только настроить передачу нужной коммьюнити и даже не нужно просить о чём-то провайдера — всё сработает автоматически.

Это наша политика по использовании коммьюнити. О ней мы сообщаем клиенту, мол, хочешь Установить для своего маршрута Local Preference в 150 в нашей AS, используй community 64500:150  
И вот он настраивает на R9:  

    router bgp 64504
    neighbor 100.0.0.9 remote-as 64500
    neighbor 100.0.0.9 route-map LP out
    neighbor 100.0.0.9 send-community

    route-map LP permit 10
    set community 64500:150

При необходимости то же самое он может настроить на R7.  
После **clear ip bgp * soft** в отправляемых анонсах мы можем увидеть community:  
![](http://img-fotki.yandex.ru/get/9747/83739833.36/0_d4c6c_f3bf3a6a_XXL.png)  

В итоге R3 имеет маршрут с более высоким Local Preference:  

![](http://img-fotki.yandex.ru/get/9062/83739833.2f/0_c72de_927369c1_XL.png)  

Передаёт его рут-рефлектору (R1 и R2), который делает выбор и распространяет всем своим соседям:  

![](http://img-fotki.yandex.ru/get/9171/83739833.2f/0_c72df_6de773eb_XL.png)  

И даже R4, которому рукой дотянуться до R7, будет отправлять трафик на R3:  

![](http://img-fotki.yandex.ru/get/9252/83739833.2f/0_c72e0_245dce0d_XL.png)  

Трафик идёт именно тем путём, который мы выбрали.  

![](http://img-fotki.yandex.ru/get/9161/83739833.2f/0_c72e1_25a155db_L.png)  

> Пусть вас не пугает по 3 записи для каждого хопа — это говорит о балансировке трафика между равноценными линками _R1<->R2<->R3_ и _R1<->R4<->R3_. Просто один раз он идёт по одному пути, второй по другому. А вот вы лучше попробуйте ответить на вопрос, почему на первом хопе 1-я и 3-я попытки идут через R4, а вот на втором хопе на R3\. Почему пакет “перепрыгивает”? Как так получается?

Кстати, не стоит забывать команду **ip bgp-community new-format**, а иначе вместо этого:  
![](http://img-fotki.yandex.ru/get/9494/83739833.2f/0_c72e3_c257e926_M.png)  
вы увидите это:  
![](http://img-fotki.yandex.ru/get/6718/83739833.2f/0_c72e2_cf91a1ac_M.png)  
Отправляться будет то же самое, но в выводах show команд будет отображаться в удобном виде.  

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 8**](https://linkmeup.ru/blog/100.html)  

В нашей AS для настройки политик с клиентскими AS, используются community. Используются такие значения: 64500:150, 64500:100, 64500:50, 64500:1, 64500:2, 64500:3.  
Кроме того, маршрутизаторы нашей AS также используют community для работы с соседними AS. Их формат: 64501:xxx, 64502:xxx.  
Задание:  
— все значения community приходящие от клиентов, которые не определены политикой, должны удаляться,  
— значения community, которые проставлены клиентами, должны удаляться, при передаче префиксов соседним вышестоящим AS. При этом не должны удаляться другие значения, которые проставлены маршрутизаторами нашей AS.  

Конфигурация и схема: [базовые](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub).  

Подробности задачи [тут](https://linkmeup.ru/blog/100.html).  


[Конфигурация устройств](https://docs.google.com/document/d/1WFjksUR5aD2KhuN_ypA1IOMFavRzOX6p5ledbhyAN8o/pub)  

В приведённом примере видно, что коммьюнити позволяет работать не с отдельными анонсами и для каждого из них отдельно применять какие-то политики, а рассматривать их сразу как группу, что естественно, значительно упрощает обслуживание.  
Иными словами, коммьюнити — это группа анонсов с одинаковыми характеристиками.  

При работе с community важно понимать, что настройка необходима с двух сторон — чтобы желаемое заработало, у провайдера тоже должна быть выполнена соответствующая конфигурация.  

Часто у провайдеров бывает уже выработанная политика использования коммьюнити, и они просто дают вам те номера, которые необходимо использовать. То есть после того, как вы добавите к анонсу номер коммьюнити, провайдеру не придётся ничего делать руками — всё произойдёт автоматически.  

Например, у Балаган-Телекома может быть такая политика:  

| **Значение ** | **Действие**                                                                |
|---------------|-----------------------------------------------------------------------------|
| 64501:100Х    | При анонсировании маршрута соседу A добавить Х препендов, где Х от 1 до 6   |
| 64501:101X    | При анонсировании маршрута соседу B добавить Х препендов, где Х от 1 до 6   |
| 64501:102X    | При анонсировании маршрута соседу C добавить Х препендов, где Х от 1 до 6   |
| 64501:103X    | При анонсировании маршрута в AS64503 добавить Х препендов, где Х от 1 до 6  |
| 64501:20050   | Установить Local Preference для полученных маршрутов в 50                   |
| 64501:20150   | Установить Local Preference для полученных маршрутов в 150                  |
| 64501:666     | Установить Next-Hop для маршрут в Null — создать Black Hole                 |
| 64501:3333    | Выполнить скрипт по уничтожению конфигурации BGP на всех маршрутизаторах AS |

Исходя из этой таблички, которая опубликована на сайте Балаган-телекома, мы можем сами принять решение об управлении трафиком.  

Как это реально может помочь нам?  

У нас Dual-homing подключение к двум различным провайдерам — Балаган Телеком и Филькин Сертификат. У датацентра подключение также к обоим провайдерам. Он принадлежит какому-то контент-генератору, допустим это оператор потового видео.  

По умолчанию, в нашу сеть всё ходит через Балаган-Телеком (AS64501). Канал там хоть и широкий, но его утилизация уже достаточно высока. Мы хотим продавать домашним клиентам услугу IPTV и прогнозируем значительный рост входящего трафика. Неплохо было бы его завернуть в Филькин Сертификат и не бояться о том, что основной канал забьётся. При этом, естественно, весь другой трафик переносить не нужно.  

В таблице BGP проверяем, где находится сеть 103.0.0.0\. Видим, что это AS64503, которая достижима через обоих провайдеров с равным числом AS в AS-Path.  

![](http://img-fotki.yandex.ru/get/9348/83739833.2f/0_c72e4_cae17b05_L.png)  

Вот как видит нас маршрутизатор из AS 64503:  

![](http://img-fotki.yandex.ru/get/9359/83739833.2f/0_c72e5_a81ea8d5_XL.png)  

Маршрут в Балаган-Телеком выбран предпочтительным  

Какие мысли?  
Анонсировать определённые сети в Филькин Сертификат, а остальные оставить в Балаган Телеком? Негибко, немасштабируемо.  
Вешать препенды на маршруты, отдаваемые в Балаган Телеком? Тогда, скорее всего, куча другого трафика перетечёт на Филькин Сертификат.  
Попросить инженера Балаган-Телекома вручную удлинить наши маршруты при передаче их в AS64503\. Уже ближе к истине, и это даже сработает, но, скорее всего, инженер провайдера пошлёт вас… на сайт с табличкой, где прописана их политика Community.  

Собственно, всё, что нужно сделать нам — на маршрутизаторе R1 применить route-map по добавлению коммьюнити 64500:1031 к соседу R5(напоминаем, что 103Х — это для соседа из AS 64503). Дальше всё сделает автоматика.  

Вот как R5 видит маршрут сам:  

![](http://img-fotki.yandex.ru/get/5012/83739833.30/0_c72e6_656200ee_XL.png)  

Всё без изменений.  

Вот как его видит R8:  

![](http://img-fotki.yandex.ru/get/9172/83739833.30/0_c72e7_762d55ee_XL.png)  

Как видите, галочка стоит напротив более короткого пути через Филькин Сертификат, чего мы и добивались.  

![](http://img-fotki.yandex.ru/get/9507/83739833.30/0_c72e8_9af66ca4_L.png)  


[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 9**](https://linkmeup.ru/blog/101.html)  
Одним из наших клиентов стала крупная компания. Платят они нам довольно много, но тут возникла проблема с тем, что когда происходят какие-то проблемы с провайдером AS64501, то качество связи, которую обеспечивает линк с провайдером AS64502, не устраивает клиента. Главное для нашего клиента, хорошее качество связи к филиалам.  
Так как клиент солидный, то пришлось установить пиринг с еще одним провайдером AS64513\. Но он нам дорого обходится поэтому использовать его мы будем только когда провайдер AS64501 недоступен и только для этого важного клиента.  
Задание:  
Надо настроить работу сети таким образом, чтобы через провайдера AS64513 сеть клиента 150.0.0.0/24 анонсировалась только в том случае, если через провайдера AS64501 недоступна сеть 103.0.0.0/22 (она используется для проверки работы провайдера). Кроме того, от провайдера AS64513 нам надо принимать только сети филиалов клиента (50.1.1.0/24, 50.1.2.0/24, 50.1.3.0/24) и использовать их только если они недоступны через провайдера AS64501\. Остальной трафик клиента будет ходить через AS64502.  
Конфигурация: [базовая](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub).  
Подробности задачи [тут](https://linkmeup.ru/blog/101.html).  

# Материалы выпуска

[Повесть о настоящем Интернете](http://habrahabr.ru/post/186282/)  
[BGP Blackhole — эффективное средство борьбы с DDoS](http://habrahabr.ru/post/91574/)  
[Сравнение функций и мест использования EBGP и IBGP](http://mcp1971.livejournal.com/10316.html)  

[Основы BGP  
](http://ts.psc.ru/CISCO/ees/DAY4-BGP.html)  
Конфигурация устройств: [базовый IBGP](https://docs.google.com/document/d/1Nd2qWdLNUd1WyO1Q-U3UKZu4W3LJk8BQYlACfVCjz-I/pub), [Route Reflectors](https://docs.google.com/document/d/1LUf-RSx62_QUN5KNARufwSDz8duq1D9fCRa6u6pZlPk/pub), [Community](https://docs.google.com/document/d/1WFjksUR5aD2KhuN_ypA1IOMFavRzOX6p5ledbhyAN8o/pub).  

# Послесловие

Вот на этом знакомство с BGP можно считать законченным. Теперь мы вернёмся к нему ни много ни мало при рассмотрении MPLS L3VPN.  

За траблшутинг статьи спасибо [JDIMA](http://habrahabr.ru/users/JDima/)  
Задачки предоставлены [Наташей](http://xgu.ru/wiki/%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%90%D0%B2%D1%82%D0%BE%D1%80_%D0%9D%D0%B0%D1%82%D0%B0%D1%88%D0%B0_%D0%A1%D0%B0%D0%BC%D0%BE%D0%B9%D0%BB%D0%B5%D0%BD%D0%BA%D0%BE) — автором лучшего викисайта по сетевым протоколам и технологиям — xgu.ru.