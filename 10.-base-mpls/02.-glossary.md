## Терминология

**Label** — метка — значение от 0 до 1 048 575. На основе неё LSR принимает решение, что с пакетом делать: какую новую метку повешать, куда его передать.  
Является частью заголовка MPLS.

**Label Stack** — стек меток. Каждый пакет может нести одну, две, три, да хоть 10 меток — одну над другой. Решение о том, что делать с пакетом принимается на основе верхней метки. Каждый слой играет какую-то свою роль.  
Например, при передаче пакета используется транспортная метка, то есть метка, организующая транзит от первого до последнего маршрутизатора MPLS.  
Другие могут нести информацию о том, что данный пакет принадлежит определённому VPN.  
В этом выпуске метка всегда будет только одна — больше пока не нужно.

**Push Label** — операция добавления метки к пакету данных — совершается в самом начале — на первом маршрутизаторе в сети MPLS \(в нашем примере — R1\).

**Swap Label** — операция замены метки — происходит на промежуточных маршрутизаторах в сети MPLS — узел получает пакет с одной меткой, меняет её и отправляет с другой \(R2, R5\).

**Pop Label** — операция удаления метки — выполняется последним маршрутизатором — узел получает пакет MPLS и убирает **верхнюю** метку перед передачей его дальше \(R6\).

> На самом деле метка может добавляться и удаляться где угодно внутри сети MPLS.  
> Всё зависит от конкретных сервисов. Правильнее будет сказать, что метка добавляется первым маршрутизатором пути \(LSP\), а удаляется последним.  
> Но в этой статье для простоты мы будем говорить о границах сети MPLS.  
> Кроме того, удаление верхней метки ещё не означает, что остался чистый IP-пакет, если речь идёт о стеке меток. То есть если над пакетом с тремя метками совершили операцию Pop Label, то меток осталось две и дальше он по-прежнему обрабатывается, как MPLS. А в нашем примере была одна, а после не останется ни одной — и это уже дело IP.

**LSR —** _**Label Switch Router**_ — это любой маршрутизатор в сети MPLS. Называется он так, потому что выполняет какие-то операции с метками. В нашем примере это все узлы: R1, R2, R3, R4, R5, R6.  
LSR делится на 3 типа:  
**Intermediate LSR** — промежуточный маршрутизатор MPLS — он выполняет операцию Swap Label \(R2, R5\).  
**Ingress LSR** — «входной», первый маршрутизатор MPLS — он выполняет операцию Push Label \(R1\).  
**Egress LSR** — «выходной», последний маршрутизатор MPLS — он выполняет операцию Pop Label \(R6\).  
**LER —** _**Label Edge Router**_ — это маршрутизатор на границе сети MPLS.  
В частности Ingress LSR и Egress LSR являются граничными, а значит они тоже LER.

**LSP —** _**Label Switched Path**_ — путь переключения меток. Это однонаправленный канал от Ingress LSR до Egress LSR, то есть путь, по которому фактически пройдёт пакет через MPLS-сеть. Иными словами — это последовательность LSR.  
Важно понимать, что LSP **на самом деле** однонаправленный. Это означает, что, во-первых, трафик по нему передаётся только в одном направлении, во-вторых, если существует «туда», не обязательно существует «обратно», в-третьих, «обратно» не обязательно идёт по тому же пути, что «туда». Ну, это как туннельные интерфейсы в GRE.

Как выглядит LSP?

![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_fd879_b291c55_orig.png)

Да, вот так непрезентабельно.  
Это компилированный вывод с четырёх LSR — R1, R2, R5, R6. То есть на LSR вы не увидите законченной последовательности узлов от входа до выхода, по типу атрибута AS-PATH в BGP. Здесь каждый узел знает только входную и выходную метки. Но LSP при этом существует.

Это похоже немного на IP-маршрутизацию. Несмотря на то, что существует путь от точки А до точки Б, таблица маршрутизации знает только следующий узел, куда надо отправлять трафик. Но разница в том, что LSR не принимает решение о каждом пакете на основе адреса назначения — путь определён заранее.

И одно из самых важный понятий, с которым необходимо разобраться — **FEC —** _**Forwarding Equivalence Class**_. Мне оно почему-то давалось очень тяжело, хотя по сути — всё просто. FEC — это классы трафика. В простейшем случае идентификатором класса является адресный префикс назначения \(грубо говоря, IP-адрес или подсеть назначения\).  
Например, есть потоки трафика от разных клиентов и разных приложений, которые идут все на один адрес — все эти потоки принадлежат одному классу — одному FEC — используют один LSP.  
Если мы возьмём другие потоки от других клиентов и приложений на другой адрес назначения — это будет соответственно другой класс и другой LSP.

> В теории помимо адреса назначения FEC может учитывать, например, метки QoS, адрес источника, идентификатор VPN или тип приложений. Важно понимать тут, что пакеты одного FEC не обязаны следовать на один и тот же адрес назначения. И в то же время, если даже и два пакета следуют в одно место, не обязательно они будут принадлежать одному FEC.  
>   
> Я поясню для чего всё это нужно. Дело в том, что для каждого FEC выбирается свой LSP — свой путь через сеть MPLS. И тогда, например, для WEB-сёрфинга вы устанавливаете приоритет [QoS BE](http://lookmeup.linkmeup.ru/#term509) — это будет один FEC — а для VoIP — [EF](http://lookmeup.linkmeup.ru/#term508) — другой FEC. И далее можно указать, что для FEC BE LSP должен идти широким, но долгим и негарантированным путём, а для FEC EF — можно узким, но быстрым.  
>   
> К сожалению или к счастью, но сейчас в качестве FEC может выступать только IP-префикс. Такие вещи, как маркировка QoS не рассматриваются.

Если вы обратите внимание на таблицу меток, FEC там присутствует, поскольку параметры замены меток определяются как раз таки на основе FEC, но делается это только в первый момент времени — когда эти метки распределяются. Когда же по LSP бежит реальный трафик, никто, кроме Ingress LSR, уже не смотрит на него — только метки и интерфейсы. Всю работу по определению FEC и в какой LSP отправить трафик берёт на себя Ingress LSR — получив чистый пакет, он его анализирует, проверяет какому классу тот принадлежит и навешивает соответствующую метку. Пакеты разных FEC получат разные метки и будут отправлены в соответствующие интерфейсы.  
Пакеты одного FEC получают одинаковые метки.

То есть промежуточные LSR — это молотилки, которые для всего транзитного трафика только и делают, что переключают метки. А всю интеллектуальную работу выполняют Ingress LSR.

**LIB —** _**Label Information Base**_ — таблица меток. Аналог таблицы маршрутизации \(RIB\) в IP. В ней указано для каждой входной метки, что делать с пакетом — поменять метку или снять её и в какой интерфейс отправить.  
**LFIB —** _**Label Forwarding Information Base**_ — по аналогии с FIB — это база меток, к которой обращается сетевой процессор. При получении нового пакета нет нужды обращаться к CPU и делать lookup в таблицу меток — всё уже под рукой.

Одна из первоначальных идей MPLS — максимально разнести Control Plane и Data Plane — ушла в небытие.  
Разработчикам хотелось, чтобы при передаче пакета через маршрутизатор не было никакого анализа — просто прочитал метку, поменял на другую, передал в нужный интерфейс.  
Чтобы добиться этого, как раз и было два разнесённых процесса — относительно долгое построение пути \(Control Plane\) и быстрая передача по этому пути трафика \(Data Plane\)

Но с появлением дешёвых чипов \(ASIC, FPGA\) и механизма FIB обычная IP-передача тоже стала быстрой и простой.  
Для маршрутизатора без разницы, куда смотреть при передаче пакета — в FIB или в LFIB.  
А вот что, несомненно, важно и полезно — так это, что безразличие MPLS к тому, что передаётся под его заголовком — IP, Ethernet, ATM. Не нужно городить GRE или какие-то другие до боли в суставах неудобные VPN. Но об этом ещё поговорим.

### Заголовок MPLS

Весь заголовок MPLS — это 32 бита. Формат полей и их длина фиксированы. Часто весь заголовок называют меткой, хотя это не совсем и верно.

![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_10096d_2b0780c8_orig.png)

_**Label**_ — собственно сама метка. Длина — 20 бит.  
_**TC**_ — Traffic Class. Несёт в себе приоритет пакета, как поле DSCP в IP.  
Длина 3 бита. То есть может кодировать 8 различных значений.  
Например, при передаче IP-пакета через сеть MPLS значению в поле DSCP определённым образом ставится в соответствие значение TC. Таким образом пакет может почти одинаково обрабатываться в очередях на всём протяжении своего пути, как на участке чистого IP, так и в MPLS.  
Но, естественно, это преобразование с потерями — шести битам DSCP тесно в 3 битах TC: 64 против 8. Поэтому существует специальная таблица соответствий, где целый диапазон — это всего лишь одно значение.

> Первоначально поле носило название EXP \(экспериментальное\), а его содержимое не было регламентировано. Предполагалось, что оно может быть использовано для исследований, внедрения нового функционала. Но это в прошлом.  
> Если кто-то с вами спорит, что это поле экспериментальное и не утверждено формально за функцией QoS — он ~~не шарит~~ порядочно [отстал от жизни](http://packetlife.net/blog/2009/mar/2/mpls-qos-no-longer-experimental/).
>
> [![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_9e219_a466f149_S.png)**Задача № 1**](https://linkmeup.ru/blog/155.html)  
>   
> В сети настроена простая политика QoS, в которой IP-пакеты, которые идут с хоста 10.0.17.7 на адрес 6.6.6.6, маркируются и передаются по сети MPLS. Для маркировки пакетов используется поле EXP, значение поля 3.  
> ![](../.gitbook/assets/10.-base-mpls/02.-glossary/d25ba61aea0a08460d54480061b0927a.png)  
>   
> На маршрутизаторе R6 настроена политика QoS, которая классифицирует пакеты по полю EXP.  
> Но, при проверке оказалось, что политика на R6 не отрабатывает. То есть, нет пакетов, приходящих со значением EXP 3 и все пакеты попадают в class default.  
>   
> Задание: Исправить конфигурацию так, чтобы политика на R6 срабатывала.  
>   
> Маршрутизатор R7 используется в качестве клиента. Соответственно MPLS между R7 и R1 не включен.  
>   
> Подробности задачи и конфигурации [тут](https://linkmeup.ru/blog/155.html).

_**S**_ — Bottom of Stack — индикатор дна стека меток длиной в 1 бит. Заголовков MPLS на пакете может быть несколько, например, внешняя для коммутации в сети MPLS, а внутренняя указывает на определённый VPN. Чтобы LSR понимал с чем он имеет дело. В бит S записывается «1», если это последняя метка \(достигнуто дно стека\) и «0», если стек содержит больше одной метки \(ещё не дно\). То есть LSR не знает, сколько всего меток в стеке, но знает, одна она или больше — да этого и достаточно на самом-то деле. Ведь любые решения принимаются на основе только самой верхней метки, независимо от того, что там под ней. Зато, снимая метку, он уже знает, что дальше сделать с пакетом: продолжить работу с процессом MPLS или отдать его какому-то другому \(IP, Ethernet, ATM, FR итд\).

> Вот к этой фразе: “Зато, снимая метку, он уже знает, что дальше сделать с пакетом” — надо дать пояснение. В заголовке MPLS, как вы заметили, нет информации о содержимом \(как Ethertype в Ethernet’е или Protocol в IP\).  
> Это с одной стороны хорошо — внутри может быть что угодно — выше гибкость, а с другой стороны, как без анализа содержимого теперь определить, какому процессу передавать всё это хозяйство?  
> А тут небольшая хитрость — маршрутизатор, как вы увидите дальше, всегда сам выделяет метку и передаёт её своим соседям, поэтому он знает, для чего её выделял — для IP или для Ethernet или ещё для чего-то. Поэтому он просто добавляет эту информацию в свою таблицу меток. И в следующий раз, когда делает операцию Pop Label, он уже из таблицы \(а не из пакета\) знает, что дальше делать.

![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_fd609_77cdd883_XL.png)

В общем, стек тут в классическом понимании — последним положили, первым взяли \(LIFO — Last Input — First Output\).

В итоге, несмотря на то, что длина заголовка MPLS фиксированная, самих заголовков может быть много — и все они располагаются друг за другом.

_**TTL**_ — Time To Live — полный аналог [IP TTL](http://lookmeup.linkmeup.ru/#term47). Даже той же самой длиной обладает — 8 бит. Единственная задача — не допустить бесконечного блуждания пакета по сети в случае петли. При передаче IP-пакета через сеть MPLS значение IP TTL может быть скопировано в MPLS TTL, а потом обратно. Либо отсчёт начнётся опять с 255, а при выходе в чистую сеть IP значение IP TTL будет таким же, как до входа.

Как видите, заголовок MPLS втискивается между канальным уровнем и теми данными, которые он несёт — в случае IP — сетевым. Поэтому метафорически MPLS называется технологией 2,5 уровня, а заголовок — Shim-header — заголовок-клин.  
\_К слову, метка не обязательно должна быть в заголовке MPLS. Согласно решению IETF, она может встраиваться в заголовки ATM, AAL5, Frame Relay.

Вот как оно выглядит в жизни:

![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_10096e_c5cd901c_orig.png)

### Пространство меток

Как уже было сказано выше, может существовать 2^20 меток.

Из них несколько зарезервировано:

**0**: _IPv4 Explicit NULL Label_. «Явная пустая метка». Она используется на самом последнем пролёте MPLS — перед Egress LSR — для того, чтобы уведомить его, что эту метку 0 можно снять, не просматривая таблицу меток \(точнее LFIB\).  
Для тех FEC, что зарождаются локально \(directly connected\) Egress LSR выделяет метку 0 и передаёт своим соседям — предпоследним LSR \(Penultimate LSR\).  
При передаче пакета данных предпоследний LSR меняет текущую метку на 0.  
Когда Egress LSR получает пакет, он точно знает, что верхнюю метку нужно просто удалить.

> Так было не всегда. Изначально предлагалось, что метка 0 может быть только на дне стека меток и при получении пакета с такой меткой, LSR должен вообще очистить упоминания об MPLS и начать обрабатывать данные.  
> В какой-то момент теоретики под давлением практиков согласились, что это нерационально и реального применения им придумать не удалось, поэтому отказались от обоих условий.  
> Так что теперь метка 0 не обязательно последняя \(нижняя\) и при операции Pop Label удаляется только она, а нижние остаются и пакет дальше обрабатывается в соответствии с новой верхней меткой.

**1**: Метка _Router Alert Label_ — аналог опции Router Alert в IP — может быть где угодно, кроме дна стека. Когда пакет приходит с такой меткой, он должен быть передан локальному модулю, а дальше он коммутируется в соответствии с меткой, которая была ниже — реальной транспортной, при этом наверх стека снова должна быть добавлена метка 1.

**2**: _IPv6 Explicit NULL Label_ — то же, что и 0, только с поправкой на версию протокола IP.

**3**: _Implicit Null_. Фиктивная метка, которая используется для оптимизации процесса передачи пакета MPLS на Egress LSR. Эта метка может анонсироваться, но никогда не используется в заголовке MPLS реально. Рассмотрим её попозже.

**4-15**: Зарезервированы.

В зависимости от вендора, могут быть зафиксированы и другие значения меток, например, на оборудовании Huawei метки 16-1023 используются для статических LSP, а всё, что выше — в динамических. В Cisco доступные метки начинаются уже с 16-й.

\_

> =====================  
> [![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_9e219_a466f149_S.png)**Задача № 2**](https://linkmeup.ru/blog/156.html)  
>   
> На следующей схеме все маршрутизаторы, кроме R5, это маршрутизаторы Huawei. R5 — Cisco.  
> ![](../.gitbook/assets/10.-base-mpls/02.-glossary/0_fea21_f32bf6b2_orig.png)  
>   
> Для приведенной ниже конфигурации маршрутизатора R5, необходимо настроить его таким образом, чтобы распределение значений меток соответствовало Huawei. Речь о том, что в Huawei динамические метки начинаются с 1024, а в Cisco с 16.  
>   
> **Конфигурация R5** ip cef ! interface Loopback0 ip address 5.5.5.5 255.255.255.255 ip router isis ! interface FastEthernet0/0 description to R4 ip address 10.0.45.5 255.255.255.0 ip router isis mpls ip ! interface FastEthernet0/1 description to R2 ip address 10.0.25.5 255.255.255.0 ip router isis mpls ip ! interface FastEthernet1/0 description to R6 ip address 10.0.56.5 255.255.255.0 ip router isis mpls ip ! router isis net 10.0000.0000.0005.00 ! mpls ldp router-id Loopback0 force  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/156.html).

В целом стало понятно, как передаётся трафик и как в этом участвуют метки MPLS.  
Но метки не берутся от балды — никому не нужен дополнительный хаос в преддверии Нового Года. Специальные протоколы распределяют метки между Egress LSR и Ingress LSR, создавая LSP.
