# 10. Базовый MPLS

## Сети для самых маленьких. Часть десятая. Базовый MPLS

Сеть нашей воображаемой компании linkmeup растёт. У неё есть уже магистральные линии в различных городах, клиентская база и отличный штат инженеров, выросших на цикле СДСМ.  
Но всё им мало. Услуги ШПД — это хорошо и нужно, но есть ещё огромный потенциальный рынок корпоративных клиентов, которым нужен VPN.  
Думали ребята над этим, ломали голову и пришли к выводу, что никак тут не обойтись без MPLS.

Если мультикаст был первой темой, которая требовала некоторого перестроения понимания IP-сетей, то, изучая MPLS, вам точно придётся забыть почти всё, что вы знали раньше — это особенный мир со своими правилами.

[![](https://img-fotki.yandex.ru/get/16123/83739833.47/0_100960_19e8ebfb_XXL.jpg)](https://img-fotki.yandex.ru/get/16123/83739833.47/0_100960_19e8ebfb_orig.jpg)

Сегодня в выпуске:

* [Что такое MPLS](10.-base-mpls.md#ABOUT_MPLS)
* [Передача трафика в сети MPLS](10.-base-mpls.md#FORWARDING)
* [Терминология](10.-base-mpls.md#GLOSSARY)
* [Распространение меток](10.-base-mpls.md#LABEL_DISTRIBUTION)
* [Методы распространение меток](10.-base-mpls.md#MODES)
* [DU против DoD](10.-base-mpls.md#DU_DOD)
* [Ordered Control против Independent Control](10.-base-mpls.md#LABEL_CONTROL)
* [Liberal Label Retention Mode против Conservative Label Retention Mode](10.-base-mpls.md#RETENTION_MODE)
* [PHP](10.-base-mpls.md#PHP)
* [Протоколы распространения меток](10.-base-mpls.md#PROTOCOLS)
* [LDP](10.-base-mpls.md#LDP)
* [Практика](10.-base-mpls.md#LDP_PRACTICE)
* [Применение чистого MPLS в связке с BGP](10.-base-mpls.md#MPLS-BGP)
* [RSVP-TE](10.-base-mpls.md#RSVP-TE)
* [Практика](10.-base-mpls.md#RSVP_PRACTICE)
* [ВиО](10.-base-mpls.md#FAQ)
* [Полезные ссылки](10.-base-mpls.md#USEFUL)

А начнём мы с вопроса: «Что не так с IP?»

[_Традиционное видео_ ](https://www.youtube.com/embed/hZyfM4UZDac)

А действительно, что не так? Зачем городить MPLS?  
Да всё так. Достоинства и недостатки IP вытекают из того, что он появился позже классических сетей и невероятно гибкий. Сейчас повсеместно идёт переход на пакетную коммутацию, в основу которой лёг IP на сетевом уровне, а на канальном всё большую популярность набирает Ethernet.  
Это хорошо, ведь теперь на базе одной опорной сети и сети доступа можно предоставлять [ШПД](http://lookmeup.linkmeup.ru/#term190), IP-телефонию, IPTV и другие возможные услуги.  
То же самое прослеживается и в сетях мобильных операторов. Сети второго поколения на заре были целиком на основе [коммутации каналов](http://lookmeup.linkmeup.ru/#term187). Ядро сетей 3G в большинстве своём уже IP, но услуги телефонии по-прежнему могут предоставляться в режиме коммутации каналов. Сети же 4G это уже полноценные IP-сети, где передача голоса — это лишь одно из приложений, также, как и ШПД.

Однако существует ещё огромное число сегментов, где используются старые технологии. Например, где-то есть ATM, в другом месте нужно PDH передать из одной части сети в другую, а тут клиент захотел, чтобы его кусок Ethernet-сети оказался доступным с другого конца города так, словно он подключен непосредственно — иными словами VPN.  
Как это решалось раньше: нужен ATM между двумя географическими точками — строй канал между ними на базе ATM, PDH — строй PDH.  
А хочется-то делать всё это через одну сеть, а не строить отдельную для каждого типа трафика.  
Для этого и были придуманы в своё время GRE, PPPoE, PPPoA, ATM over Ethernet, TDM over IP и многочисленные другие over'ы. Можно насоздавать ещё тысячу других, чтобы покрыть уже все комбинации, и настанет вселенское счастье в хаосе стандартов \(_к слову, некоторые мелкие производители по такому пути и пошли_\).

В середине 90-х горячим головам из нескольких компаний \(IBM, Toshiba, Cisco, Ipsilon\) пришло в голову создать механизм, который позволил бы при маршрутизации заглядывать не внутрь пакета и прочёсывать таблицу маршрутизации в поисках лучшего пути, а ориентироваться по некой метке. Выстрелило у Cisco, и механизм был назван незамысловато: TAG Switching.  
Причём цель, которую преследовали разработчики, заключалась в том, чтобы позволить высокоскоростным коммутаторам передавать трафик исключительно аппаратно. Дело в том, что аппаратная IP-маршрутизация долгое время была малодоступным удовольствием, и применять её на недорогих коммутаторах было нецелесообразно, а принимать решение на основе метки можно было бы просто и быстро.  
Но в то же время появились сверхбольшие интегральные схемы \(пусть я и не согласен с этим термином — английский [VLSI](http://en.wikipedia.org/wiki/Very-large-scale_integration) гораздо лучше описывает суть\), и задача экономии на анализе содержимого пакета стала не такой уж и актуальной. Кроме того появилось понятие FIB, которое предполагает, что для каждого пакета не нужно осуществлять поиск адресата в таблице маршрутизации и соответственно привлекать центральный процессор — вся горячая информация уже на линейной плате.  
То есть по сути необходимость в таком механизме отпала.

Но _внезапно_ стало понятно, что у коммутации по меткам есть незапланированный потенциал — совершенно неважно, что находится под меткой — IP, Ethernet, ATM, Frame Relay. А ещё она даёт возможность отвязаться от ограничений IP-маршрутизации.  
Отсюда и берёт своё начало технология, утверждённая IETF — MPLS — MultiProtocol Label Switching. Шёл 1997-й год.  
И эта, кажущаяся, возможно, незначительной, деталь дала начало новой эре в телекоммуникациях. Сегодня MPLS вы найдёте в любом более или менее крупном провайдере.

Основные применения MPLS сейчас:

* MPLS L2VPN
* MPLS L3VPN
* MPLS TE

О каждом из них мы поговорим в отдельных статьях — это чудовищно огромные темы. Но коротко мы затронем их в конце статьи.

## MPLS

Сам по себе чистый MPLS применяется редко. Выигрыш в производительности незначительный, потому что разница между тем, чтобы заглянуть в FIB/поменять некоторые поля в заголовках и посмотреть таблицу меток/поменять метку в заголовке MPLS не такая уж большая. Используются, конечно, его приложения, перечисленные выше.  
Но в этой статье мы всё-таки сконцентрируемся именно на чистом MPLS, чтобы понимать как это работает в самом базовом виде.  
[Ниже мы рассмотрим](10.-base-mpls.md#MPLS-BGP) также одно применение чистого MPLS.

Несмотря на то, что MPLS не привязывается к типу сети, на которой он будет работать, в наше время он живёт в симбиозе только с IP. То есть сама сеть строится поверх IP, но переносить при этом она может данные многих других протоколов.  
Но давайте уже перейдём к сути, и сначала я хочу сказать, что **MPLS не заменяет IP-маршрутизацию**, а работает поверх неё.

Чтобы быть более конкретным, я возьму такую сеть.

![](https://img-fotki.yandex.ru/get/15503/83739833.48/0_100a2c_2b3d829b_orig.png)

Сейчас она в полностью рабочем состоянии, но без всяких намёков на MPLS. То есть R1, например, видит R6 и может пинговать его Loopback.  
ПК1 посылает ICMP-запрос на сервер 172.16.0.2. ICMP-запрос — это IP-пакет. На R1 согласно базовым принципам пакет уходит через интерфейс FE0/0 на R2 — так сказала Таблица Маршрутизации.  
R2 после получения пакета проверяет адрес назначения, просматривает свою FIB, видит следующий маршрутизатор и отправляет пакет в интерфейс FE0/0.  
И этот процесс повторяется раз за разом. Каждый маршрутизатор самостоятельно решает судьбу пакета.

Вот так совершенно привычно выглядит дамп трафика:

![](https://img-fotki.yandex.ru/get/15489/83739833.47/0_100966_fcc67b8b_orig.png)

Что происходит, если мы активируем MPLS? Вот сразу же, в ту же секунду мир меняется. После этого на маршрутизаторах заполняются таблицы меток и строятся многочисленные LSP.

И теперь тот же путь будет проделан немного иначе.

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/32c/f20/5d3/32cf205d34d648caa6ab8c2983f754db.gif)

Когда IP-пакет от ПК1 попадает в сеть MPLS первый маршрутизатор навешивает метку, дальше этот пакет идёт к точке назначения, а каждый следующий маршрутизатор меняет одну метку на другую. При выходе из сети MPLS метка снимается и дальше передаётся уже чистый IP-пакет, каким он был в самом начале.

Это основной принцип MPLS — маршрутизаторы коммутируют пакеты по меткам, не заглядывая внутрь пакета MPLS. Первый — добавляет, последний — удаляет.

Давайте рассмотрим шаг за шагом передачу пакета данных от ПК1 до узла назначения:

**1.** ПК1 — обычный компьютер — отправляет обычный пакет на удалённый сервер.

**2.** Пакет доходит до R1. Он добавляет метку 18. Она вставляется между заголовком IP и Ethernet.  
Эту информацию он может взять из FIB:

![](https://img-fotki.yandex.ru/get/15581/83739833.48/0_10096a_76d817ff_orig.png)

По FIB видно, что пакет с адресатом **6.6.6.6** нужно снабдить меткой **18** и отправить в интерфейс **FE0/0**.  
Собственно это он и делает: добавляет заголовок и прописывает в него 18:

![](https://img-fotki.yandex.ru/get/15574/83739833.47/0_100965_4578740b_orig.png)  
_Дамп между R1 и R2_.

**3.** R2 получает этот пакет, в заголовке Ethernet видит, что это MPLS-пакет \(Ethertype 8847\), считывает метку и обращается к своей таблице меток:

![](https://img-fotki.yandex.ru/get/15481/83739833.47/0_100967_b461a856_orig.png)

![](https://img-fotki.yandex.ru/get/15545/83739833.48/0_10096b_bc8ed326_orig.png)

Читаем по буквам: если пакет MPLS пришёл с меткой 18, её нужно поменять на 20 и отправить пакет в интерфейс FE0/0.

![](https://img-fotki.yandex.ru/get/15552/83739833.48/0_100969_55db3cb8_orig.png)  
_Дамп после R2._

**4.** R5 совершает аналогичные действия — видит, что пришёл пакет с меткой 20, её нужно поменять на 0 и отправить в FE1/0. Без всякого обращения к таблице маршрутизации.

**5.** R6, получив пакет MPLS, видит в своей таблице, что теперь метку надо снять. А, сняв её, видит уже, что адресат пакета — 172.16.0.2 — это Directly Connected сеть. Дальше пакет передаётся обычным образом по таблице маршрутизации уже безо всяких меток.

**То есть целиком процесс выглядит так:**

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/c31/6ae/95b/c316ae95bc8d4450a30e99e111354025.gif)  
_Не будем рассматривать конечные узлы, чтобы не усложнять схему._

Пока, вроде, всё просто, пусть и непонятно зачем.

Сейчас домены IGP и MPLS совпадают и MPLS только обещает нам в дальнейшем какие-то плюшки: L2VPN, L3VPN, MPLS TE.  
Но, на самом деле, даже базовый MPLS дает нам преимущества, если мы вспомним, что мы провайдер.  
Как провайдер, мы ведь не используем протоколы IGP для маршрутизации между AS. Для этого мы используем BGP. И именно в связке с BGP станут понятны преимущества MPLS.  
Рассмотрим нашу сеть в связке с соседними AS:

![](https://img-fotki.yandex.ru/get/15527/83739833.48/0_100a4d_647bcf2c_XXL.png)

Из выпуска о BGP мы знаем, что **на каждом** маршрутизаторе в нашей AS должен быть настроен BGP. Иначе мы не сможем передавать трафик соседних AS и наших клиентов, через нашу AS. Каждый маршрутизатор должен знать все маршруты.

Но это было до MPLS!  
Когда в нашей сети настроен MPLS, нам больше не обязательно настраивать BGP на каждом маршрутизаторе в сети. Достаточно настроить его только на пограничных маршрутизаторах в AS, на тех, которые подключены к другим клиентам или провайдерам.

![](https://img-fotki.yandex.ru/get/17911/83739833.48/0_100a4b_f130e3b2_XXL.png)

Но это не все хорошие новости. Кроме того, что BGP теперь можно не настраивать на каждом маршрутизаторе в AS, маршрутизаторам также не нужно создавать метку для каждого префикса BGP. Достаточно знать как добраться до IP-адреса, который указан как next-hop. То есть, если сессия BGP настроена между Loopback0 R1 и Loopback0 R6, то в таблице меток ничего не изменится, даже если каждый из них передает по BGP сотни тысяч маршрутов:

Например, маршрутизатору R1 по BGP от маршрутизатора R6 пришло несколько маршрутов:  
![](https://img-fotki.yandex.ru/get/15569/83739833.48/0_100a4f_1a737f3_orig.png)

Посмотрим как будут обрабатываться пакеты, которые идут в сеть 100.0.0.0/16:  
![](https://img-fotki.yandex.ru/get/15590/83739833.48/0_100a4c_5335b60c_orig.png)

В выводе выше видно, что пакетам будет добавляться метка 27.  
И, если посмотреть в таблицу меток, то там нет меток для маршрутов, которые известны по BGP, но есть метка 27 и она соответствует 6.6.6.6/32. А это именно тот адрес, который мы видели в маршрутах, которые пришли по BGP от R6:  
![](https://img-fotki.yandex.ru/get/15483/83739833.48/0_100a4e_cfdf9929_orig.png)

Пример настройки вы можете найти [ниже](10.-base-mpls.md#MPLS-BGP).

Мы немного забежали вперед, но теперь, когда стало понятнее какие преимущества дает даже базовый MPLS, мы можем окунуться в понятийный аппарат в мире MPLS.

## Терминология

**Label** — метка — значение от 0 до 1 048 575. На основе неё LSR принимает решение, что с пакетом делать: какую новую метку повешать, куда его передать.  
Является частью заголовка MPLS.

**Label Stack** — стек меток. Каждый пакет может нести одну, две, три, да хоть 10 меток — одну над другой. Решение о том, что делать с пакетом принимается на основе верхней метки. Каждый слой играет какую-то свою роль.  
Например, при передаче пакета используется транспортная метка, то есть метка, организующая транзит от первого до последнего маршрутизатора MPLS.  
Другие могут нести информацию о том, что данный пакет принадлежит определённому VPN.  
В этом выпуске метка всегда будет только одна — больше пока не нужно.

**Push Label** — операция добавления метки к пакету данных — совершается в самом начале — на первом маршрутизаторе в сети MPLS \(в нашем примере — R1\).

**Swap Label** — операция замены метки — происходит на промежуточных маршрутизаторах в сети MPLS — узел получает пакет с одной меткой, меняет её и отправляет с другой \(R2, R5\).

**Pop Label** — операция удаления метки — выполняется последним маршрутизатором — узел получает пакет MPLS и убирает **верхнюю** метку перед передачей его дальше \(R6\).

> На самом деле метка может добавляться и удаляться где угодно внутри сети MPLS.  
> Всё зависит от конкретных сервисов. Правильнее будет сказать, что метка добавляется первым маршрутизатором пути \(LSP\), а удаляется последним.  
> Но в этой статье для простоты мы будем говорить о границах сети MPLS.  
> Кроме того, удаление верхней метки ещё не означает, что остался чистый IP-пакет, если речь идёт о стеке меток. То есть если над пакетом с тремя метками совершили операцию Pop Label, то меток осталось две и дальше он по-прежнему обрабатывается, как MPLS. А в нашем примере была одна, а после не останется ни одной — и это уже дело IP.

**LSR —** _**Label Switch Router**_ — это любой маршрутизатор в сети MPLS. Называется он так, потому что выполняет какие-то операции с метками. В нашем примере это все узлы: R1, R2, R3, R4, R5, R6.  
LSR делится на 3 типа:  
**Intermediate LSR** — промежуточный маршрутизатор MPLS — он выполняет операцию Swap Label \(R2, R5\).  
**Ingress LSR** — «входной», первый маршрутизатор MPLS — он выполняет операцию Push Label \(R1\).  
**Egress LSR** — «выходной», последний маршрутизатор MPLS — он выполняет операцию Pop Label \(R6\).  
**LER —** _**Label Edge Router**_ — это маршрутизатор на границе сети MPLS.  
В частности Ingress LSR и Egress LSR являются граничными, а значит они тоже LER.

**LSP —** _**Label Switched Path**_ — путь переключения меток. Это однонаправленный канал от Ingress LSR до Egress LSR, то есть путь, по которому фактически пройдёт пакет через MPLS-сеть. Иными словами — это последовательность LSR.  
Важно понимать, что LSP **на самом деле** однонаправленный. Это означает, что, во-первых, трафик по нему передаётся только в одном направлении, во-вторых, если существует «туда», не обязательно существует «обратно», в-третьих, «обратно» не обязательно идёт по тому же пути, что «туда». Ну, это как туннельные интерфейсы в GRE.

Как выглядит LSP?

![](https://img-fotki.yandex.ru/get/6836/83739833.46/0_fd879_b291c55_orig.png)

Да, вот так непрезентабельно.  
Это компилированный вывод с четырёх LSR — R1, R2, R5, R6. То есть на LSR вы не увидите законченной последовательности узлов от входа до выхода, по типу атрибута AS-PATH в BGP. Здесь каждый узел знает только входную и выходную метки. Но LSP при этом существует.

Это похоже немного на IP-маршрутизацию. Несмотря на то, что существует путь от точки А до точки Б, таблица маршрутизации знает только следующий узел, куда надо отправлять трафик. Но разница в том, что LSR не принимает решение о каждом пакете на основе адреса назначения — путь определён заранее.

И одно из самых важный понятий, с которым необходимо разобраться — **FEC —** _**Forwarding Equivalence Class**_. Мне оно почему-то давалось очень тяжело, хотя по сути — всё просто. FEC — это классы трафика. В простейшем случае идентификатором класса является адресный префикс назначения \(грубо говоря, IP-адрес или подсеть назначения\).  
Например, есть потоки трафика от разных клиентов и разных приложений, которые идут все на один адрес — все эти потоки принадлежат одному классу — одному FEC — используют один LSP.  
Если мы возьмём другие потоки от других клиентов и приложений на другой адрес назначения — это будет соответственно другой класс и другой LSP.

> В теории помимо адреса назначения FEC может учитывать, например, метки QoS, адрес источника, идентификатор VPN или тип приложений. Важно понимать тут, что пакеты одного FEC не обязаны следовать на один и тот же адрес назначения. И в то же время, если даже и два пакета следуют в одно место, не обязательно они будут принадлежать одному FEC.  
>   
> Я поясню для чего всё это нужно. Дело в том, что для каждого FEC выбирается свой LSP — свой путь через сеть MPLS. И тогда, например, для WEB-сёрфинга вы устанавливаете приоритет [QoS BE](http://lookmeup.linkmeup.ru/#term509) — это будет один FEC — а для VoIP — [EF](http://lookmeup.linkmeup.ru/#term508) — другой FEC. И далее можно указать, что для FEC BE LSP должен идти широким, но долгим и негарантированным путём, а для FEC EF — можно узким, но быстрым.  
>   
> К сожалению или к счастью, но сейчас в качестве FEC может выступать только IP-префикс. Такие вещи, как маркировка QoS не рассматриваются.

Если вы обратите внимание на таблицу меток, FEC там присутствует, поскольку параметры замены меток определяются как раз таки на основе FEC, но делается это только в первый момент времени — когда эти метки распределяются. Когда же по LSP бежит реальный трафик, никто, кроме Ingress LSR, уже не смотрит на него — только метки и интерфейсы. Всю работу по определению FEC и в какой LSP отправить трафик берёт на себя Ingress LSR — получив чистый пакет, он его анализирует, проверяет какому классу тот принадлежит и навешивает соответствующую метку. Пакеты разных FEC получат разные метки и будут отправлены в соответствующие интерфейсы.  
Пакеты одного FEC получают одинаковые метки.

То есть промежуточные LSR — это молотилки, которые для всего транзитного трафика только и делают, что переключают метки. А всю интеллектуальную работу выполняют Ingress LSR.

**LIB —** _**Label Information Base**_ — таблица меток. Аналог таблицы маршрутизации \(RIB\) в IP. В ней указано для каждой входной метки, что делать с пакетом — поменять метку или снять её и в какой интерфейс отправить.  
**LFIB —** _**Label Forwarding Information Base**_ — по аналогии с FIB — это база меток, к которой обращается сетевой процессор. При получении нового пакета нет нужды обращаться к CPU и делать lookup в таблицу меток — всё уже под рукой.

Одна из первоначальных идей MPLS — максимально разнести Control Plane и Data Plane — ушла в небытие.  
Разработчикам хотелось, чтобы при передаче пакета через маршрутизатор не было никакого анализа — просто прочитал метку, поменял на другую, передал в нужный интерфейс.  
Чтобы добиться этого, как раз и было два разнесённых процесса — относительно долгое построение пути \(Control Plane\) и быстрая передача по этому пути трафика \(Data Plane\)

Но с появлением дешёвых чипов \(ASIC, FPGA\) и механизма FIB обычная IP-передача тоже стала быстрой и простой.  
Для маршрутизатора без разницы, куда смотреть при передаче пакета — в FIB или в LFIB.  
А вот что, несомненно, важно и полезно — так это, что безразличие MPLS к тому, что передаётся под его заголовком — IP, Ethernet, ATM. Не нужно городить GRE или какие-то другие до боли в суставах неудобные VPN. Но об этом ещё поговорим.

### Заголовок MPLS

Весь заголовок MPLS — это 32 бита. Формат полей и их длина фиксированы. Часто весь заголовок называют меткой, хотя это не совсем и верно.

![](https://img-fotki.yandex.ru/get/16187/83739833.48/0_10096d_2b0780c8_orig.png)

_**Label**_ — собственно сама метка. Длина — 20 бит.  
_**TC**_ — Traffic Class. Несёт в себе приоритет пакета, как поле DSCP в IP.  
Длина 3 бита. То есть может кодировать 8 различных значений.  
Например, при передаче IP-пакета через сеть MPLS значению в поле DSCP определённым образом ставится в соответствие значение TC. Таким образом пакет может почти одинаково обрабатываться в очередях на всём протяжении своего пути, как на участке чистого IP, так и в MPLS.  
Но, естественно, это преобразование с потерями — шести битам DSCP тесно в 3 битах TC: 64 против 8. Поэтому существует специальная таблица соответствий, где целый диапазон — это всего лишь одно значение.

> Первоначально поле носило название EXP \(экспериментальное\), а его содержимое не было регламентировано. Предполагалось, что оно может быть использовано для исследований, внедрения нового функционала. Но это в прошлом.  
> Если кто-то с вами спорит, что это поле экспериментальное и не утверждено формально за функцией QoS — он ~~не шарит~~ порядочно [отстал от жизни](http://packetlife.net/blog/2009/mar/2/mpls-qos-no-longer-experimental/).
>
> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 1**](https://linkmeup.ru/blog/155.html)  
>   
> В сети настроена простая политика QoS, в которой IP-пакеты, которые идут с хоста 10.0.17.7 на адрес 6.6.6.6, маркируются и передаются по сети MPLS. Для маркировки пакетов используется поле EXP, значение поля 3.  
> ![](http://habrastorage.org/getpro/habr/post_images/d25/ba6/1ae/d25ba61aea0a08460d54480061b0927a.png)  
>   
> На маршрутизаторе R6 настроена политика QoS, которая классифицирует пакеты по полю EXP.  
> Но, при проверке оказалось, что политика на R6 не отрабатывает. То есть, нет пакетов, приходящих со значением EXP 3 и все пакеты попадают в class default.  
>   
> Задание: Исправить конфигурацию так, чтобы политика на R6 срабатывала.  
>   
> Маршрутизатор R7 используется в качестве клиента. Соответственно MPLS между R7 и R1 не включен.  
>   
> Подробности задачи и конфигурации [тут](https://linkmeup.ru/blog/155.html).

_**S**_ — Bottom of Stack — индикатор дна стека меток длиной в 1 бит. Заголовков MPLS на пакете может быть несколько, например, внешняя для коммутации в сети MPLS, а внутренняя указывает на определённый VPN. Чтобы LSR понимал с чем он имеет дело. В бит S записывается «1», если это последняя метка \(достигнуто дно стека\) и «0», если стек содержит больше одной метки \(ещё не дно\). То есть LSR не знает, сколько всего меток в стеке, но знает, одна она или больше — да этого и достаточно на самом-то деле. Ведь любые решения принимаются на основе только самой верхней метки, независимо от того, что там под ней. Зато, снимая метку, он уже знает, что дальше сделать с пакетом: продолжить работу с процессом MPLS или отдать его какому-то другому \(IP, Ethernet, ATM, FR итд\).

> Вот к этой фразе: “Зато, снимая метку, он уже знает, что дальше сделать с пакетом” — надо дать пояснение. В заголовке MPLS, как вы заметили, нет информации о содержимом \(как Ethertype в Ethernet’е или Protocol в IP\).  
> Это с одной стороны хорошо — внутри может быть что угодно — выше гибкость, а с другой стороны, как без анализа содержимого теперь определить, какому процессу передавать всё это хозяйство?  
> А тут небольшая хитрость — маршрутизатор, как вы увидите дальше, всегда сам выделяет метку и передаёт её своим соседям, поэтому он знает, для чего её выделял — для IP или для Ethernet или ещё для чего-то. Поэтому он просто добавляет эту информацию в свою таблицу меток. И в следующий раз, когда делает операцию Pop Label, он уже из таблицы \(а не из пакета\) знает, что дальше делать.

![](https://img-fotki.yandex.ru/get/5500/83739833.46/0_fd609_77cdd883_XL.png)

В общем, стек тут в классическом понимании — последним положили, первым взяли \(LIFO — Last Input — First Output\).

В итоге, несмотря на то, что длина заголовка MPLS фиксированная, самих заголовков может быть много — и все они располагаются друг за другом.

_**TTL**_ — Time To Live — полный аналог [IP TTL](http://lookmeup.linkmeup.ru/#term47). Даже той же самой длиной обладает — 8 бит. Единственная задача — не допустить бесконечного блуждания пакета по сети в случае петли. При передаче IP-пакета через сеть MPLS значение IP TTL может быть скопировано в MPLS TTL, а потом обратно. Либо отсчёт начнётся опять с 255, а при выходе в чистую сеть IP значение IP TTL будет таким же, как до входа.

Как видите, заголовок MPLS втискивается между канальным уровнем и теми данными, которые он несёт — в случае IP — сетевым. Поэтому метафорически MPLS называется технологией 2,5 уровня, а заголовок — Shim-header — заголовок-клин.  
\_К слову, метка не обязательно должна быть в заголовке MPLS. Согласно решению IETF, она может встраиваться в заголовки ATM, AAL5, Frame Relay.

Вот как оно выглядит в жизни:

![](https://img-fotki.yandex.ru/get/15486/83739833.48/0_10096e_c5cd901c_orig.png)

### Пространство меток

Как уже было сказано выше, может существовать 2^20 меток.

Из них несколько зарезервировано:

**0**: _IPv4 Explicit NULL Label_. «Явная пустая метка». Она используется на самом последнем пролёте MPLS — перед Egress LSR — для того, чтобы уведомить его, что эту метку 0 можно снять, не просматривая таблицу меток \(точнее LFIB\).  
Для тех FEC, что зарождаются локально \(directly connected\) Egress LSR выделяет метку 0 и передаёт своим соседям — предпоследним LSR \(Penultimate LSR\).  
При передаче пакета данных предпоследний LSR меняет текущую метку на 0.  
Когда Egress LSR получает пакет, он точно знает, что верхнюю метку нужно просто удалить.

> Так было не всегда. Изначально предлагалось, что метка 0 может быть только на дне стека меток и при получении пакета с такой меткой, LSR должен вообще очистить упоминания об MPLS и начать обрабатывать данные.  
> В какой-то момент теоретики под давлением практиков согласились, что это нерационально и реального применения им придумать не удалось, поэтому отказались от обоих условий.  
> Так что теперь метка 0 не обязательно последняя \(нижняя\) и при операции Pop Label удаляется только она, а нижние остаются и пакет дальше обрабатывается в соответствии с новой верхней меткой.

**1**: Метка _Router Alert Label_ — аналог опции Router Alert в IP — может быть где угодно, кроме дна стека. Когда пакет приходит с такой меткой, он должен быть передан локальному модулю, а дальше он коммутируется в соответствии с меткой, которая была ниже — реальной транспортной, при этом наверх стека снова должна быть добавлена метка 1.

**2**: _IPv6 Explicit NULL Label_ — то же, что и 0, только с поправкой на версию протокола IP.

**3**: _Implicit Null_. Фиктивная метка, которая используется для оптимизации процесса передачи пакета MPLS на Egress LSR. Эта метка может анонсироваться, но никогда не используется в заголовке MPLS реально. Рассмотрим её попозже.

**4-15**: Зарезервированы.

В зависимости от вендора, могут быть зафиксированы и другие значения меток, например, на оборудовании Huawei метки 16-1023 используются для статических LSP, а всё, что выше — в динамических. В Cisco доступные метки начинаются уже с 16-й.

\_

> =====================  
> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 2**](https://linkmeup.ru/blog/156.html)  
>   
> На следующей схеме все маршрутизаторы, кроме R5, это маршрутизаторы Huawei. R5 — Cisco.  
> ![](https://img-fotki.yandex.ru/get/15521/83739833.46/0_fea21_f32bf6b2_orig.png)  
>   
> Для приведенной ниже конфигурации маршрутизатора R5, необходимо настроить его таким образом, чтобы распределение значений меток соответствовало Huawei. Речь о том, что в Huawei динамические метки начинаются с 1024, а в Cisco с 16.  
>   
> **Конфигурация R5** ip cef ! interface Loopback0 ip address 5.5.5.5 255.255.255.255 ip router isis ! interface FastEthernet0/0 description to R4 ip address 10.0.45.5 255.255.255.0 ip router isis mpls ip ! interface FastEthernet0/1 description to R2 ip address 10.0.25.5 255.255.255.0 ip router isis mpls ip ! interface FastEthernet1/0 description to R6 ip address 10.0.56.5 255.255.255.0 ip router isis mpls ip ! router isis net 10.0000.0000.0005.00 ! mpls ldp router-id Loopback0 force  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/156.html).

В целом стало понятно, как передаётся трафик и как в этом участвуют метки MPLS.  
Но метки не берутся от балды — никому не нужен дополнительный хаос в преддверии Нового Года. Специальные протоколы распределяют метки между Egress LSR и Ingress LSR, создавая LSP.

## Распространение меток

Во-первых, как вы уже поняли, на некоторых устройствах можно всё сделать вручную — виват усердие и старание!  
Но в эпоху автоматических стиральных машин существует три базовых протокола для распространения меток — LDP, RSVP-TE и MBGP.

Если коротко, то LDP — самый простой и понятный способ — опирается на маршрутную информацию узлов. RSVP-TE — это развитие некогда разработанного, но непопулярного протокола [RSVP](http://lookmeup.linkmeup.ru/#term488) — используется в MPLS-TE для построения LSP, удовлетворяющих определённым условиям. Для его работы нужны IGP, поддерживающие Traffic Engineering \(OSPF, ISIS\).  
MBGP — близкий родственник BGP, но это протокол из немного другой истории, он передаёт метки для других целей. Поэтому и стоит он в стороне от LDP и RSVP-TE.

Поговорим о каждом из них, но перед этим несколько слов о том, как LSR обращаются с метками вообще.

### Методы распространения меток

Первый очевидный факт — метки распространяются в направлении от получателя трафика к отправителю, а точнее от Egress LER к Ingress LER. Первый неочевидный факт — в MPLS Downstream — это от отправителя к получателю, а Upstream от получателя к отправителю. Я для себя определил это так: LSP «растёт» из FEC **вверх** к Ingress LER, как дерево, а пользовательский трафик «спускается» к получателю по LSP, как дождевая вода по веткам. То есть метки распространяются навстречу трафику.

Говорят ещё, что LSP строится навстречу трафику.

Сам же механизм распространения меток зависит от протокола, настроек и производителя.

#### DU против DoD

_**Во-первых**_, маршрутизатор может распространять метки всем своим соседям сразу же и без лишних вопросов, а может выдавать по запросу от вышестоящих \(мы помним, да, какое направление называется Upstream?\)  
Первый режим называется _\*\*DU — \_Downstream Unsolicited_\*\*\_. Как только LSR узнаёт про FEC, он рассылает всем своим MPLS-соседям метки для этого FEC.  
Выглядит это примерно так:

![](https://img-fotki.yandex.ru/get/16110/83739833.48/0_10098a_66cd2b8f_orig.png)

Все LSR узнают обо всех FEC по всем возможным путям. Сначала соответствие FEC-метка расходится по всей сети от соседа к соседу, почти как это происходит с сообщениями [BootStrap](http://lookmeup.linkmeup.ru/#term302) в PIM SM. А потом каждый LSR выбирает только тот, который пришёл по лучшему пути, и его использует для LSP — точно так же работает [Reverse Path Forwarding](http://lookmeup.linkmeup.ru/#term332) в том же [PIM SM](https://linkmeup.ru/blog/129.html#PIM-SM).

Быстро, просто, понятно, хотя и не всегда нужно, чтобы все знали обо всём.

Второй режим — _\*\*DoD — \_Downstream-on-Demand_\*\*\_. LSR знает FEC, у него есть соседи, но пока они не спросят, какая для данного FEC метка, LSR сохраняет молчание.

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/b56/523/10c/b5652310c50f4238938f1bda1e8e7206.gif)

Этот способ удобен, когда к LSP предъявляются какие-то требования, например, по ширине полосы. Зачем слать метку просто так, если она тут же будет отброшена? Лучше вышестоящий LSR запросит у нижестоящего: мне нужна от тебя метка для данного FEC — а тот: «ок, на».

Режим выделения меток специфичен для интерфейса и определяется в момент установки соединения. В сети могут быть использованы оба способа, но на одной линии, соседи должны договориться только об одном конкретном.

**Ordered Control против Independent Control**

_**Во-вторых**_, LSR может дожидаться, когда со стороны Egress LER придёт метка данного FEC, прежде чем рассказывать вышестоящим соседям. А может разослать метки для FEC, как только узнал о нём.

Первый режим называется _**Ordered Control**_

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/36f/ea5/c7e/36fea5c7edcb49679ded58494d19d604.gif)

Гарантирует, что к моменту передачи данных весь путь вплоть до выходного LER будет построен.

Второй режим — _**Independent Control**_.

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/08d/b3d/af5/08db3daf5031411a9e2b6fcc1407fe16.gif)

То есть метки передаются неупорядоченно. Удобен тем, что трафик можно начинать передавать ещё до того, как весь путь построен. Этим же и опасен.

**Liberal Label Retention Mode против Conservative Label Retention Mode**

_**В-третьих**_, важно, как LSR обращается с переданными ему метками.  
Например, в такой ситуации, должен ли R1 хранить хранить информацию о метке 20, полученной от соседа R3, который не является лучшим способом добраться до R6?

![](https://img-fotki.yandex.ru/get/4708/83739833.46/0_fd607_d363bbd0_orig.png)

А это определяется режимом удержания меток.  
_**Liberal Label Retention Mode**_ — метки сохраняются. В случае, когда R3 станет следующим шагом \(например, проблемы с основным путём\), трафик будет перенаправлен скорее, потому что метка уже есть. То есть скорость реакции выше, но велико и количество использованных меток.  
_**Conservative Label Retention Mode**_ — лишняя метка отбрасывается сразу, как она получена. Это позволяет сократить количество используемых меток, но и MPLS среагирует медленнее в случае аварии.

**PHP**

Нет, это не тот PHP, о котором вы подумали. Речь о **Penultimate Hop Popping**. Все инженеры _немного_ оптимизаторы, вот и тут ребята подумали: а зачем нам два раза обрабатывать заголовки MPLS — сначала на предпоследнем маршрутизаторе, потом ещё на выходном.  
И решили они, что метку нужно снимать на предпоследнем LSR и назвали сие действо — PHP.  
Для PHP существует специальная метка — 3.  
Возвращаясь к нашему примеру, для FEC 6.6.6.6 и 172.16.0.2 R6 выделяет метку 3 и сообщает её R5.  
При передаче пакета на R6 R5 должен назначить ему фиктивную метку — 3, но фактически она не применяется и в интерфейс отправляется голый IP-пакет \(стоит заметить, что PHP работает только в сетях IP\) — то есть процедура Pop Label была выполнена ещё на R5.

Давайте проследим жизнь пакета с учётом всего, что мы теперь знаем.

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/2c7/449/998/2c74499985d7463da7e67beac679038f.gif)

С тем, как трафик передаётся, вроде, более или менее понятно. Но кто выполняет весь титанический труд по созданию меток, заполнению таблиц?

## Протоколы распространения меток

Их не так много — три: LDP, RSVP-TE, MBGP.  
Есть две глобальные цели — распространение траспортных меток и распространение меток сервисных.  
Поясним: _**транспортные метки**_ используются **для передачи трафика** по сети MPLS. Это как раз те, о которых мы говорим весь выпуск. Для них используются LDP и RSVP-TE.

_**Сервисные метки**_ служат **для разделения** различных сервисов. Тут на арену выходят MBGP и отросток LDP — [tLDP](http://lookmeup.linkmeup.ru/#term511).  
В частности MBGP позволяет, например, пометить, что вот такой-то маршрут принадлежит такому-то VPN. Потом он этот маршрут передаёт, как vpn-ipv4 family своему соседу с меткой, чтобы тот смог потом отделить мух от котлет.  
Так вот, чтобы он мог отделить, ему и нужно сообщить о соответствии метка-FEC.  
Но это действие другой пьесы, которую мы сыграем ещё через полгода-год.

Обязательным условием работы всех протоколов динамического распределения меток является базовая настройка IP-связности. То есть на сети должны быть запущены IGP.

Ну, вот теперь, когда я вас окончательно запутал, можно начинать распутывать.  
Итак, как проще всего распределить метки? Ответ — включить LDP.

### LDP

Протокол с очень прозрачным названием — **Labed Distribution Protocol** — имеет соответствующий принцип работы.  
Рассмотрим его на сети linkmeup, которую мы мурыжим весь выпуск:

![](https://img-fotki.yandex.ru/get/3014/83739833.45/0_fd5e7_94e2cc0b_orig.png)

**1.** После включения LDP LSR делает мультикастовую рассылку UDP-дейтаграмм во все интерфейсы на адрес 224.0.0.2 и порт 646, где активирован LDP — так происходит поиск соседей.  
TTL таких пакетов равен 1, поскольку LDP-соседство устанавливается между непосредственно подключенными узлами.

> Вообще говоря, это не всегда так — LDP сессия может устанавливаться для определённых целей и с удалённым узлом, тогда это называется tLDP — [Targeted LDP](http://lookmeup.linkmeup.ru/#term511). О нём мы поговорим в других выпусках.

\_  
Такие сообщения называются **Hello**.

**2.** Когда соседи обнаружены, устанавливается TCP соединение с ними, тоже по порту 646 — **Initialization**. Дальнейшие сообщения \(кроме Hello\) передаются уже с TTL равным 255.

**3.** Теперь LSR периодически обмениваются сообщениями **Keepalive** адресно по TCP и по-прежнему не оставляют попыток найти соседей с помощью Hello.

**4.** В какой-то момент один из LSR обнаруживает в себе вторую личность — Egress LSR — то есть он является выходным для какого-то FEC. Это факт, о котором нужно сообщить миру.  
В зависимости от режима он ждёт запроса на метку для данного FEC, либо рассылает его сразу же.

![](https://img-fotki.yandex.ru/get/6702/83739833.45/0_fd5f2_5d73bd4_orig.png)

Эта информация передаётся в сообщении **Label Mapping Message**. Исходя из названия, оно несёт в себе соответствие FEC и метки.

R5 получает информацию о соответствии FEC 6.6.6.6/32 и метки 3 \(implicit null\) и записывает её в свою таблицу меток. Теперь, когда ему нужно будет отправить данные на 6.6.6.6 он будет знать, что нужно удалить верхний заголовок MPLS и отправить оставшийся пакет в интерфейс FE1/0.

Далее он выбирает входную метку для данного FEC, записывает эту информацию в свою таблицу меток и отправляет её вышестоящим соседям.

![](https://img-fotki.yandex.ru/get/5102/83739833.45/0_fd5f3_7a06af1_orig.png)

Теперь R5 знает, что если пришёл пакет MPLS с меткой 20, его нужно передать в интерфейс FE1/0, сняв метку, то есть выполнив процедуру PHP.

R2 получает от R5 информацию о соответствии FEC-метка \(6.6.6.6 — 20\), вносит её в таблицу и, создав свою входную метку \(18\), передаёт её ещё выше. И так далее, пока все LSR не получат свою выходную метку.

![](https://img-fotki.yandex.ru/get/6846/83739833.45/0_fd5f4_ea89267c_orig.png)

Таким образом у нас построен LSP от R1 до R6. R1 при отправке пакета на 6.6.6.6/32 добавляет к нему метку 18 \(Push Label\) и посылает его в порт FE0/0. R2, получив пакет с меткой 18, меняет метку на 20 \(Swap Label\) и отправляет его в порт FE0/0. R5 видит, что для пакета с меткой 20, надо выполнить PHP \(выходная метка — 3 — implicit null\), снимает метку \(Pop Label\) и отправляет данные в порт FE1/0.

При этом параллельно оказались построены LSP от R2 до R6, от R5 до R6, от R4 до R6 итд. То есть ото всех LSR — просто я не показал это на иллюстрации.

Если у вас хватит сил, то на гифке ниже можно весь процесс посмотреть в динамике.

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/b13/71a/cab/b1371acab49e47c9bab46aa0af23123b.gif)

Естественно, вы понимаете, что не только R6 вдруг начал рассылать свои соответствия FEC-метка, но и все другие — R1 про 1.1.1.1/32, R2 — 2.2.2.2/32 итд. Все эти сообщения молниеносно разносятся по сети MPLS, строя десятки LSP. В результате каждый LSR будет знать про все существующие FEC и будет построен соответствующий LSP.

Опять же на гифке выше процесс показан не до конца, R1 потом передаёт информацию на R3, R3 на R4, R4 на R5.  
И если мы посмотрим на R5, то увидим, что для FEC 6.6.6.6/32 у нас не одна выходная метка, как ожидалось, а 3:

![](https://img-fotki.yandex.ru/get/2710/83739833.46/0_fd87a_e3a55b27_orig.png)

Более того, сам R6 запишет метку для FEC 6.6.6.6, которую получит от R5:

![](https://img-fotki.yandex.ru/get/4613/83739833.46/0_fd87b_472a5f5a_orig.png)

_Inuse_ — правильная — **imp-null** в сторону R6. Но две других из кольца — от R2 и R4. Это не ошибка и не петля — просто R2 и R4 сгенерировали эти метки для известного им из таблицы маршрутизации FEC 6.6.6.6/32.

Возникает два вопроса:  
1\) Как он планирует ими воспользоваться? Они же бестолковые. Ответ: а никак. Не может быть в нашей сети такой ситуации, когда 2.2.2.2 или 4.4.4.4 будут следующими узлами на пути к 6.6.6.6 — IGP так маршрут не построит. А значит и использованы метки не будут. Просто LDP-то глупый — его сообщения разбредаются по всей сети, пробиваясь в каждую щёлочку. А умный LSR уже решит каким пользоваться.  
2\) Что насчёт петель? Не будут сообщения LDP курсировать по сети пока TTL не истечёт?  
А тут всё просто — получение нового сообщения Label Mapping Message не инициирует создание нового — полученное соответствие просто записывается в таблицу LDP. То есть в нашем случае R5 уже придумал один раз метку для FEC 6.6.6.6/32 и разослал её своим вышестоящим соседям и она уже не поменяется, пока процесс LDP не перезагрузится.  
\_

> Возможно, вы уже заметили, что при настройке LDP есть возможность включить функционал Loop Detection, но спешу вас успокоить — это для сетей, где нет TTL, например, ATM. Этот функционал переключит LDP в режим DoD.

\_  
Это базовая информация о том, как работает LDP.  
На самом деле здесь всё очень сильно зависит от производителя. В принципе LDP поддерживает всевозможные режимы работы с метками: и DoD/DU, и Independent Control/Ordered Control, и Conservative/Liberal Label Retention. Это никак не регламентируется RFC, поэтому каждый вендор волен выбирать свой путь.  
Например, в основном все используют DU для LDP, но при этом в Juniper метки раздаются упорядоченно, а в Cisco независимо.  
В качестве FEC в Huawei и Juniper выбираются только Loopback-интерфейсы LSR, а Cisco FEC создаётся для всех записей в таблице маршрутизации.

Но это всё едва ли как-то отразится на реальной сети.

Самое важное, что нужно понимать относительно LDP — он не использует в своей работе протоколы динамической маршрутизации — по принципу работы он похож на [PIM DM](https://linkmeup.ru/tag/сети%20для%20самых%20маленьких/#PIM-DM): наводняет всю сеть метками, но при этом он опирается на информацию из таблицы маршрутизации LSR. И если на R1 придёт две метки для одного FEC от разных соседей, то он выберет для LSP только ту, которая получена через лучший интерфейс до этого FEC по информации из ТМ.  
Это означает три вещи:

* Вы вольны выбирать IGP, который вам больше нравится, хоть RIP .
* LDP всегда строит только один \(лучший\) маршрут и не может построить, например, резервный.
* При изменении топологии сети LSP перестроится в соответствии с обновившейся таблицей маршрутизации, то есть сначала должен сойтись IGP, и только потом поднимется LSP.

И вообще после включения LDP трафик будет ходить так же, как и без него, с той лишь разницей, что появляются метки MPLS.  
В том числе LDP, как и IP, поддерживает [ECMP](http://lookmeup.linkmeup.ru/#term435), просто алгоритмы вычисления хэша, а соответственно и балансировки могут отличаться.

Интересная [статья](http://blog.ipspace.net/2011/11/junos-versus-cisco-ios-mpls-and-ldp.html) от Ивана Пепельняка на тему LDP и [видео](http://blog.ipspace.net/2014/10/tech-talks-introduction-to-label.html) о том, как протокол работает.

LDP описан в [RFC 5036](https://tools.ietf.org/html/rfc5036).

#### Практика LDP

Останемся верными сети linkmeup.

![](https://img-fotki.yandex.ru/get/3014/83739833.45/0_fd5e7_94e2cc0b_orig.png)

Запущен OSPF, маршрутизаторы видят Loopback'и друг друга, MPLS выключен.

[Файл начальной конфигурации.](https://docs.google.com/document/d/1YZUNAu3NmdXyTOt118jjxRrA-p61kUVcpkf6yS-WHxQ/pub)

Для включения MPLS глобально, необходимо дать две команды:

```text
R1(config)#ip cef
R1(config)#mpls ip
```

Первая — это уже стандарт де факто и де юре почти на любом сетевом оборудовании — она запускает механизм CEF на маршрутизаторе, вторая стартует MPLS и LDP глобально \(тоже может быть дана по умолчанию\).

Router ID \(а в более общей \(нецисковской\) терминологии LSR ID\) в MPLS выбирается незамысловато:

1. Самый большой адрес Loopback-интерфейсов
2. Если их нет — самый большой IP-адрес, настроенный на маршрутизаторе.

Естественно, не стоит доверять автоматике — настроим LSR ID вручную:

```text
R1(config)# mpls ldp router-id Loopback0 force
```

Если не добавлять ключевое слово **«force»**, Router ID изменится только при переустановлении LDP-сессии. **«Force»** заставляет маршрутизатор сменить Router ID насильно и при необходимости \(если тот поменялся\) переустанавливает соединение LDP.

Далее на нужных интерфейсах даём команду **mpls ip**:

```text
R1(config)#interface FastEthernet 0/0
R1(config-if)#mpls ip
R1(config)#interface FastEthernet 0/1
R1(config-if)#mpls ip
```

Cisco здесь опять использует свой принцип ленивого инженера — минимум усилий со стороны персонала. Команда **mpls ip** включает на интерфейсе LDP одновременно с MPLS, желаем мы этого или нет. Точно так же команда **ip pim sparse-mode** включает IGMP на интерфейсе, как я описывал это в статье про [мультикаст](https://linkmeup.ru/blog/129.html).  
После активации LDP маршрутизатор начинает прощупывать почву по UDP:

![](https://img-fotki.yandex.ru/get/5601/83739833.46/0_fd8a1_d44e698e_orig.png)  
Проверяки посылаются на мультикастовый адрес 224.0.0.2.

Теперь повторяем все те же манипуляции на R2

```text
R2(config)#ip cef
R2(config)#mpls ip
R2(config)# mpls ldp router-id Loopback0 force
R2(config)#interface FastEthernet 0/0
R2(config-if)#mpls ip
R2(config)#interface FastEthernet 0/1
R2(config-if)#mpls ip
```

и наслаждаемся результатом.  
R2 тоже ищет соседей.

![](https://img-fotki.yandex.ru/get/2712/83739833.45/0_fd5ef_68ebfcf3_orig.png)

Узнали друг про друга, и R2 поднимает LDP-сессию:

![](https://img-fotki.yandex.ru/get/4601/83739833.45/0_fd5f0_2277f163_orig.png)

> **Если интересно, как они устанавливают TCP-соединение**
>
> ![](https://img-fotki.yandex.ru/get/5101/83739833.46/0_fd606_9e996bf4_orig.png)

Теперь они соседи, что легко проверяется командой **show mpls ldp neighbor**.

![](https://img-fotki.yandex.ru/get/6841/83739833.46/0_fd603_237ee320_orig.png)

И далее один другому рассказывает о своих соответствиях FEC-метка:

![](https://img-fotki.yandex.ru/get/6702/83739833.45/0_fd5f5_a2e900a2_orig.png)

> Вот тут уже видно детали — R1 передаёт сразу 12 FEC — по одной для каждой записи в своей таблице маршрутизации. В такой же ситуации Huawei или Juniper передали бы только шесть FEC — адреса Loopback-интерфейсов, потому что они по умолчанию считают за FEC только /32-префиксы.  
> В этом плане Cisco очень неэкономно относится к ресурсу меток.  
> Впрочем, это поведение можно изменить на любом оборудовании. В нашем случае может помочь команда **mpls ldp advertise-labels**.  
>   
> Но как так, спросите вы? Разве достаточно иметь метки только в Loopback?  
>   
> Если вспомнить о том, что мы рассматривали вначале статьи, что BGP префиксы не получают свои метки, и что метки нужны только для next-hop, то становится понятно, что меток для Loopback вполне хватит.  
>   
> Для того чтобы добраться до других сетей внутри нашей AS, нам достаточно IGP.
>
> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 3**](https://linkmeup.ru/blog/157.html)  
>   
> Если в Cisco по умолчанию анонсируются метки для всех сетей \(кроме полученных по BGP\), то в Juniper, по умолчанию анонсируется только loopback.  
>   
> ![](https://img-fotki.yandex.ru/get/15521/83739833.46/0_fea21_f32bf6b2_orig.png)
>
> Все маршрутизаторы, кроме R5, это маршрутизаторы Juniper.  
>   
> Для приведенной ниже конфигурации маршрутизатора R5, донастроить его так, чтобы настройки маршрутизатора Cisco, соответствовало настройкам по умолчанию в Juniper.
>
> **Конфигурация R5**
>
> ```text
> ip cef
> !
> interface Loopback0
> ip address 5.5.5.5 255.255.255.255
> ip router isis
> !
> interface FastEthernet0/0
> description to R4
> ip address 10.0.45.5 255.255.255.0
> ip router isis
> mpls ip
> !
> interface FastEthernet0/1
> description to R2
> ip address 10.0.25.5 255.255.255.0
> ip router isis
> mpls ip
> !
> interface FastEthernet1/0
> description to R6
> ip address 10.0.56.5 255.255.255.0
> ip router isis
> mpls ip
> !
> router isis
> net 10.0000.0000.0005.00
> !
> mpls ldp router-id Loopback0 force
> ```
>
> Подробности задачи [тут](https://linkmeup.ru/blog/157.html).

![](https://img-fotki.yandex.ru/get/6821/83739833.45/0_fd5f6_e9991ea6_orig.png)

Итак, **R1** сообщает R2, что если тот хочет отправлять трафик для **FEC 3.3.3.3**, он должен использовать метку **17**.

Обратите внимание, что LDP на R3 ещё не поднят, то есть R1 анонсировал метку для FEC 3.3.3.3, не дождавшись её от R5, это говорит о том, что используется Independent Control.  
А то, что не было явного запроса от R2 на данный FEC, говорит о том, что режим — Downstrean unsolicited.  
Далее узлы будут продолжать мониторить новых соседей с помощью LDP Hello поверх UDP и обмениваться LDP Keepalive уже адресно:

![](https://img-fotki.yandex.ru/get/4602/83739833.45/0_fd5f1_b4c7e321_orig.png)

Теперь с помощью команды **show mpls forwarding-table** можно посмотреть, какие метки назначились для каждого FEC:

![](https://img-fotki.yandex.ru/get/3303/83739833.46/0_fd605_b73e078d_orig.png)

На второй строчке уже рассмотренный FEC 3.3.3.3, и мы видим, что для него локальная метка — 17, то есть R1 всем будет говорить, что для FEC 3.3.3.3 метка 17, что и было в дампе.  
А вот outgoing tag или выходная метка — _Untagged_ — это означает что пакеты пересылаются **чистым** IP \(без каких-либо оговорок на стек\). Причём _Untagged_ означает, что между R1 и R3 вообще никакого MPLS нет — правильно: мы же его не включили на R3.  
А вот с R2 \(первая строка\) ситуация другая. Локальная метка 16 — это то, что R1 будет передавать всем. А выходная — _Pop tag_. То есть при передаче пакета на R2 R1 должен снять метку. В нашем случае это означает, что будет передан чистый IP \(но в более общем случае снимается только верхняя метка\). В чём же разница с FEC 3.3.3.3? А разница в том, что между R1 и R2 есть MPLS и то, что мы видим — это тот самый PHP — Penultimate Hop Popping. Пакет, адресованный 2.2.2.2 всё равно будет обработан на R2, поэтому чтобы не плодить сущности сверх необходимого R1 услужливо снимет метку.

И тут возникает интересный вопрос, откуда R1 знает, что он предпоследний из могикан? Ведь мы же выше говорили, что LDP не пользуется протоколами маршрутизации, поэтому он и знать не может, что адрес 2.2.2.2 настроен на непосредственно подключенном R2 — он видит только то, что 2.2.2.2 доступен через 10.0.12.2.

На этот вопрос нам поможет ответить дамп трафика между R2 и R1:

![](https://img-fotki.yandex.ru/get/3010/83739833.45/0_fd5f7_276476f2_orig.png)

И тут всплывает та самая метка 3 — implicit-null. Таким образом R2 сообщает, что R1 при передаче пакета MPLS должен снять верхнюю метку.  
Хочу здесь повториться — R1 не передаст пакет с меткой 3 на R2 — он передаст его без верхней метки. В нашем случае это будет просто IP-пакет. А метка 3 никогда не появляется в заголовке MPLS.  
И вот эта метка 3 отображается в таблице коммутации MPLS, как _Pop Tag_.

Для узлов R5 и R6 у нас есть метки, хотя на них MPLS не включали, но это лишь потому, что маршрут до них лежит через R2, а R2 сгенерировал соответствие FEC-метка для них. В таком случае пакеты на R6 будут идти **с** заголовком MPLS между R1 и R2 и **без него** дальше.  
Заметьте, если бы использовался Ordered Control, R2 не смог бы отправить метку для R5 и R6, и пакеты ходили бы только по IP.

Предлагаю закончить настройку MPLS+LDP на всех элементах нашей скромной сети. Процессы там ничем не отличаются — те же Neighbor Discovery, Initialization, обмен метками, PHP.

Шаблон настройки следующий:

```text
mpls ip
!
interface Loopback0
ip address 1.1.1.1 255.255.255.255
ip router isis
!
interface FastEthernet0/0
description to R2
ip address 10.0.12.1 255.255.255.0
ip router isis
mpls ip
!
interface FastEthernet0/1
description to R3
ip address 10.0.13.1 255.255.255.0
ip router isis
mpls ip
!
router isis
net 10.0000.0000.0001.00
! 
mpls ldp router-id Loopback0 force
```

[Файл конфигурации LDP.](https://docs.google.com/document/d/1QgtI-U-EGp0no_vshOW5pDvO8pZoGb3eHenlt_qaPTU/pub)

И после этого посмотрим повторно на таблицу коммутации MPLS на **R1**:

![](https://img-fotki.yandex.ru/get/6840/83739833.45/0_fd5fe_24c2de90_orig.png)

Для всех FEC уже появились метки.  
Давайте пройдёмся по LSP от R1 до R6 и посмотрим как меняются метки по пути

**R2:**  
![](https://img-fotki.yandex.ru/get/4510/83739833.45/0_fd5ff_76c77336_orig.png)

**R5:**  
![](https://img-fotki.yandex.ru/get/4405/83739833.45/0_fd600_c02cfea_orig.png)

Значит  
1. Когда **R1** получает пакет MPLS с меткой **21**, он должен передать его в интерфейс **Fa0/0** и поменять метку на **18**.  
2. Когда **R2** получает пакет MPLS с меткой **18**, он должен передать его в интерфейс **Fa0/0** и поменять метку на **20**.  
3. Когда **R5** получает пакет MPLS с меткой **20**, он должен передать его в интерфейс **Fa1/0** и снять метку — **PHP**.

В этом случае LSR даже не задумываются о том, чтобы глянуть что-то в таблице маршрутизации или в ip cef — они просто жонглируют метками.

Таблица коммутации, которую мы уже смотрели командой **show mpls forwarding table** — это **LFIB** \(_**Lable Forwarding Information Base**_\) — почти что прописная истина для передачи данных — это Data Plane. Но что же там с Control Plane? Вряд ли LDP знает столько же? Наверняка у него ещё есть козыри в рукаве?  
Так и есть:

![](https://img-fotki.yandex.ru/get/5508/83739833.45/0_fd602_ba8014a_orig.png)

Для каждого FEC мы тут видим информацию о различных метках:  
_local binding_ — что этот LSR передаёт соседям  
_remote binding_ — что этот LSR получил от соседей.

На иллюстрации выше вы можете видеть слово «tib». **TIB — это** _**Tag Information Base**_, которая правильно называется Label Information Base — LIB.  
Это пережиток почившего в бозе [TDP](http://lookmeup.linkmeup.ru/#term510) — прародителя LDP.

Обратите внимание, что везде по 2 remote binding — это два пути получения меток. Например, до R2 можно добрать от R1 напрямую, а можно через R3-R4-R5-R2.  
То есть, понимаете да? Мало того, что он из каждой записи в таблице маршрутизации делает FEC, так этот негодяй ещё и Liberal Retention Mode использует для удержания меток.  
Давайте подытожим: по умолчанию LDP в Cisco работает в следующих режимах:

* DU
* Independent Control
* Liberal Retention Mode
* В качестве FEC выбираются все записи в таблице маршрутизации

Короче говоря, щедроты его не знают границ.

Есть ещё команда **show mpls ip binding**. Она показывает нечто похожее и позволяет кроме того быстро узнать, какой путь сейчас активен, то есть как построен LSP:

![](https://img-fotki.yandex.ru/get/5803/83739833.45/0_fd601_ffd5c0da_orig.png)

И последний, пожалуй, вопрос, который возникает в связи со всеми этими LSP — когда маршрутизатор сам является Ingress LSR, как он понимает, что нужно делать с пакетами, как выбрать LSP?  
А для этого вот и придётся заглянуть в IP CEF. Вообще именно на Ingress LSR ложится всё бремя обработки пакета, определения FEC и назначения правильных меток.

![](https://img-fotki.yandex.ru/get/3012/83739833.45/0_fd5fc_fe25908f_orig.png)

Тут вам и Next Hop и выходной интерфейс и выходная метка

И тут уже вы должны заметить, что в LDP понятия LER, Ingress LSR, Egress LSR — это не роль каких-то конкретных узлов или характеристика местоположения узла в сети. Они неотделимы от FEC и LSP, индивидуальны для них. То есть для каждого конкретного FEC есть один или несколько Egress LSR и множество Ingress LSR \(как правило, все маршрутизаторы\), до которых ведут LSP.  
Даже скажем так, понятия LER возникают когда мы говорим о конкретном LSP, тогда мы можем сказать, кто является Ingress, кто Egress.

### MPLS и BGP

До сих пор мы говорили о том как MPLS взаимодействует с IGP-протоколами. Мы убедились, что ничего сложного в этом нет и что настройки также довольно простые.

Но самое интересное кроется во взаимодействии MPLS с BGP. В этом выпуске мы лишь слегка затронем эту тему. Но в следующих, мы поговорим подробнее о том, какую роль играет BGP, и как с помощью него и MPLS мы можем организовывать различные типы VPN.  
Сейчас же нам надо разобраться как MPLS и BGP взаимодействуют на самом базовом уровне.

Главное отличие BGP от IGP заключается в том, что MPLS не создает метки для маршрутов BGP. Если вспомнить о том, какое количество маршрутов передает BGP, то становится понятно, что это очень хорошая идея. Как же тогда состыковать MPLS и BGP?  
Все просто:

1. создаем метки только для адресов, которые будут указаны как next-hop для маршрутов, которые мы получаем по BGP \(тут надо не забыть про next-hop-self для IBGP-соседей\).
2. Когда нашему Ingress LSR понадобится передать пакеты по маршруту, который был получен по BGP, отправляем их к next-hop, который указан в маршруте и используем ту метку, которая была создана для него.

Теперь, вместе того чтобы настраивать BGP на каждом маршрутизаторе в нашей AS, мы можем настраивать его только на пограничных маршрутизаторах, к которым подключены клиенты или другие провайдеры.

Посмотрим на примере сети:  
![](https://img-fotki.yandex.ru/get/17911/83739833.48/0_100a4b_f130e3b2_XXL.png)

Если нам надо добраться с R1 до сетей Филькин Сертификат, мы смотрим, что они доступны через R6 и «пролетаем» через MPLS до адреса 6.6.6.6. А когда мы добираемся до R6, он уже знает куда идти дальше. Аналогично будет и наоборот, в Балаган-Телеком.

Конфигурацию для этой схемы и пару команд с выводом информации, можно найти по [ссылке](https://docs.google.com/document/d/19ehYnTkg4Y-NvGyxWAzPm4c2vhTTL_dIZRNvwkAahk4/pub).

> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 4**](https://linkmeup.ru/blog/158.html)  
>   
> В сети настроены MPLS и OSPF. MPLS настроен во всей сети, кроме соединения между R7 и R1.  
> Между маршрутизаторами R1-R2-R3-R4-R5-R6 трафик должен передаваться силами MPLS.  
> В сети также настроен BGP, который работает между R1 и R6.  
>   
> Для маршрутов BGP не генерируются метки.  
> Для того чтобы R1 мог добраться до маршрутов, которые получены по BGP от R6, пакеты передаются средствами MPLS до IP-адреса, который указан как next-hop в маршрутах BGP.  
>   
> Сейчас с R7 недоступен маршрут, который анонсируется по BGP маршрутизатором R6.  
>   
> **Задание:**  
> Восстановить работу сети, чтобы с R7 пинговался адрес 100.0.0.1.  
>   
> **Ограничения:**  
> Нельзя менять настройки BGP.  
>   
> **Схема** ![](https://img-fotki.yandex.ru/get/15537/83739833.48/0_100a4a_ed0fdad5_orig.png)  
>   
> Подробности задачи и конфигурации узлов [тут](https://linkmeup.ru/blog/158.html).

### RSVP-TE

LDP хорош. Работает он просто и понятно. Но есть такая технология, как MPLS TE — Traffic Engineering. И ей недостаточно лучшего маршрута, который может обеспечить LDP.  
Управление трафиком подразумевает, что вы можете направить трафик между узлами как вам угодно, учитывая различные ограничения.  
Например, в нашей сети клиент имеет две точки подключения своих узлов — на R1 и на R6. И между ними он просит предоставить ему VPN с гарантированной шириной канала в 100 Мб/с. Но при этом у нас в сети ещё и обычные ШПДшники видео гоняют с вконтактика и дюжина других клиентов, которые VPN арендуют, но полосу им резервировать не надо.  
Если не вмешаться в эту ситуацию, где-нибудь на R2 может возникнуть перегруз, и 100 Мб/с для дорогого клиента не достанется.

MPLS TE позволяет пройти по всей сети от отправителя до получателя и зарезервировать ресурсы на каждом узле. Если вы знакомы с концепцией IntServ, то да, это именно она — организовать QoS на всём протяжении пути, вместо того, чтобы позволить каждому маршрутизатору самому принимать решение для проходящего пакета.  
Собственно, протокол **RSVP** \(_**Resource ReSerVation Protocol**_\) изначально \(в 1993-м году\) и был задуман для организации IntServ в IP-сетях. Он должен был донести информацию о QoS для какого-то конкретного потока данных до каждого узла и заставить его зарезервировать ресурсы.

В первом приближении работает он просто.

1\) Узел-источник хочет отправить поток данных со скоростью 5 Мб/с. Но перед этим он посылает RSVP запрос на резервирование полосы до получателя — **Path Message**. Это сообщение содержит некие идентификаторы потока, по которым узел потом сможет идентифицировать принадлежность полученных IP-пакетов потоку, и требуемую ширину полосы.  
2\) Сообщение Path передаётся от узла к узлу до самого получателя. Куда его послать, определяется на основе таблицы маршрутизации.  
3\) Каждый маршрутизатор, получив Path, проверяет свои ресурсы. Если у него есть достаточно свободной полосы, он настраивает свои внутренние алгоритмы так, чтобы пакеты потока были обработаны как следует и пропускной способности всегда хватало.  
4\) Если же у него нет необходимых 5 Мб/с \(занято другими потоками\), он отказывает в выделении ресурсов и возвращает соответствующее сообщение отправителю.  
5\) Пакет Path доходит до получателя потока, тот отправляет назад сообщение **Resv**, подтверждая выделение ресурсов на всём протяжении пути.  
6\) Изначальный отправитель, получив Resv, понимает, что всё для него готово, и он может отправлять данные.

На самом деле под этими четырьмя простыми шагами лежат гораздо более сложные процессы, но нам это не интересно.

А вот что нам интересно — так это расширение **RSVP для Traffic Engineering**, или проще — **RSVP TE**, которое было разработано специально для MPLS TE.  
Его задача такая же, как у LDP — распределить метки между LSR и скомпилировать в итоге LSP от получателя до отправителя. Но теперь, как вы уже поняли, появляются нюансы — LSP должен удовлетворять определённым условиям.

RSVP TE позволяет строить основной и запасной LSP, резервировать ресурсы на всех узлах, обнаруживать аварии на сети, строить заранее обходные пути, делать быстрое перенаправление трафика, избегать каналов, которые физически проходят по одному пути.  
Но всё это мы будем обсуждать в статье о MPLS TE через пару выпусков. А сегодня же мы сосредоточимся на принципах, согласно которым RSVP TE строит LSP.

> От смены протокола не меняется то, что LSP — однонаправленный, соответственно и ресурсы будут резервироваться только в одном направлении. Хочешь в другом — создавай обратный LSP.

Для начала мы отбросим функционал резервирования ресурсов — пусть наша задача только создать LSP, то есть распределить метки между LSR.

Чтобы это стало возможно, стандартный RSVP расширяется добавлением нескольких объектов. Рассмотрим простейший вариант.  
0\) R1 нужен LSP до FEC 6.6.6.6/32. Это выглядит как интерфейс Tunnel на R1, у которого адрес назначений 6.6.6.6 и тип Traffic Engineering.  
1\) Он посылает сообщение RSVP Path в направлении 6.6.6.6. В этом сообщении появляется новый объект — **Label Request**. Сообщение Path провоцирует узел выделить метку для данного FEC — то есть это запрос метки.  
2\) Следующий узел формирует новое сообщение Path и также отправляет его в сторону 6.6.6.6. Итд.  
3\) Path достигает Egress LSR. Тот видит, что пакет-то ему адресован, выделяет метку и отправляет источнику сообщение Resv. В последнем тоже добавлен новый объект — **Label**. В нём Egress LSR передаёт свою метку для этого FEC предпоследнему, предпоследний предпредпоследнему свою итд.  
4\) Resv достигает источника, распределяя по пути метки. Таким образом создан LSP, а источник уведомлён, что всё готово.

Метки запрашиваются вниз по течению \(сообщение Path от отправителя к получателю\), а передаются вверх по течению \(сообщение Resv от получателя к отправителю\).  
При этом обратите ваше внимание на то, что это уже самый что ни на есть Downstream on Demand + Ordered Control. Path выступает запросом метки, а Resv идёт от получателя шаг за шагом и, пока метку не выслал нижестоящий LSR, вышестоящий не может её отправить своим соседям.

Стоп! Мы говорили, что RSVP TE в отличие от LDP позволяет строить как мы хотим, не привязываясь к таблице маршрутизации и IGP, а тут пока просто «в направлении 6.6.6.6».  
И вот тут мы подошли вплотную к фундаментальному отличию RSVP TE от LDP. RSVP TE очень тесно связан с протоколами динамической маршрутизации, он не просто опирается на результат их работы — он адаптирует их под себя, эксплуатирует в прямом смысле слова.  
**Во-первых**, годятся только протоколы, основанные на алгоритмах по состоянию связи \(link-state\), то есть OSPF и ISIS.  
**Во-вторых**, OSPF и ISIS расширяются введением новых элементов в протоколы. Так в OSPF появляется новый тип _LSA — Opaque LSA_, а в ISIS — новые _TLV IS Neighbor_ и _IP Reachability_.  
**В-третьих**, для расчёта пути между Ingress LSR и Egress LSR используется специальная модификация алгоритма SPF — CSPF \(_Constrained Shortest Path First_\).

Теперь подробнее.

Сообщение Path в принципе передаётся юникастом адресно. То есть адрес отправителя у него — адрес R1, а получателя — 6.6.6.6. И оно могло бы дойти и просто по таблице маршрутизации.

![](https://img-fotki.yandex.ru/get/15514/83739833.46/0_fea14_2c156001_orig.png)

Но фактически Path передаётся по сети не как FIB на душу положит на каждом узле, ведь мы тогда не сможем ни резервирование обеспечить, ни поиск запасных маршрутов. Нет, он следует определённому пути.  
Этот путь определяется на Ingress LSR с точностью до каждого узла.  
Чтобы построить этот путь, RSVP TE нужно знать топологию сети. Понимаете да, к чему мы приближаемся? Сам RSVP не утруждает себя её изучением, да и зачем, когда её можно получить у OSPF или ISIS. И тут же становится очевидно, почему сюда не подходят RIP, IGRP и EIGRP — ведь они не изучают топологию, максимум на что они способны — это Feasible Successor.  
Но классический алгоритм SPF на входе имеет топологию сети, а на выходе может выдать только наибыстрейший маршрут с учётом метрик и [AD](http://lookmeup.linkmeup.ru/#term503), хотя просчитать может и все возможные пути.  
И тут на сцену выходит CSPF. Именно этот алгоритм может посчитать лучший путь, второй по приоритетности путь и, например, ещё какой-нибудь запасной, чтобы хоть как-то добраться, пусть и [через Китай](https://linkmeup.ru/topic/edit/150/).  
То есть RSVP TE может обращаться к CSPF с просьбой вычислить для него какой-либо путь между двумя узлами.  
Ну хорошо, а зачем для этого менять сами протоколы IGP? Вооот. А это уже Constraints — ограничения. RSVP TE может предъявлять требования к пути — ширина полосы пропускания, минимально доступная ширина, тип линии или даже узлы, через которые LSP должен пролегать. Так вот, чтобы CSPF мог учитывать ограничения, он должен знать и о них и о доступных ресурсах на узлах всей сети. Входными данными для него являются ограничения, заданные в туннеле и топология сети — логично будет, если топология будет содержать кроме префиксов и метрик ещё и информацию о доступных ресурсах.  
Для этой цели маршрутизаторы обмениваются между собой через сообщения OSPF и ISIS не только базовой информацией, но и характеристиками линий, интерфейсов итд. Как раз в новых типах сообщений и передаётся эта информация.  
Например, в OSPF для этого ввели 3 дополнительных типа LSA:

* **Type 9** — link-local scope
* **Type 10** — area-local scope
* **Type 11** — AS scope

_**Opaque**_ значит непрозрачный \(для OSPF\). Это специальные типы LSA, которые никак не учитываются в самом OSPF при расчёте таблицы маршрутизации. Их могут использовать любые другие протоколы для своих нужд. Так TE их использует для построения своей топологии \(она называется **TED —** _**Traffic Egineering Database**_\). Но теоретически за TE они не закреплены — если вы напишете своё приложение для маршрутизаторов, которое будет требовать обмена какой-то информацией о топологии, вы тоже можете использовать Opaque LSA.  
Точно так же работает и ISIS. Новые сообщения: IS-IS TLV 22 \(Extended IS Reachability\), 134 \(Traffic Engineering router ID\), 135 \(Extended IP reachability\).

Итак, взглянем более детализированно на весь этот процесс.

**0\)** На R1 мы включили MPLS TE и настроили ISIS \(OSPF\) на передачу данных для поддержки TE. Маршрутизаторы обменялись информацией о доступных ресурсах. На этом шаге сформирована TED. RSVP молчит.

![](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/e49/7a6/f18/e497a6f187b049e18a5b9a85d1ce9414.gif)

**1\)** Мы создали туннельный интерфейс, где указали его тип \(Traffic Engineering\), адрес назначения \(6.6.6.6\) и необходимые требования по ресурсам. LSR запускает CSPF: нужно вычислить кратчайший путь от R1 до 6.6.6.6 с учётом накладываемых условий. На этом шаге мы получаем оптимальный путь — список узлов от источника до получателя \(R2, R5, R6\).

**2\)** Результат предыдущего шага скармливается RSVP и трансформируется в объект **ERO**. R1 компилирует RSPV Path, куда, естественно, добавляет ERO. Адресат пакета — 6.6.6.6. Кроме того, имеется и объект Label Request, сообщающий о том, что при получении пакета нужно выделить метку для данного FEC \(6.6.6.6/32\).

> **ERO — Explicit Route Object** — специальный объект сообщения RSVP Path. Он содержит список узлов, через которые суждено пройти этому сообщению.

**3\)** Сообщение RSVP Path передаётся специальным образом — не по таблице маршрутизации, а по списку ERO. В нашем случае лучший маршрут IGP и ERO совпадают, поэтому пакет посылается на R2.

**4\)** R2, получив RSVP Path, проверяет наличие требуемых ресурсов и, если они есть, выделяет метку MPLS для FEC 6.6.6.6/32. Старый пакет Path уничтожается и создаётся новый, причём объект ERO меняется — из него удаляется сам R2. Делается это для того, чтобы следующий узел не пытался вернуть пакет на R2. То есть новый ERO выглядит уже так: \(R5, R6\). В соответствии с ним R2 отправляет обновлённый Path на R5.

**5\)** R5 совершает аналогичные операции: проверяет ресурсы, выделяет метку, удаляет себя из ERO, пересоздаёт пакет Path и передаёт в интерфейс, через который ему известен следующий объект ERO — R6.  
![](https://img-fotki.yandex.ru/get/16132/83739833.46/0_fea3a_514e0c91_orig.png)

**6\)** R6, получив пакет, понимает, что он виновник всей суматохи. Он уничтожает Path, выделяет метку для FEC 6.6.6.6 и вставляет её как объект **Label** в ответное сообщение Resv.  
Заметьте, до этого шага метки только выделялись, но не распространялись, теперь же они начинают анонсироваться тем LSR, которые их запрашивали.  
**7\)** Сообщение RESV продвигается к R1 \(Ingress LSR\), оставляя за собой растущий хвост LSP. Resv должно пройти через те же узлы, что Path, но в обратном порядке.

![](https://img-fotki.yandex.ru/get/15523/83739833.46/0_fea24_2f014439_orig.png)

**8\)** В конце концов LSP от R1 до 6.6.6.6 сформирован. Данные по нему могут передаваться только от R1 к R6. Чтобы позволить передачу данных в обратном направлении, нужно создать туннельный интерфейс на R6 с адресом назначения 1.1.1.1 — все действия будут точно такими же.

![](https://img-fotki.yandex.ru/get/15570/83739833.46/0_fea22_b48dd8f6_orig.png)

Возникает вопрос — почему адресат пакета Path 6.6.6.6, если передаётся он узел за узлом и их адреса известны? Вопрос этот не праздный — он ведёт нас к одной важной особенности. Объект ERO может на самом деле содержать не все узлы от Ingress LSR до Egress LSR — некоторые могут быть опущены. Поэтому каждый LSR должен знать, куда в итоге направляется сообщение. И происходить это может не потому что Ingress LSR лень просчитать весь путь.  
Проблема в зонах IGP. Вы знаете, что и в OSPF и в ISIS существует это понятие для того, чтобы упростить маршрутизацию. В больших сетях \(сотни и тысячи узлов\) встаёт проблема широковещательных рассылок служебных пакетов и просчёт огромного количества комбинация алгоритмом SPF. Поэтому один глобальный домен делится на зоны маршрутизации.  
И вся загвоздка в том, что если внутри зоны IGP и является протоколом по состоянию связи \(link-state\), то между ними — он самый настоящий дистанционно-векторный — топология сети строится только внутри зоны, любые внутренние маршрутизаторы не знают, как устроены другие зоны — они только поставлены в известность, что для того, чтобы попасть в ту или иную сеть, им нужно отправлять пакеты на конкретный [ABR](http://lookmeup.linkmeup.ru/#term504).  
Иными словами, если у вас сеть поделена на зоны, то с MPLS TE возникают затруднения — CSPF не может просчитать весь путь, потому что в его топологии адресат из другой зоны — это облако, а не конкретный узел.

И тут на помощь приходит **Explicit Path** \(не путать с объектом ERO\). Это самый, что ни на есть, прямой способ управления путём построения LSP — администратор может самостоятельно и явно задать те узлы, через которые нужно проложить LSP. Ingress LSR должен точно следовать таким указаниям. Это вносит в жизнь алгоритма CSPF ещё немного разнообразия.  
Как Explicit Path помогает пробить зону? Давайте на примере.

![](https://img-fotki.yandex.ru/get/15506/83739833.48/0_100a2b_e29fa551_orig.png)

Мы возьмём и укажем, что обязательно должны быть промежуточные точки:  
Explicit-path: R1, R3, R5.

Когда этот Explicit Path мы скармливаем CSPF, он строит тот кусок, который может, то есть в пределах Area 0: от R1 до R3.  
То, что он насчитал, заносится в ERO, плюс в него добавляются и ещё один узел из Explicit-path — R5. Получается: R1, R2, R3. Path отправляется по сети согласно ERO, доходит до R3. Тот видит, что он в общем-то не адресат, а только перевалочный пункт, берёт заданные условия по требуемым ресурсам и адрес узла-получателя из Explicit-path и запускает CSPF. Последний выдаёт полный список узлов до адресата \(R3, R4, R5\), который преобразуется в ERO, и дальше всё происходит по стандартному сценарию.  
То есть в случае нахождения Ingress LSR и Egress LSR в разных зонах вычисление пути выполняется отдельно для каждой зоны, а контрольной точкой является ABR.

Следует понимать, что Explicit Path используется не только для этого случая, но это вообще удобный инструмент, ведь вы можете явно указать, как нужно проложить LSP или наоборот, через какие узлы не надо прокладывать LSP.  
Этого и много другого мы коснёмся детально в выпуске, посвящённом MPLS TE.

> Меня могут упрекнуть в лукавстве, сказав, что не настолько уж и обязателен Link-State IGP. Ну вот хочется на моноцисочной сети запустить EIGRP, сил нет. Или вообще некрофильные позывы заставляют откопать RIP. И что теперь? Отказаться от TE?  
> В общем есть спасение, но только на оборудовании Cisco — называется оно [Verbatim](http://www.cisco.com/c/en/us/td/docs/ios/mpls/configuration/guide/12_2sy/mp_12_2sy_book/mp_te_verbatim_path.html).  
>   
> Ведь для чего нам нужен Link-State протокол? Он собирает информацию о топологии TE, а CSPF строит путь от Ingress LSR до Egress LSR. Таак. Отлично. А что если мы возьмём и состряпаем Explicit Path, где перечислим все узлы один за другим? Ведь тогда не надо ничего считать.  
> На самом деле, как бы подробно вы ни составили явный путь, он всё равно будет передан CSPF.  
> Но такое поведение можно отключить. Как раз для случаев, описанных выше.  
> Поможет такая команда:
>
> ```text
> Router(config-if)# tunnel mpls traffic-eng path-option 1 explicit name test verbatim
> ```
>
> То ест данный путь будет взят как заведомо верный безо всяких проверок и пересчётов CSPF.  
> Такой сценарий стоит под большим вопросом, а его плюсы весьма призрачны. Однако возможность есть, и не говорите потом, что я вам про неё не рассказал.

#### Практика RSVP TE

![](https://img-fotki.yandex.ru/get/15521/83739833.46/0_fea21_f32bf6b2_orig.png)

Команда **mpls ip** была нам нужна для работы LDP. Теперь в ней больше нет нужды — удаляем её и начинаем с [чистого листа](https://docs.google.com/document/d/1YZUNAu3NmdXyTOt118jjxRrA-p61kUVcpkf6yS-WHxQ/pub).  
Теперь нам понадобится **mpls traffic-eng tunnels**. Она глобально включает поддержку TE-туннелей и собственно RSVP TE:

```text
R1(config)#mpls traffic-eng tunnels
```

Также необходимо включить то же самое на интерфейсах:

```text
R1(config)# interface FastEthernet 0/0
R1(config-if)# mpls traffic-eng tunnels 
R1(config)# interface FastEthernet 0/1
R1(config-if)# mpls traffic-eng tunnels
```

Пока ничего не происходит. RSVP молчит.

Сейчас мы расширим IGP на передачу данных TE. В своём примере мы используем ISIS:

```text
R1(config)#router isis 
R1(config-router)# metric-style wide
R1(config-router)# mpls traffic-eng router-id Loopback0
R1(config-router)# mpls traffic-eng level-2
```

Включить режим расширенных меток — обязательно, иначе TE не заработает.  
Задать LSR-ID, как мы это делали и в LDP,  
Необходимо задать конкретный уровень ISIS, иначе, TE не заработает.

> **Если вдруг вы используете OSPF**
>
> R1\(config-router\)\# mpls traffic-eng area 0  
> R1\(config-router\)\# mpls traffic-eng router-id Loopback0

Эти шаги нужно повторить на других маршрутизаторах.

Сразу после этого ISIS начинает обмениваться информацией о TE:

![](https://img-fotki.yandex.ru/get/16132/83739833.46/0_fea12_633d17ff_orig.png)

Как видите передаётся информация о LSR-ID, расширенная информация о соседях \(которые поддерживают TE\), расширенная информация о интерфейсах.

На этом этапе сформирована TED.

Саму топологию вы можете посмотреть в ISIS: **\#show isis database verbose**

RSVP пока молчит.

Теперь настроим TE-туннель.

```text
R1(config)# interface Tunnel1
R1(config-if)# ip unnumbered Loopback0
R1(config-if)# tunnel destination 6.6.6.6
R1(config-if)# tunnel mode mpls traffic-eng
R1(config-if)# tunnel mpls traffic-eng path-option 10 dynamic
```

Туннельные интерфейсы — вещь очень универсальная на маршрутизаторах. Они могут использоваться для L2TP, GRE, IPIP и, как видите, для MPLS TE.  
**ip unnumbered Loopback0** означает, что отправной точкой туннеля должен быть адрес интерфейса Loopback0.  
**tunnel destination 6.6.6.6** — универсальная для туннельных интерфейсов команда, определяет точку терминации, окончания туннеля.  
**tunnel mode mpls traffic-eng** — задаёт тип. Именно здесь и определяется алгоритм работы туннеля, как его строить.  
**tunnel mpls traffic-eng path-option 10 dynamic** — эта команда позволяет CSPF построить путь динамически, без задания промежуточных узлов.

Если до этого вы всё сделали правильно, то туннельный интерфейс должен подняться:

```text
%LINEPROTO-5-UPDOWN: Line protocol on Interface Tunnel1, changed state to up
```

Что при этом произошло?  
**R1 отправил Path.**

![](https://img-fotki.yandex.ru/get/15596/83739833.46/0_fea13_22e1ef99_orig.png)  
_Дамп снят на линии R1-R2._

Нас в нём интересуют адрес назначения, объекты ERO и Label Request.  
**Адрес назначения** — 6.6.6.6, как и настроили в туннеле.  
**Explicit Route:**  
10.0.12.2 **-&gt;** 10.0.25.2 **-&gt;** 10.0.25.5 **-&gt;** 10.0.56.5 **-&gt;** 10.0.56.6.  
То есть в нём прописан линковый адрес выходного интерфейса и линковый же адрес следующего узла. Каждый LSR таким образом точно знает, в какой интерфейс нужно отправить Path.  
В данном ERO нет 10.0.12.1, потому что R1 уже удалил его перед отправкой.  
Факт наличия **Label Request** говорит о том, что LSR должен выделить метку для данного FEC.  
При этом он никак не отвечает на этот Path **пока** — он посылает обновлённый дальше.  
_Resv ниже посылается после того, как пришёл Resv от нижестоящего LSR._

То же самое происходит на R5:

![](https://img-fotki.yandex.ru/get/15522/83739833.46/0_fea16_2d761c44_orig.png)  
_Дамп снят на линии R2-R5._

![](https://img-fotki.yandex.ru/get/16130/83739833.46/0_fea17_38a6543d_orig.png)  
_Дамп снят на линии R2-R5._

Так Path доходит до R6. Тот отправляет назад RSPV Resv:

![](https://img-fotki.yandex.ru/get/15531/83739833.46/0_fea19_9698c760_orig.png)  
_Дамп снят на линии R5-R6._

На дампе хорошо видно, что Resv передаётся от узла к узлу.  
В объекте **Label** передаётся метка, выделенная данному FEC.

Обратите внимание, что R6 присвоил метку 0 — Expliсit Null. Вообще это нормальная ситуация — делается это для того, чтобы метка MPLS между R5 и R6 была \(для обработки пакета согласно значению в поле EXP, например\), но R6 сразу же понял, что метку 0 надо сбрасывать и обрабатывать то, что под ней, а не производил поиск в таблице меток.  
Проблема в том, что в пакете меток может быть больше одной \(например, для VPN\), но согласно [RFC 3032](http://tools.ietf.org/html/rfc3032) \(да и мы раньше об этом говорили\) R5 должен удалить весь стек меток, сколько бы их ни было, и передать пакет с одной меткой 0. При этом, конечно, всё сломается.  
На самом деле, требование того, чтобы метка 0 была единственной в стеке, выглядит неоправданным — применений этому нет. Поэтому в [RFC 4182](https://tools.ietf.org/html/rfc4182) это ограничение убрали. Теперь метка 0 может быть не единственной в стеке.  
Интересная особенность — PHP. Несмотря на то, что для этого есть специальная метка — 3 — LSR совершит PHP даже при получении метки 0. Подробнее у того же [Пепельняка](http://blog.ipspace.net/2008/09/mpls-te-if-you-want-standard-compliance.html).

R5 передаёт Resv на R2, а R2 на R1.  
![](https://img-fotki.yandex.ru/get/16132/83739833.46/0_fea18_2f267f6c_orig.png)  
_Дамп снят на линии R1-R2._

Тут, как видите, уже метка нормальная — 16.

> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 5**](https://linkmeup.ru/blog/159.html)  
>   
> Как бы внимательно вы ни приглядывались к Resv, вы не увидите там пути, по которому нужно пройти, а список узлов должен быть тем же самым, чтобы успешно раздать метки и построить LSP. Как это решается?  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/159.html).

#### Explicit Path

Давайте теперь попробуем поменять путь — трафик должен пройти через R1-R3-R4-R5-R6.  
Проще простого: нужно всего-лишь настроить explicit-path:

```text
R1(config)# ip explicit-path name R1-to-R6-primary 
R1(cfg-ip-expl-path)# next-address 10.0.13.3 
R1(cfg-ip-expl-path)# next-address 10.0.34.4 
R1(cfg-ip-expl-path)# next-address 10.0.45.5 
R1(cfg-ip-expl-path)# next-address 10.0.56.6
```

И применить его на туннельный интерфейс:

```text
R1(config)# Interface Tunnel 1
R1(config-if)# tunnel mpls traffic-eng path-option 5 explicit name R1-to-R6-primary
```

Заметьте, что приоритет мы ему поставили выше, чем предыдущему правилу — 5 против 10. То есть сначала будет использоваться explicit-path, а если с ним какие-то проблемы, тогда R1 попытается построить LSP динамически \(уж как-нибудь\).

Конфигурация туннеля выглядит сейчас так:

```text
interface Tunnel1
ip unnumbered Loopback0
tunnel destination 6.6.6.6
tunnel mode mpls traffic-eng
tunnel mpls traffic-eng path-option 5 explicit name R1-to-R6-primary
tunnel mpls traffic-eng path-option 10 dynamic
no routing dynamic
```

А так выглядит сообщение Path, несущее в себе новый ERO:

![](https://img-fotki.yandex.ru/get/15487/83739833.46/0_fea15_92ad51df_orig.png)

Чтобы просмотреть информацию о туннеле, выполните команду **show mpls traffic-eng tunnels**:

![](https://img-fotki.yandex.ru/get/16121/83739833.46/0_fea1a_50a3f8ab_orig.png)

Можно это посмотреть и на промежуточном:

![](https://img-fotki.yandex.ru/get/16177/83739833.46/0_fea1b_e00cf26_orig.png)

Как LSP формируется при наличии требований по ресурсам, что такое Loose и Strict, FRR и make before break, Affinity и прочее, читайте через пару выпусков в статье про MPLS TE.

[Файл итоговой конфигурации RSVP-TE](https://docs.google.com/document/d/1A2xZ9kXWEUrrUYc5fcRwd_9U-lgXZQ0L3N1b3GLg1FA/pub).

## ВиО

**В1:** Чем отличаются RSVP TE LSP и LDP LSP?

> Строго говоря, с точки зрения как вышестоящиех протоколов, так и самого MPLS таких понятий нет вообще. LSP — он и есть LSP — это просто путь коммутации меток.  
> Можно выделить термин CR-LSP \(ConstRaint-based LSP\) — он строится RSVP TE. В этом плане разница в том, что CR-LSP удовлетворяет условиям заданным в туннельном интерфейсе.

**В2:** Как соотносятся Explicit Path и ERO?

> Если для туннеля задан Explicit Path, то RSVP формирует ERO, учитывая требования Explicit Path. При этом даже если вы в Explicit-Path пропишите каждый узел до Egress LSR, RSVP всё равно загонит данные в CSPF.

**В3:** Если один из промежуточных узлов не будет поддерживать LDP \(RSVP TE\) или протокол будет выключен на интерфейсе/платформе, будет ли построен LSP так, например, чтобы на этом узле он переходил в IP, а потом на следующем снова в MPLS?

> В случае RSVP TE Ingress LSR не будет иметь данного узла в TED и не сможет выстроить путь до Egress LSR, соответственно не пошлёт Path, соответственно, не будет и меток и LSP.  
> Трафик через туннель передаваться не сможет.  
>   
> Если же речь о LDP, то ситуация интереснее. Например, если на R2 выключить LDP на интерфейсе FE0/0 \(в сторону R5\), то  
> 1\) на R1 будет метка для FEC 6.6.6.6/32. Причём их будет 2: одна через R2, другая — через R3, поскольку согласно таблице маршрутизации лучший — через R2, то и LSP будет лежать в сторону R2.  
> 2\) на R2 метка будет, но только одна — в сторону 1.1.1.1. Это не лучший путь, поэтому он не будет использован. То есть здесь LSP от R1 к FEC 6.6.6.6/32 прекращает своё существование.  
> 3\) на R5 метка для FEC 6.6.6.6/32 будет  
>   
> То есть, вроде бы, мы получаем разорванный LSP: {R1-R2, R5-R6}. Но на самом деле, это не так. LSP на то и Label Switched, чтобы на протяжении всего пути на нём менялись метки, а у нас получается от R1 до R2 MPLS, от R2 до R5 IP, а от R5 до R6 опять MPLS. **LSP для FEC 6.6.6.6/32 здесь нет**. Обычный трафик тут пройдёт, в принципе, но если говорить о каких-то применениях MPLS, таких, например, как VPN, то это работать не будет.

**В4:** Хорошо, зачем нужен MPLS будет понятно из следующих статей — пока это вообще какая-то искусственная ерунда, чтобы усложнить жизнь инженера, но зачем мне MPLS TE-то? Ведь трафик можно направить нужным мне путём с помощью метрик IGP.

> Начнём с того, что это тема будущих выпусков. Но…  
> Вообще говоря, если вы хотите определять путь, по которому пойдёт трафик, то это действительно можно сделать путём хитрой настройки стоимости линков, интерфейсов итд. Но обслуживание такой системы доставит вам те ещё хлопоты с одной стороны, а с другой у вас всё равно не получится направить два разных потока разными путями. То есть если стоит задача разгрузить сеть путём распределения трафика, то с помощью метрик вы просто перенесёте проблему с одного плеча на другое.  
> А вот если у вас будет несколько разных LSP и вы сможете направить в них трафик, то это пожалуйста. Хотя в плане простоты поддержки TE тоже вызывает вопросы.  
>   
> Ну и вообще подумайте, если вам нужны для двух клиентов гарантированные каналы 40 Мб/с и 50 Мб/с соответственно, как вы будете отслеживать утилизацию линий? Ну хорошо, один раз вы вычислили и настроили каким-то чудесным образом маршрутизацию и QoS так, чтобы обеспечить нужный уровень услуги, но вдруг у вас срезают в трёх местах 3 километра оптики разом и вы неделю не можете починить. И у вас даже есть три резервных канала по 50Мб/с, но трафик обоих клиентов попёр в одно место, наплевав на все ваши формальные [SLA](http://lookmeup.linkmeup.ru/#term433).

**В5:** Так чем всё-таки отличаются метки Explicit Null и Implicit Null? Нужно ли мне о них действительно знать?

> Нужно. Первоначально предполагается, что по сети MPLS пакет всегда **коммутируется** по меткам от первого до последнего LSR. А на последнем пролёте метка будет «0», чтоб Egress LSR сразу знал, что её нужно снять. Эта метка позволяет не потерять приоритет, заданный в поле TC заголовка MPLS, который копируется по мере передачи пакета по сети. В итоге даже последний маршрутизатор обработает данные в правильных очередях.  
>   
> В концепции с использованием метки «3» решили отказаться от лишних действий на Egress LSR. Если вас не волнует QoS \(или вы скопировали приоритет, например, в поле DSCP\), то острой нужды в транспортной метке на последнем пролёте нет — главное отправить в правильный интерфейс, а там Egress LSR разберётся. Если там был чистый IP-пакет — отдать его процессу IP, если был какой-нибудь E1, передать поток в нужный интерфейс, если стек меток, то сделать lookup в LFIB и посмотреть, какие дальнейшие действия нужно предпринять.

**В6:** Для одного FEC LSR всегда будет выделять одну и ту же метку всем своим соседям?

> Существует понятие пространства меток:
>
> * пространство меток интерфейса
> * пространство меток слота
> * пространство меток платформы
>
> Если метки специфичны для каждого интерфейса, тогда для одного FEC в разные порты **могут** быть отправлены разные метки.  
> И наоборот — если метки специфичны для платформы \(читай всего LSR\), то маршрутизатор во все порты для одного FEC **обязан** отправить одинаковые метки.  
> В примерах ниже вы увидите, что у нас для одного FEC отправляются одинаковые метки разным соседям, но это ещё не говорит о том, как организовано пространство меток. Это вещь сугубо индивидуальная и завязана на аппаратном обеспечении.

Важно понимать, что технология MPLS никак не регламентирует протокол распространения меток, но конечные результаты на конкретной сети вполне могут различаться при использовании разных протоколов. Вышестоящие протоколы и приложения используют LSP безотносительно того, кем и как они построены.  
Кстати нередко в современных сетях встречается сценарий LDP over TE. В этом случае RSVP-TE используется для организации транспорта и реализации Traffic Engineering, а LDP для обмена метками VPN, например.  
Ingress LSR, записывая в заголовок MPLS первую метку, определяет весь путь пакета. Промежуточные маршрутизаторы просто меняют одну метку на другую. Содержимое может быть совершенно любым. Как раз вот эта мультипротокольность позволяет MPLS служить основой для разнообразных сервисов VPN.

## Полезные ссылки

* Замечательнейший документ для тех, кто в общих чертах представляет, что такое MPLS: [MPLS for Dummies](http://www.nanog.org/meetings/nanog49/presentations/Sunday/mpls-nanog49.pdf).
* Набор русских переводов RFC, весьма не плох:
* [Введение в MPLS, TE и QoS](http://book.itep.ru/4/4/mpls17.htm)
* [Архитектура MPLS](http://book.itep.ru/4/4/mpls18.htm)
* [Кодирование меток в MPLS](http://book.itep.ru/4/4/label.htm)
* [LDP](http://book.itep.ru/4/4/rfc3036.htm)
* [RSVP-TE](http://book.itep.ru/4/4/rfc3209.htm)
* Отчаянно рекомендую к чтению все публикации [Джефа Дойла](http://www.networkworld.com/blog/jeff-doyle-on-ip-routing). Я искренне завидую его способности настолько просто даже на английском языке объяснять сложные вещи.
  * [Understanding the Role of FECs in MPLS](http://www.networkworld.com/article/2350449/cisco-subnet/understanding-the-role-of-fecs-in-mpls.html)
  * [Understanding MPLS Label Stacking](http://www.networkworld.com/article/2350577/cisco-subnet/understanding-mpls-label-stacking.html)
  * [Understanding Signaling in MPLS Networks](http://www.networkworld.com/article/2343494/cisco-subnet/understanding-signaling-in-mpls-networks.html)
  * [Understanding MPLS Label Distribution](http://www.networkworld.com/article/2237487/cisco-subnet/understanding-mpls-label-distribution.html)
  * [Understanding MPLS Explicit and Implicit Null Labels](http://www.networkworld.com/article/2350466/cisco-subnet/understanding-mpls-explicit-and-implicit-null-labels.html)
  * [Understanding MPLS CSPF](http://www.networkworld.com/article/2343657/cisco-subnet/understanding-mpls-cspf.html)

За финальные штрихи к статье спасибо [JDima](http://habrahabr.ru/users/jdima/).  
За задачки и помощь в написании статьи спасибо [Наташе Самойленко](http://xgu.ru/wiki/Категория:Автор_Наташа_Самойленко).  
КДПВ нарисована [Ниной Долгополовой](http://www.nina-dolgopolova.com/) — замечательным художником и другом проекта.  
Проверку ошибок и поиск неточностей провёл [Максим the gluck](http://habrahabr.ru/users/thegluck/)

