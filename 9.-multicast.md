# 9. Мультикаст

## Сети для самых маленьких. Часть девятая. Мультикаст

Наш умозрительный провайдер linkmeup взрослеет и обрастает по-тихоньку всеми услугами обычных операторов связи. Теперь мы доросли до IPTV.  
Отсюда вытекает необходимость настройки мультикастовой маршрутизации и в первую очередь понимание того, что вообще такое мультикаст.  
Это первое отклонение от привычных нам принципов работы IP-сетей. Всё-таки парадигма многоадресной рассылки в корне отличается от тёплого лампового юникаста.  
Можно даже сказать, это в некоторой степени бросает вызов гибкости вашего разума в понимании новых подходов.

В этой статье сосредоточимся на следующем:

* [Общее понимание Multicast](9.-multicast.md#Multicast_Basics)
* [Протокол IGMP](9.-multicast.md#IGMP)
* [Протокол PIM](9.-multicast.md#PIM)
* [PIM Dense Mode](9.-multicast.md#PIM-DM)
* [Pim Sparse Mode](9.-multicast.md#PIM-SM)
* [SPT Switchover — переключение RPT-SPT](9.-multicast.md#SPT_Switchover)
* [DR, Assert, Forwarder](9.-multicast.md#DR_Assert_Forwarder)
* [Автоматический выбор RP](9.-multicast.md#Bootstrap)
* [SSM](9.-multicast.md#SSM)
* [BIDIR PIM](9.-multicast.md#BIDIR_PIM)
* [Мультикаст на канальном уровне](9.-multicast.md#L2_Multicast)
* [IGMP Snooping](9.-multicast.md#IGMP_Snooping)
* [MVR](9.-multicast.md#MVR)

[![&#x41C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;](https://img-fotki.yandex.ru/get/9810/83739833.39/0_de148_8fc00820_XL.jpg)](https://img-fotki.yandex.ru/get/9810/83739833.39/0_de148_8fc00820_orig.jpg)

[Традиционный видеоурок](https://www.youtube.com/embed/uYnC6yU6Apo)

> На заре моего становления, как инженера, тема мультикаста меня неимоверно пугала, и я связываю это с психотравмой моего первого опыта с ним.  
> «_Так, Марат, срочно, до полудня нужно пробросить видеопоток до нашего нового здания в центре города — провайдер отдаст его нам тут на втором этаже_» — услышал я одним чудесным утром. Всё, что я тогда знал о мультикасте, так это то, что отправитель один, получателей много, ну и, кажется, протокол IGMP там как-то задействован.  
>   
> В итоге до полудня мы пытались всё это дело запустить — я пробросил самый обычный VLAN от точки входа до точки выхода. Но сигнал был нестабильным — картинка замерзала, разваливалась, прерывалась. Я в панике пытался разобраться, что вообще можно сделать с IGMP, тыркался, тыркался, включал мультикаст роутинг, IGMP Snooping, проверял по тысяче раз задержки и потери — ничего не помогало. А потом вдруг всё заработало. Само собой, стабильно, безотказно.  
>   
> Это послужило мне прививкой против мультикаста, и долгое время я не проявлял к нему никакого интереса.  
>   
> Уже гораздо позже я пришёл в к следующему правилу:  
> [![keep kalm and trust me](http://img-fotki.yandex.ru/get/9825/83739833.39/0_dd502_10ea996f_M.png)](http://img-fotki.yandex.ru/get/9825/83739833.39/0_dd502_10ea996f_orig.png)  
>   
> И теперь с высоты оттраблшученных кейсов я понимаю, что там не могло быть никаких проблем с настройкой сетевой части — глючило конечное оборудование.

Сохраняйте спокойствие и доверьтесь мне. После этой статьи такие вещи вас пугать не будут.

## Общее понимание Multicast

Как известно, существуют следующие типы трафика:  
**Unicast** — одноадресная рассылка — один отправитель, один получатель. \(_Пример: запрос HTTP-странички у WEB-сервера_\).  
**Broadcast** — широковещательная рассылка — один отправитель, получатели — все устройства в широковещательном сегменте. \(_Пример: ARP-запрос_\).  
**Multicast** — многоадресная рассылка — один отправитель, много получателей. \(_Пример: IPTV_\).  
**Anycast** — одноадресная рассылка ближайшему узлу — один отправитель, вообще получателей много, но фактически данные отправляются только одному. \(_Пример: Anycast DNS_\).

Раз уж мы решили поговорить о мультикасте, то, пожалуй, начнём этот параграф с вопроса, где и как он используется.

Первое, что приходит на ум, — это телевидение \(IPTV\) — один сервер-источник отправляет трафик, который хочет получать сразу много клиентов. Это и определяет сам термин — **multicast** — многоадресное вещание. То есть, если уже известный вам Broadcast означает вещание всем, мультикаст означает вещание определённой группе.

Второе применение — это, например, репликация операционной системы на множество компьютеров разом. Это подразумевает загрузку больших объёмов данных с одного сервера.

Возможные сценарии: аудио и видеоконференции \(один говорит — все слушают\), электронная коммерция, аукционы, биржи. Но это в теории, а на практике редко тут всё-таки используется мультикаст.

Ещё одно применение — это служебные сообщения протоколов. Например, OSPF в своём широковещательном домене рассылает свои сообщения на адреса 224.0.0.5 и 224.0.0.6. И обрабатывать их будут только те узлы, на которых запущен OSPF.

Сформулируем два основных принципа мультикастовой рассылки:

1. Отправитель посылает только одну копию трафика, независимо от количества получателей.
2. Трафик получают только те, кто действительно заинтересован в нём.

В данной статье для практики мы возьмём IPTV, как наиболее наглядный пример.

### Пример I

Начнём с самого простого случая:

![](http://img-fotki.yandex.ru/get/9812/83739833.37/0_da2e8_e826bc36_XL.png)

На сервере-источнике настроено вещание в группу 224.2.2.4 — это означает, что сервер отправляет трафик на IP-адрес 224.2.2.4. На клиенте видеоплеер настроен принимать поток группы 224.2.2.4.  
При этом, заметьте, клиент и сервер не обязательно должны иметь адреса из одной подсети и пинговать друг друга — достаточно, чтобы они были в одном широковещательном домене.  
Мультикастовый поток просто льётся с сервера, а клиент его просто принимает. Вы можете попробовать это прямо у себя на рабочем месте, соединив патчкордом два компьютера и запустив, например, VLC.

Надо заметить, что в мультикасте нет никакой сигнализации от источника, мол, _«Здрасьте, я Источник, не надо немного мультикаста?»_.  
Сервер-источник просто начинает вещать в свой интерфейс мультикастовые пакеты. В нашем примере они напрямую попадают клиенту и тот, собственно, сразу же их и принимает.  
Если на этом линке отловить пакеты, то вы увидите, что мультикастовый трафик — это ни что иное, как море UDP-пакетов.

![&#x43C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442; &#x434;&#x430;&#x43C;&#x43F;](http://img-fotki.yandex.ru/get/6729/83739833.37/0_da2e9_d455737_XXL.png)

Мультикаст не привязан к какому-то конкретному протоколу. По сути, всё, что его определяет — адреса. Однако, если говорить о его применении, то в абсолютном большинстве случаев используется именно UDP. Это легко объясняется тем, что обычно с помощью многоадресной рассылки передаются данные, которые нужны здесь и сейчас. Например, видео. Если кусочек кадра потеряется, и отправитель будет пытаться его послать повторно, как это происходит в TCP, то, скорее всего, этот кусочек опоздает, и где его тогда показывать? Поезд ушёл. Ровно то же самое со звуком.  
Соответственно не нужно и устанавливать соединение, поэтому TCP здесь ни к чему.

Чем же так разительно отличается мультикаст от юникаста? Думаю, у вас есть уже предположение. И вы, наверняка, правы.

В обычной ситуации у нас 1 получатель и 1 отправитель — у каждого из них один уникальный IP-адрес. Отправитель точно знает, куда надо слать пакет и ставит этот адрес в заголовок IP. Каждый промежуточный узел благодаря своей таблице маршрутизации точно знает, куда переслать пакет. Юникастовый трафик между двумя узлами беспрепятственно проходит сквозь сеть. Но проблема в том, что в обычном пакете указывается только один IP-адрес получателя.  
Что делать, если у одного и того же трафика несколько получателей? В принципе можно расширить одноадресный подход и на такую ситуацию — отправлять каждому клиенту свой экземпляр пакета. Клиенты не заметят разницы — хоть он один, хоть их тысяча, но разница будет отчётливо различима на ваших каналах передачи данных.  
![Unicast Multicast relation graph &#x413;&#x440;&#x430;&#x444;&#x438;&#x43A; &#x441;&#x43E;&#x43E;&#x442;&#x43D;&#x43E;&#x448;&#x435;&#x43D;&#x438;&#x44F; &#x44E;&#x43D;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x43E;&#x432;&#x43E;&#x433;&#x43E; &#x438; &#x43C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x43E;&#x432;&#x43E;&#x433;&#x43E; &#x442;&#x440;&#x430;&#x444;&#x438;&#x43A;&#x430;](http://img-fotki.yandex.ru/get/9170/83739833.39/0_de153_5b40d1c4_XL.png)  
Предположим у нас идёт передача одного SD-канала с мультикаст-сервера. Пусть, он использует 2 Мб/с. Всего таких каналов 30, а смотрит каждый канал по 20 человек одновременно. Итого получается 2 Мб/с  _30 каналов_  20 человек = 1200 Мб/с или 1,2 Гб/с только на телевидение в случае одноадресной рассылки. А есть ведь ещё HD каналы, где можно смело умножать эту цифру на 2. И где тут место для торрентов?

Вот почему в IPv4 был заложен блок адресов **класса D: 224.0.0.0/4** \(224.0.0.0-239.255.255.255\). Адреса этого диапазона определяют мультикастовую группу. Один адрес — это одна группа, обычно она обозначается буквой «**G**».  
То есть, говоря, что клиент подключен к группе 224.2.2.4, мы имеем ввиду, что он получает мультикастовый трафик с адресом назначения 224.2.2.4.

### Пример II

Добавим в схему коммутатор и ещё несколько клиентов:

![](http://img-fotki.yandex.ru/get/9753/83739833.37/0_da2ec_4d18ca94_XXL.png)

Мультикастовый сервер по-прежнему вещает для группы 224.2.2.4. На коммутаторе все 4 порта должны быть в одном VLAN. Трафик приходит на коммутатор и по умолчанию рассылается во все порты одного VLAN'а. Значит все клиенты получают этот трафик. На них на всех в видеопроигрывателе так же указан групповой адрес 224.2.2.4.  
Собственно, все эти устройства становятся членами данной мультикастовой группы. Членство в ней динамическое: кто угодно, в любой момент может войти и выйти из неё.

> В данной ситуаци трафик будут получать даже те, кто этого в общем-то и не хотел, то есть на нём не запущен ни плеер, ни что бы то ни было другое. Но только, если он в том же VLAN'е. [Позже](9.-multicast.md#IGMP_Snooping) мы разберёмся, как с этим бороться.

Обратите внимание, что в данном случае от сервера-источника приходит только одна копия трафика на коммутатор, а не по отдельной копии на каждого клиента. И в нашем примере с SD каналами загрузка порта между источником и коммутатором будет не 1,2 Гб/с, а всего 60 Мб/с \(2Мб/с \* 30 каналов\).

Собственно говоря, весь этот огромный диапазон \(224.0.0.0-239.255.255.255\) можно использовать.  
Ну, почти весь — первые адреса \(диапазон 224.0.0.0/23\) всё-таки зарезервированы под известные протоколы.

| **Адрес**  | **Значение**  |
| :--- | :--- |
| 224.0.0.0 | Не используется |
| 224.0.0.1 | Все узлы данного сегмента |
| 224.0.0.2 | Все мультикастовые узлы данного сегмента |
| 224.0.0.4 | Данный адрес выделялся для покойного протокола DVMRP |
| 224.0.0.5 | Все OSPF-маршрутизаторы сегмента |
| 224.0.0.6 | Все DR маршрутизаторы сегмента |
| 224.0.0.9 | Все RIPv2-маршрутизаторы сегмента |
| 224.0.0.10 | Все EIGRP-маршрутизаторы сегмента |
| 224.0.0.13 | Все PIM-маршрутизаторы сегмента |
| 224.0.0.18 | Все VRRP-маршрутизаторы сегмента |
| 224.0.0.19-21 | Все IS-IS-маршрутизаторы сегмента |
| 224.0.0.22 | Все IGMP-маршрутизаторы сегмента \(v2 и v3\) |
| 224.0.0.102 | Все HSRPv2/GLBP-маршрутизаторы сегмента |
| 224.0.0.107 | PTPv2 — Precision Time Protocol |
| 224.0.0.251 | mDNS |
| 224.0.0.252 | LLMNR |
| 224.0.0.253 | Teredo |
| 224.0.1.1 | NTP |
| 224.0.1.39 | Cisco Auto-RP-Announce |
| 224.0.1.40 | Cisco Auto-RP-Discovery |
| 224.0.1.41 | H.323 Gatekeeper |
| 224.0.1.129-132 | PTPv1/PTPv2 |
| 239.255.255.250 | SSDP |

Диапазон 224.0.0.0/24 зарезервирован под [link-local](http://lookmeup.linkmeup.ru/#term42) коммуникации. Мультикастовые пакеты с такими адресами назначения не могут выходить за пределы одного широковещательного сегмента.  
Диапазон 224.0.1.0/24 зарезервирован под протоколы, которым необходимо передавать мультикаст по всей сети, то есть проходить через маршрутизаторы.

Вот, собственно, самые базисные вещи касательно мультикаста.  
Мы рассмотрели простую ситуацию, когда источник и получатель находятся в одном сегменте сети. Трафик, полученный коммутатором, просто рассылается им во все порты — никакой магии.

Но пока совсем непонятно, как трафик от сервера достигает клиентов, когда между ними огромная провайдерская сеть линкмиап? Да и откуда, собственно, будет известно, кто клиент? Мы же не можем вручную прописать маршруты, просто потому что не знаем, где могут оказаться клиенты. Не ответят на этот вопрос и обычные протоколы маршрутизации. Так мы приходим к пониманию, что доставка мультикаст — это нечто совершенно новое для нас.

Вообще, чтобы доставить мультикаст от источника до получателя на данный момент существует много протоколов — IGMP/MLD, PIM, MSDP, MBGP, MOSPF, DVMRP.  
Мы остановимся на двух из них, которые используются в настоящее время: PIM и IGMP.  
С помощью IGMP конечные получатели-клиенты сообщают ближайшим маршрутизаторам о том, что хотят получать трафик. А PIM строит путь движения мультикастового трафика от источника до получателей через маршрутизаторы.

![PIM+IGMP](http://img-fotki.yandex.ru/get/6710/83739833.37/0_da2ed_7bb60de6_XXL.png)

## IGMP

Снова вернёмся к дампу. Видите вот этот верхний пакет, после которого полился мультикастовый поток?

![IGMP Dump](http://img-fotki.yandex.ru/get/9806/83739833.37/0_da2eb_e8ae8cb9_XXL.png)

Это сообщение протокола IGMP, которое отправил клиент, когда мы на нём нажали Play. Именно так он сообщает о том, что хочет получать трафик для группы 224.2.2.4.  
**IGMP — Internet Group Management Protocol** — это сетевой протокол взаимодействия клиентов мультикастового трафика и ближайшего к ним маршрутизатора.

> В IPv6 используется [MLD](http://lookmeup.linkmeup.ru/#term286) \(Multicast Listener Discovery\) вместо IGMP. Принцип работы у них абсолютно одинаковый, поэтому далее везде вы смело можете менять IGMP на MLD, а IP на IPv6.

Как же именно работает IGMP?  
Пожалуй, начать нужно с того, что версий у протокола сейчас три: IGMPv1, IGMPv2, IGMPv3. Наиболее используемая — вторая, первая уже практически забыта, поэтому про неё говорить не будем, третья очень похожа на вторую.

Акцентируемся пока на второй, как на самой показательной, и рассмотрим все события от подключения клиента к группе до его выхода из неё.  
Клиент будет также запрашивать группу 224.2.2.4 через проигрыватель VLC.

Роль IGMP очень проста: если клиентов нет — передавать мультикастовый трафик в сегмент не надо. Если появился клиент, он уведомляет маршрутизаторы с помощью IGMP о том, что хочет получать трафик.

Для того, чтобы понять, как всё происходит, возьмём такую сеть:

![Multicast](http://img-fotki.yandex.ru/get/9753/83739833.37/0_da2ef_f0bc8d45_XL.png)

Предположим, что маршрутизатор уже настроен на получение и обработку мультикастового трафика.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)  
**1.** Как только мы запустили приложение на клиенте и задали группу 224.2.2.4, в сеть будет отправлен пакет **IGMP Membership Report** — узел «рапортует» о том, что хочет получать трафик этой группы.

![IGMP Report](http://img-fotki.yandex.ru/get/6729/83739833.37/0_da2f0_e4ee7c67_XXXL.png)

В IGMPv2 Report отправляется на адрес желаемой группы, и параллельно он же указывается в самом пакете. Данные сообщения должны жить только в пределах своего сегмента и не пересылаться никуда маршрутизаторами, поэтому и TTL у них 1.

> Часто в литературе вы можете встретить упоминание о **IGMP Join**. Не пугайтесь — это альтернативное название для IGMP Membership Report.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)  
**2.** Маршрутизатор получает IGMP-Report и, понимая, что за данным интерфейсом теперь есть клиенты, заносит информацию в свои таблицы

![show ip igmp group](http://img-fotki.yandex.ru/get/9763/83739833.37/0_da2f1_e0f2b4_XL.png)

Это вывод информации по IGMP. Первая группа запрошена клиентом. Третья и четвёртая — это служебные группы протокола [SSDP](http://lookmeup.linkmeup.ru/#term158), встроенного в Windows. Вторая — специальная группа, которая всегда присутствует на маршрутизаторах Cisco — она используется для протокола [Auto-RP](http://lookmeup.linkmeup.ru/#term306), который по умолчанию активирован на маршрутизаторах.  
Интерфейс FE0/0 становится нисходящим для трафика группы 224.2.2.4 — в него нужно будет отправлять полученный трафик.

Наряду с обычной юникастовой таблицей маршрутизации существует ещё и мультикастовая:

![show ip mroute](http://img-fotki.yandex.ru/get/9932/83739833.37/0_da2f2_7a90f656_XL.png)

О наличии клиентов говорит первая запись **\(\*, 224.2.2.4\)**. А запись **\(172.16.0.5, 224.2.2.4\)** означает, что маршрутизатор знает об источнике мультикастового потока для этой группы.  
Из вывода видно, что трафик для группы 224.2.2.4 приходит через FE0/1, а передавать его надо на порт FE0/0.  
Интерфейсы, в которые нужно передавать трафик, входят в список нисходящих интерфейсов — **OIL — Outbound Interface List**.  
Более подробно вывод команды **show ip mroute** мы разберём позже.

Выше на дампе вы видите, что как только клиент отправил IGMP-Report, сразу после него полетели UDP — это видеопоток.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)  
**3.** Клиент начал получать трафик. Теперь маршрутизатор должен иногда проверять, что получатели до сих пор у него есть, чтобы зазря не вещать, если вдруг клиентов не осталось. Для этого он периодически отправляет во все свои нисходящие интерфейсы запрос **IGMP Query**.  
_Дамп отфильтрован по IGMP_.  
![IGMP General Query](http://img-fotki.yandex.ru/get/9169/83739833.37/0_da2f3_1f65170e_XXL.png)

По умолчанию это происходит каждые 60 секунд. TTL таких пакетов тоже равен 1. Они отправляются на адрес 224.0.0.1 — все узлы в этом сегменте — без указания конкретной группы. Такие сообщений Query называются **General Query** — общие. Таким образом маршрутизатор спрашивает: «Ребят, а кто и что ещё хочет получать?».

Получив IGMP General Query, любой хост, который слушает любую группу, должен отправить IGMP Report, как он это делал при подключении. В Report, естественно, должен быть указан адрес интересующей его группы.  
_Дамп отфильтрован по IGMP_.  
![IGMP Membership report](http://img-fotki.yandex.ru/get/9491/83739833.37/0_da2f4_7d385a82_XXL.png)

Если в ответ на Query на маршрутизатор пришёл хотя бы один Report для группы, значит есть ещё клиенты, он продолжает вещать в тот интерфейс, откуда пришёл этот Report, трафик этой самой группы.  
Если на 3 подряд Query не было с интерфейса ответа для какой-то группы, маршрутизатор удаляет этот интерфейс из своей таблицы мультикастовой маршрутизации для данной группы — перестаёт туда посылать трафик.

По своей инициативе клиент обычно посылает Report только при подключении, потом — просто отвечает на Query от маршрутизатора.

> Интересная деталь в поведении клиента: получив Query, он не торопится сразу же ответить Report'ом. Узел берёт тайм-аут длиной от 0 до **Max Response Time**, который указан в пришедшем Query:  
>   
> ![Max Response Time](http://img-fotki.yandex.ru/get/9497/83739833.37/0_da2f5_348d9ad8_XXL.png)  
>   
> При отладке или в дампе, кстати, можно видеть, что между получением различных Report может пройти несколько секунд.  
> Сделано это для того, чтобы сотни клиентов все скопом не наводнили сеть своими пакетам Report, получив General Query. Более того, только один клиент обычно отправляет Report.  
> Дело в том, что Report отсылается на адрес группы, а следовательно доходит и до всех клиентов. Получив Report от другого клиента для этой же группы, узел не будет отправлять свой. Логика простая: маршрутизатор и так уже получил этот самый Report и знает, что клиенты есть, больше ему не надо.  
> Этот механизм называется **Report Suppression**.  
>   
> **Далее в статье мы расскажем о том, почему этот механизм на деле очень редко реально работает**.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)  
**4.** Так продолжается веками, пока клиент не захочет выйти из группы \(например, выключит плеер/телевизор\). В этом случае он отправляет **IGMP Leave** на адрес группы.

![IGMP Leave](http://img-fotki.yandex.ru/get/6710/83739833.37/0_da2f6_4cec4c3a_XXXL.png)

Маршрутизатор получает его и по идее должен отключить. Но он ведь не может отключить одного конкретного клиента — маршрутизатор их не различает — у него просто есть нисходящий интерфейс. А за интерфейсом может быть несколько клиентов. То есть, если маршрутизатор удалит этот интерфейс из своего списка OIL \(Outgoing Interface List\) для этой группы, видео выключится у всех.  
Но и не удалять его совсем тоже нельзя — вдруг это был последний клиент — зачем тогда впустую вещать?

Если вы посмотрите в дамп, то увидите, что после получения Leave маршрутизатор ещё некоторое время продолжает слать поток. Дело в том, что маршрутизатор в ответ на Leave высылает IGMP Query на адрес группы, для которой этот Leave пришёл в тот интерфейс, откуда он пришёл. Такой пакет называется **Group Specific Query**. На него отвечают **только** те клиенты, которые подключены к данной конкретной группе.

![IGMP Group Specific Query](http://img-fotki.yandex.ru/get/9169/83739833.37/0_da2f7_eb322104_XXXL.png)

Если маршрутизатор получил ответный Report для группы, он продолжает вещать в интерфейс, если не получил — удаляет по истечении таймера.

Всего после получения Leave отправляется два Group Specific Query — один обязательный, второй контрольный.

_Дамп отфильтрован по IGMP_.  
![&#x43E;&#x442;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435; &#x43C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x43E;&#x432;&#x43E;&#x433;&#x43E; &#x43A;&#x43B;&#x438;&#x435;&#x43D;&#x442;&#x430;](http://img-fotki.yandex.ru/get/9806/83739833.37/0_da2f8_5c37f4c9_XXL.png)

Далее маршрутизатор останавливает поток.

#### Querier

Рассмотрим чуть более сложный случай:

![IGMP Querier](http://img-fotki.yandex.ru/get/9813/83739833.38/0_da358_a61224c0_XL.png)

В клиентский сегмент подключено два \(или больше\) маршрутизатора, которые могут вещать трафик. Если ничего не сделать, мультикастовый трафик будет дублироваться — оба маршрутизатора ведь будут получать Report от клиентов. Во избежание этого существует механизм выбора **Querier** — опрашивателя. Тот кто победит, будет посылать Query, мониторить Report и реагировать на Leave, ну и, соответственно, он будет отправлять и трафик в сегмент. Проигравший же будет только слушать Report и держать руку на пульсе.

Выборы происходят довольно просто и интуитивно понятно.  
Рассмотрим ситуацию с момента включения маршрутизаторов R1 и R2.  
**1\)** Активировали IGMP на интерфейсах.  
**2\)** Сначала по умолчанию каждый из них считает себя Querier.  
**3\)** Каждый отправляет IGMP General Query в сеть. Главная цель — узнать, есть ли клиенты, а параллельно — заявить другим маршрутизаторам в сегменте, если они есть, о своём желании участвовать в выборах.  
**4\)** General Query получают все устройства в сегменте, в том числе и другие IGMP-маршрутизаторы.  
**5\)** Получив такое сообщение от соседа, каждый маршрутизатор оценивает, кто достойнее.  
**6\)** Побеждает маршрутизатор с **меньшим IP** \(указан в поле Source IP пакета IGMP Query\). Он становится Querier, все другие — Non-Querier.  
**7\)** Non-Querier запускает таймер, который обнуляется каждый раз, как приходит Query с меньшим IP-адресом. Если до истечения таймера \(больше 100 секунд: 105-107\) маршрутизатор не получит Query с меньшим адресом, он объявляет себя Querier и берёт на себя все соответствующие функции.  
**8\)** Если Querier получает Query с меньшим адресом, он складывает с себя эти обязанности. Querier'ом становится другой маршрутизатор, у которого IP меньше.

_Тот редкий случай, когда меряются, у кого меньше._

Выборы Querier очень важная процедура в мультикасте, но некоторые коварные производители, не придерживающиеся RFC, могут вставить крепкую палку в колёса. Я сейчас говорю о IGMP Query с адресом источника 0.0.0.0, которые могут генерироваться коммутатором. Такие сообщения не должны участвовать в выборе Querier, но надо быть готовыми ко всему. [Вот пример](http://nag.ru/articles/article/25136/takie-raznyie-problemyi.html) весьма сложной долгоиграющей проблемы.

#### Ещё пара слов о других версиях IGMP

Версия 1 отличается по сути только тем, что **в ней нет сообщения Leave**. Если клиент не хочет больше получать трафик данной группы, он просто перестаёт посылать Report в ответ на Query. Когда не останется ни одного клиента, маршрутизатор по таймауту перестанет слать трафик.  
Кроме того, **не поддерживаются выборы Querier**. За избежание дублирования трафика отвечает вышестоящий протокол, например, PIM, о котором мы будем говорить [далее](9.-multicast.md#PIM).

Версия 3 поддерживает всё то, что поддерживает IGMPv2, но есть и ряд изменений. Во-первых, Report отправляется уже не на адрес группы, а на мультикастовый служебный адрес **224.0.0.22**. А адрес запрашиваемой группы указан только внутри пакета. Делается это для упрощения работы IGMP Snooping, о котором мы поговорим [дальше](9.-multicast.md#IGMP_Snooping).

Во-вторых, что более важно, IGMPv3 стал поддерживать SSM в чистом виде. Это так называемый [**Source Specific Multicast**](http://lookmeup.linkmeup.ru/#term284). В этом случае клиент может не просто запросить группу, но также указать список источников, от которых он хотел бы получать трафик или наоборот не хотел бы. В IGMPv2 клиент просто запрашивает и получает трафик группы, не заботясь об источнике.

![IGMPv3](http://img-fotki.yandex.ru/get/9806/83739833.39/0_db5cd_7173c5bc_XXXL.png)

Итак, IGMP предназначен для взаимодействия клиентов и маршрутизатора. Поэтому, возвращаясь к _Примеру II_, где нет маршрутизатора, мы можем авторитетно заявить — IGMP там — не более, чем формальность. Маршрутизатора нет, и клиенту не у кого запрашивать мультикастовый поток. А заработает видео по той простой причине, что поток и так льётся от коммутатора — надо только подхватить его.

Напомним, что IGMP не работает для IPv6. Там существует протокол [MLD](http://lookmeup.linkmeup.ru/#term286).

#### Повторим ещё раз

_Дамп отфильтрован по IGMP_.  
![IGMP Capture](http://img-fotki.yandex.ru/get/9812/83739833.37/0_da2f9_96978a5e_XXL.png)  
**1.** Первым делом маршрутизатор отправил свой IGMP General Query после включения IGMP на его интерфейсе, чтобы узнать, есть ли получатели и заявить о своём желании быть Querier. На тот момент никого не было в этой группе.  
**2.** Далее появился клиент, который захотел получать трафик группы 224.2.2.4 и он отправил свой IGMP Report. _После этого пошёл трафик на него, но он отфильтрован из дампа._  
**3.** Потом маршрутизатор решил зачем-то проверить — а нет ли ещё клиентов и отправил IGMP General Query ещё раз, на который клиент вынужден ответить \(**4**\).  
**5.** Периодически \(раз в минуту\) маршрутизатор проверяет, что получатели по-прежнему есть, с помощью IGMP General Query, а узел подтверждает это с помощью IGMP Report.  
**6.** Потом он передумал и отказался от группы, отправив IGMP Leave.  
**7.** Маршрутизатор получил Leave и, желая убедиться, что больше никаких других получателей нет, посылает IGMP Group Specific Query… дважды. И по истечении таймера перестаёт передавать трафик сюда.  
**8.** Однако передавать IGMP Query в сеть он по-прежнему продолжает. Например, на тот случай, если вы плеер не отключали, а просто где-то со связью проблемы. Потом связь восстанавливается, но клиент-то Report не посылает сам по себе. А вот на Query отвечает. Таким образом поток может восстановиться без участия человека.

#### И ещё раз

**IGMP** — протокол, с помощью которого маршрутизатор узнаёт о наличии получателей мультикастового трафика и об их отключении.  
**IGMP Report** — посылается клиентом при подключении и в ответ на IGMP Query. Означает, что клиент хочет получать трафик конкретной группы.  
**IGMP General Query** — посылается маршрутизатором периодически, чтобы проверить какие группы сейчас нужны. В качестве адреса получателя указывается 224.0.0.1.  
**IGMP Group Sepcific Query** — посылается маршрутизатором в ответ на сообщение Leave, чтобы узнать есть ли другие получатели в этой группе. В качестве адреса получателя указывается адрес мультикастовой группы.  
**IGMP Leave** — посылается клиентом, когда тот хочет покинуть группу.  
**Querier** — если в одном широковещательном сегменте несколько маршрутизаторов, который могут вещать, среди них выбирается один главный — Querier. Он и будет периодически рассылать Query и передавать трафик.

Подробное описание всех терминов [IGMP](http://lookmeup.linkmeup.ru/#term264).

## PIM

Итак, мы разобрались, как клиенты сообщают ближайшему маршрутизатору о своих намерениях. Теперь неплохо было бы передать трафик от источника получателю через большую сеть.

Если вдуматься, то мы стоим перед довольной сложной проблемой — источник только вещает на группу, он ничего не знает о том, где находятся получатели и сколько их.  
Получатели и ближайшие к ним маршрутизаторы знают только, что им нужен трафик конкретной группы, но понятия не имеют, где находится источник и какой у него адрес.  
Как в такой ситуации доставить трафик?

Существует несколько протоколов маршрутизации мультикастового трафика: [DVMRP](http://lookmeup.linkmeup.ru/#term371), [MOSPF](http://lookmeup.linkmeup.ru/#term241), [CBT](http://lookmeup.linkmeup.ru/#term370) — все они по-разному решают такую задачу. Но стандартом де факто стал **PIM — Protocol Independent Multicast**.  
Другие подходы настолько нежизнеспособны, что порой даже их разработчики практически признают это. Вот, например, выдержка из RFC по протоколу CBT:  
_CBT version 2 is not, and was not, intended to be backwards compatible with version 1; we do not expect this to cause extensive compatibility problems because we do not believe CBT is at all widely deployed at this stage._

PIM имеет две версии, которые можно даже назвать двумя различными протоколами в принципе, уж сильно они разные:

* PIM Dense Mode \(DM\)
* PIM Sparse Mode \(SM\)

Independent он потому, что не привязан к какому-то конкретному протоколу маршрутизации юникастового трафика, и позже вы увидите почему.

### PIM Dense Mode

**PIM DM** пытается решить проблему доставки мультиакста в лоб. Он заведомо предполагает, что получатели есть везде, во всех уголках сети. Поэтому изначально он наводняет всю сеть мультикастовым трафиком, то есть рассылает его во все порты, кроме того, откуда он пришёл. Если потом оказывается, что где-то он не нужен, то эта ветка «отрезается» с помощью специального сообщения PIM Prune — трафик туда больше не отправляется.

Но через некоторое время в эту же ветку маршрутизатор снова пытается отправить мультикаст — вдруг там появились получатели. Если не появились, ветка снова отрезается на определённый период. Если клиент на маршрутизаторе появился в промежутке между этими двумя событиями, отправляется сообщение Graft — маршрутизатор запрашивает отрезанную ветку обратно, чтобы не ждать, пока ему что-то перепадёт.  
Как видите, здесь не стоит вопрос определения пути к получателям — трафик достигнет их просто потому, что он везде.  
После «обрезания» ненужных ветвей остаётся дерево, вдоль которого передаётся мультикастовый трафик. Это дерево называется **SPT — Shortest Path Tree**.

Оно лишено петель и использует кратчайший путь от получателя до источника. По сути оно очень похоже на Spanning Tree в [STP](https://linkmeup.ru/blog/15.html), где корнем является источник.  
SPT — это конкретный вид дерева — дерево кратчайшего пути. А вообще любое мультикастовое дерево называется **MDT — Multicast Distribution Tree**.

Предполагается, что PIM DM должен использоваться в сетях с высокой плотностью мультикастовых клиентов, что и объясняет его название \(Dense\). Но реальность такова, что эта ситуация — скорее, исключение, и зачастую PIM DM нецелесообразен.

Что нам действительно важно сейчас — это механизм избежания петель.  
Представим такую сеть:

![RPF](http://img-fotki.yandex.ru/get/9323/83739833.37/0_da2fb_45dcf1f2_L.png)

Один источник, один получатель и простейшая IP-сеть между ними. На всех маршрутизаторах запущен PIM DM.

Что произошло бы, если бы не было специального механизма избежания петель?  
Источник отправляет мультикастовый трафик. R1 его получает и в соответствии с принципами PIM DM отправляет во все интерфейсы, кроме того, откуда он пришёл — то есть на R2 и R3.

R2 поступает точно так же, то есть отправляет трафик в сторону R3. R3 не может определить, что это тот же самый трафик, который он уже получил от R1, поэтому пересылает его во все свои интерфейсы. R1 получит копию трафика от R3 и так далее. Вот она — петля.

Что же предлагает PIM в такой ситуации? **RPF — Reverse Path Forwarding**. Это главный принцип передачи мультикастового трафика в PIM \(любого вида: и DM и SM\) — трафик от источника должен приходить по кратчайшему пути.  
То есть для каждого полученного мультикастового пакета производится проверка на основе таблицы маршрутизации, оттуда ли он пришёл.

1\) Маршрутизатор смотрит на адрес источника мультикастового пакета.  
2\) Проверяет таблицу маршрутизации, через какой интерфейс доступен адрес источника.  
3\) Проверяет интерфейс, через который пришёл мультикастовый пакет.  
4\) Если интерфейсы совпадают — всё отлично, мультикастовый пакет пропускается, если же данные приходят с другого интерфейса — они будут отброшены.  
В нашем примере R3 знает, что кратчайший путь до источника лежит через R1 \(статический или динамический маршрут\). Поэтому мультикастовые пакеты, пришедшие от R1, проходят проверку и принимаются R3, а те, что пришли от R2, отбрасываются.

![RPF Check](http://img-fotki.yandex.ru/get/5013/83739833.37/0_da2fc_84c6ecc5_L.png)

Такая проверка называется **RPF-Check** и благодаря ей даже в более сложных сетях петли в MDT не возникнут.  
Этот механизм важен нам, потому что он актуален и в PIM-SM и работает там точно также.  
Как видите, PIM опирается на таблицу юникастовой маршрутизации, но, во-первых, сам не маршрутизирует трафик, во-вторых, ему не важно, кто и как наполнял таблицу.

Останавливаться здесь и подробно рассматривать работу PIM DM мы не будем — это устаревший протокол с массой недостатков \(ну, как [RIP](http://lookmeup.linkmeup.ru/#term242)\).

Однако PIM DM может применяться в некоторых случаях. Например, в совсем небольших сетях, где поток мультикаста небольшой.

![PIM DM](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/e3d/59c/7b1/e3d59c7b18ca4b1c8e81c0571271bd68.gif)

### PIM Sparse Mode

Совершенно другой подход применяет **PIM SM**. Несмотря на название \(разреженный режим\), он с успехом может применяться в любой сети с эффективностью как минимум не хуже, чем у PIM DM.  
Здесь отказались от идеи безусловного наводнения мультикастом сети. Заинтересованные узлы самостоятельно запрашивают подключение к дереву с помощью сообщений **PIM Join**.  
Если маршрутизатор не посылал Join, то и трафик ему отправляться не будет.

Для того, чтобы понять, как работает PIM, начнём с уже знакомой нам простой сети с одним PIM-маршрутизатором:  
![](http://img-fotki.yandex.ru/get/9763/83739833.38/0_da359_c396dba4_XL.png)  
Из настроек на R1 надо включить возможность маршрутизации мультикаста, PIM SM на двух интерфейсах \(в сторону источника и в сторону клиента\) и IGMP в сторону клиента. _Помимо прочих базовых настроек, конечно \(IP, IGP\)._

С этого момента вы можете расчехлить GNS и собирать лабораторию. Достаточно подробно о том, как собрать стенд для мультикаста я рассказал в этой [статье](https://linkmeup.ru/blog/126.html).

```text
R1(config)#ip multicast-routing
R1(config)#int fa0/0
R1(config-if)#ip pim sparse-mode
R1(config-if)#int fa1/0
R1(config-if)#ip pim sparse-mode
```

> Cisco тут как обычно отличается своим особенным подходом: при активации PIM на интерфейсе, автоматически активируется и IGMP. На всех интерфейсах, где активирован PIM, работает и IGMP.  
> В то же время у других производителей два разных протокола включаются двумя разными командами: отдельно IGMP, отдельно PIM.  
> Простим Cisco эту странность? Вместе со всеми остальными?  
>   
> Плюс, возможно, потребуется настроить адрес RP \(**ip pim rp-address 172.16.0.1**, например\). Об этом позже, пока примите как данность и смиритесь.

Проверим текущее состояние таблицы мультикастовой маршрутизации для группы 224.2.2.4:

![show ip mroute](http://img-fotki.yandex.ru/get/9169/83739833.37/0_da308_1a7f06fb_L.png)

После того, как на источнике вы запустите вещание, надо проверить таблицу ещё раз.

![\(\*, G\) \(S, G\)](http://img-fotki.yandex.ru/get/9932/83739833.37/0_da304_f1641eea_XXL.png)

Давайте разберём этот немногословный вывод.

Запись вида **\(\*, 225.0.1.1\)** называется **\(\*, G\)**, /читается _старкомаджи_/ и сообщает нам о получателях. Причём не обязательно речь об одном клиенте-компьютере, вообще это может быть и, например, другой PIM-маршрутизатор. Важно то, в какие интерфейсы надо передавать трафик.  
Если список нисходящих интерфейсов \(OIL\) пуст — **Null**, значит нет получателей — а мы их пока не запускали.

Запись **\(172.16.0.5, 225.0.1.1\)** называется **\(S, G\)**, /читается _эскомаджи_/ и говорит о том, что известен источник. В нашем случае источник с адресом 172.16.0.5 вещает трафик для группы 224.2.2.4. Мультикастовый трафик приходит на интерфейс FE0/1 — это **восходящий** \(**Upstream**\) интерфейс.

Итак, нет клиентов. Трафик от источника доходит до маршрутизатора и на этом его жизнь кончается. Давайте добавим теперь получателя — настроим приём мультикаста на ПК.  
ПК отсылает IGMP Report, маршрутизатор понимает, что появились клиенты и обновляет таблицу мультикастовой маршрутизации.  
Теперь она выглядит так:

![OIL Multicast](http://img-fotki.yandex.ru/get/9323/83739833.37/0_da305_a28aa520_XL.png)

Появился и нисходящий интерфейс: FE0/0, что вполне ожидаемо. Причём он появился как в \(_, G\), так и в \(S, G\). Список нисходящих интерфейсов называется \*OIL — Outgoing Interface List_.

Добавим ещё одного клиента на интерфейс FE1/0:

![OIL Multicast](http://img-fotki.yandex.ru/get/9820/83739833.37/0_da307_e8818032_XL.png)

Если читать вывод дословно, то имеем:  
\(_, G\): Есть получатели мультикастового трафика для группы 224.2.2.4 за интерфейсами FE0/0, FE1/0. Причём совершенно неважно, кто отправитель, о чём и говорит знак «_».

\(S, G\): Когда мультикастовый трафик с адресом назначения 224.2.2.4 от источника 172.16.0.5 приходит на интерфейс FE0/1, его копии нужно отправить в FE0/0 и FE1/0.

Но это был очень простой пример — один маршрутизатор сразу знает и адрес источника и где находятся получатели. Фактически даже деревьев тут никаких нет — разве что вырожденное. Но это помогло нам разобраться с тем, как взаимодействуют PIM и IGMP.

#### Чтобы разобраться с тем, что такое PIM, обратимся к сети гораздо более сложной

![PIM SM RP](http://img-fotki.yandex.ru/get/9820/83739833.37/0_da30b_7fe598c3_XXL.png)

Предположим, что уже настроены все IP-адреса в соответствии со схемой. На сети запущен IGP для обычной юникастовой маршрутизации.  
_Клиент1_, например, может пинговать Сервер-источник.

![](http://img-fotki.yandex.ru/get/6729/83739833.37/0_da30c_f76d7a97_XL.png)

Но пока не запущен PIM, IGMP, клиенты не запрашивают каналы.

[Файл начальной конфигурации](https://docs.google.com/document/d/1rtrifoyP4mwjnbVug8zW-nL0g5qm1405IaWpbasusog/pub).

Итак, момент времени 0.

Включаем мультикастовую маршрутизацию на всех пяти маршрутизаторах:

```text
RX(config)#ip multicast-routing
```

PIM включается непосредственно на всех интерфейсах всех маршрутизаторов \(в том числе на интерфейсе в сторону Сервера-источника и клиентов\):

```text
RX(config)#int FEX/X
RX(config-if)#ip pim sparse-mode
```

> IGMP, по идее должен включаться на интерфейсах в сторону клиентов, но, как мы уже отметили выше, на оборудовании Cisco он включается автоматически вместе с PIM.

Первое, что делает PIM — устанавливает соседство. Для этого используются сообщения **PIM Hello**. При активации PIM на интерфейсе с него отправляется PIM Hello на адрес **224.0.0.13** с TTL равным 1. Это означает, что соседями могут быть только маршрутизаторы, находящиеся в одном широковещательном домене.

![PIM Hello](http://img-fotki.yandex.ru/get/6727/83739833.37/0_da30a_5acf69cf_XXL.png)

Как только соседи получили приветствия друг от друга:

![show ip pim neighbor](http://img-fotki.yandex.ru/get/9740/83739833.37/0_da30d_479d34e1_XL.png)

Теперь они готовы принимать заявки на мультикастовые группы.

Если мы сейчас запустим в вольер клиентов с одной стороны и включим мультикастовый поток с сервера с другой, то R1 получит поток трафика, а R4 получит IGMP Report при попытке клиента подключиться. В итоге R1 не будет знать ничего о получателях, а R4 об источнике.

![show ip mroute](http://img-fotki.yandex.ru/get/9740/83739833.37/0_da30e_90dc2ddd_XL.png)

![show ip mroute](http://img-fotki.yandex.ru/get/9812/83739833.37/0_da30f_1c687d52_XL.png)

Неплохо было бы если бы информация об источнике и о клиентах группы была собрана где-то в одном месте. Но в каком?

Такая точка встречи называется **Rendezvous Point — RP**. Это центральное понятие PIM SM. Без неё ничего бы не работало. Здесь встречаются источник и получатели.  
Все PIM-маршрутизаторы должны знать, кто является RP в домене, то есть знать её IP-адрес.

Чтобы построить дерево MDT, в сети выбирается в качестве RP некая центральная точка, которая,

1. отвечает за изучение источника,
2. является точкой притяжения сообщений Join от всех заинтересованных.

Существует два способа задания RP: статический и динамический. Мы рассмотрим оба в этой статье, но начнём со статического, поскольку чего уж проще статики?

Пусть пока R2 будет выполнять роль RP.  
Чтобы увеличить надёжность, обычно выбирается адрес Loopback-интерфейса. Поэтому **на всех** маршрутизаторах выполняется команда:

```text
RX(config)#ip pim rp-address 2.2.2.2
```

Естественно, этот адрес должен быть доступен по таблице маршрутизации со всех точек.  
Ну и поскольку адрес 2.2.2.2 является RP, на интерфейсе _Loopback 0_ на R2 желательно тоже активировать PIM.

```text
R2(config)#interface Loopback 0
RX(config-if)#ip pim sparse-mode
```

Сразу после этого R4 узнает об источнике трафика для группы 224.2.2.4:

![](http://img-fotki.yandex.ru/get/9740/83739833.37/0_da310_9c1b38c7_XL.png)

и даже передаёт трафик:

![show interface summary](http://img-fotki.yandex.ru/get/9932/83739833.37/0_da311_5228d502_XL.png)

На интерфейс FE0/1 приходит 362000 б/с, и через интерфейс FE0/0 они передаются.

Всё, что мы сделали:  
Включили возможность маршрутизации мультикастового трафика \(**ip multicast-routing**\)  
Активировали PIM на интерфейсах \(**ip pim sparse-mode**\)  
Указали адрес RP \(**ip pim rp-adress** _**X.X.X.X**_\)

Всё, это уже рабочая конфигурация и можно приступать к разбору, ведь за кулисами скрывается гораздо больше, чем видно на сцене.  
[Полная конфигурация с PIM.](https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub)

#### Разбор полётов

Ну так и как же в итоге всё работает? Как RP узнаёт где источник, где клиенты и обеспечивает связь между ними?

Поскольку всё затевается ради наших любимых клиентов, то, начав с них, рассмотрим в деталях весь процесс.

**1\)** Клиент 1 отправляет IGMP Report для группы 224.2.2.4

![&#x41F;&#x43E;&#x434;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435; &#x43C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x43E;&#x432;&#x43E;&#x433;&#x43E; &#x43A;&#x43B;&#x438;&#x435;&#x43D;&#x442;&#x430;](http://img-fotki.yandex.ru/get/6727/83739833.37/0_da313_3e5a9f37_XXL.png)

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**2\)** R4 получает этот запрос, понимает, что есть клиент за интерфейсом FE0/0, добавляет этот интерфейс в OIL и формирует запись \(\*, G\).

![\(\*, G\)](http://img-fotki.yandex.ru/get/9491/83739833.37/0_da312_867e4e37_XL.png)

> Здесь видно восходящий интерфейс FE0/1, но это не значит, что R4 получает трафик для группы 224.2.2.4. Это говорит лишь о том, что единственное место, откуда сейчас он может получать — FE0/1, потому что именно там находится RP. Кстати, здесь же указан и сосед, который прошёл **RPF-Check** — R2: 10.0.2.24. Ожидаемо.

R4 называется — **LHR \(Last Hop Router\)** — последний маршрутизатор на пути мультикастового трафика, если считать от источника. Иными словами — это маршрутизатор, ближайший к получателю. Для _Клиента1_ — это R4, для _Клиента2_ — это R5.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**3\)** Поскольку на R4 пока нет мультикастового потока \(он его не запрашивал прежде\), он формирует сообщение PIM Join и отправляет его в сторону RP \(2.2.2.2\).

![\(\*, G\)](http://img-fotki.yandex.ru/get/9820/83739833.37/0_da314_6a1e3e1d_XXL.png)

PIM Join отправляется мультикастом на адрес 224.0.0.13. «В сторону RP» означает через интерфейс, который указан в таблице маршрутизации, как outbound для того адреса, который указан внутри пакета. В нашем случае это 2.2.2.2 — адрес RP. Такой Join обозначается ещё как **Join \(\*,G\)** и говорит: «Не важно, кто источник, мне нужен трафик группы 224.2.2.4».  
То есть каждый маршрутизатор на пути должен обработать такой Join и при необходимости отправить новый Join в сторону RP. \(Важно понимать, что если на маршрутизаторе уже есть эта группа, он не будет отправлять выше Join — он просто добавит интерфейс, с которого пришёл Join, в OIL и начнёт передавать трафик\).  
В нашем случае Join ушёл в FE0/1:

![show ip route](http://img-fotki.yandex.ru/get/9813/83739833.37/0_da315_d385f9e7_XL.png)

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**4\)** R2, получив Join, формирует запись \(\*, G\) и добавляет интерфейс FE0/0 в OIL. Но Join отсылать уже некуда — он сам уже RP, а про источник пока ничего не известно.

![](http://img-fotki.yandex.ru/get/9813/83739833.37/0_da316_a5b98bea_XL.png)  
Таким образом RP узнаёт о том, где находятся клиенты.

Если _Клиент 2_ тоже захочет получать мультикастовый трафик для той же группы, R5 отправит PIM Join в FE0/1, потому что за ним находится RP, R3, получив его, формирует новый PIM Join и отправляет в FE1/1 — туда, где находится RP.  
То есть Join путешествует так узел за узлом, пока не доберётся до RP или до другого маршрутизатора, где уже есть клиенты этой группы.

![](http://img-fotki.yandex.ru/get/6710/83739833.37/0_da317_d383a226_XL.png)

Итак, R2 — наш RP — сейчас знает о том, что за FE0/0 и FE1/0 у него есть получатели для группы 224.2.2.4.  
Причём неважно, сколько их там — по одному за каждым интерфейсом или по сто — поток трафика всё равно будет один на интерфейс.

Если изобразить графически то, что мы получили, то это будет выглядеть так:

![RP Tree](http://img-fotki.yandex.ru/get/9806/83739833.37/0_da318_4bb77bc6_XXL.png)

Отдалённо напоминает дерево, не так ли? Поэтому оно так и называется — **RPT — Rendezvous Point Tree**. Это дерево с корнем в RP, а ветви которого простираются до клиентов.  
Более общий термин, как мы упоминали выше, — **MDT — Multicast Distribution Tree** — дерево, вдоль которого распространяется мультикастовый поток. Позже вы увидите разницу между MDT и RPT.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**5\)** Теперь врубаем сервер. Как мы уже выше обсуждали, он не волнуется о PIM, RP, IGMP — он просто вещает. А R1 получает этот поток. Его задача — доставить мультикаст до RP.  
В PIM есть специальный тип сообщений — **Register**. Он нужен для того, чтобы зарегистрировать источник мультикаста на RP.  
Итак, R1 получает мультикастовый поток группы 224.2.2.4:

![show interface summary](http://img-fotki.yandex.ru/get/6729/83739833.38/0_da31b_832942ad_XXL.png)

![\(S, G\)](http://img-fotki.yandex.ru/get/6710/83739833.38/0_da31c_84967d3b_XL.png)

R1 является **FHR \(First Hop Router\)** — первый маршрутизатор на пути мультикастового трафика или ближайший к источнику.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**6\)** Далее он инкапсулирует каждый полученный от источника мультикастовый пакет в юникастовый PIM Register и отправляет его прямиком на RP.

![PIM Register](http://img-fotki.yandex.ru/get/9763/83739833.38/0_da31d_44c384a1_XXL.png)

Обратите внимание на стек протоколов. Поверх юникастового IP и заголовка PIM идёт изначальный мультикастовый IP, UDP и данные.  
Теперь, в отличие от всех других, пока известных нам сообщений PIM, в адресе получателя указан 2.2.2.2, а не мультикастовый адрес.

Такой пакет доставляется до RP по стандартным правилам юникастовой маршрутизации и несёт в себе изначальный мультикастовый пакет, то есть это… это же туннелирование!

> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 1**](https://linkmeup.ru/blog/130.html)  
>   
> [Схема и начальная конфигурация](https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub).  
>   
> ![](http://img-fotki.yandex.ru/get/9820/83739833.37/0_da30b_7fe598c3_XXL.png)  
>   
> На сервере 172.16.0.5 работает приложение, которое может передавать пакеты только на широковещательный адрес 255.255.255.255, с портом получателя UDP 10999.  
>   
> Этот трафик надо доставить к клиентам 1 и 2:  
> Клиенту 1 в виде мультикаст трафика с адресом группы 239.9.9.9.  
> А в сегмент клиента 2, в виде широковещательных пакетов на адрес 255.255.255.255.  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/130.html).

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**7\)** RP получает PIM Register, распаковывает его и обнаруживает под обёрткой трафик для группы 224.2.2.4.  
Информацию об этом он сразу заносит в свою таблицу мультикастовой маршрутизации:

![\(S, G\)](http://img-fotki.yandex.ru/get/6729/83739833.38/0_da31f_7e396715_XL.png)

Появилась запись \(S, G\) — \(172.16.0.5, 224.2.2.4\).  
Распакованные пакеты RP дальше отправляет в RPT в интерфейсы FE0/0 и FE1/0, по которому трафик доходит до клиентов.

В принципе, на этом можно было бы и остановиться. Всё работает — клиенты получают трафик. Но есть две проблемы:

1. Процессы инкапсуляции и декапсуляции — весьма затратные действия для маршрутизаторов. Кроме того, дополнительные заголовки увеличивают размер пакета, и он может просто не пролезть в MTU где-то на промежуточном узле \(вспоминаем все проблемы [туннелирования](http://www.opennet.ru/base/cisco/gre_fragment.txt.html)\).
2. Если вдруг где-то между источником и RP есть ещё получатели для группы, мультикастовому трафику придётся пройти один путь дважды.

Возьмём для примера вот такую топологию:

![PIM Register Encapsulation](http://img-fotki.yandex.ru/get/6727/83739833.37/0_da319_ddb77e2d_XXL.png)

Трафик в сообщениях Register сначала дойдёт до RP по линии R1-R42-R2, затем чистый мультикаст вернётся по линии R2-R42. Таким образом на линии R42-R2 будет ходить две копии одного трафика, пусть и в противоположных направлениях.

![&#x418;&#x43D;&#x43A;&#x430;&#x43F;&#x441;&#x443;&#x43B;&#x44F;&#x446;&#x438;&#x44F; PIM Register](http://img-fotki.yandex.ru/get/9169/83739833.38/0_da31a_4f499e56_XXL.png)

Поэтому лучше от источника до RP тоже передавать чистый мультикаст, а для этого нужно построить дерево — **Source Tree**.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**8\)** Поэтому RP отправляет на R1 сообщение PIM Join. Но теперь уже в нём указывается для группы адрес не RP, а источника, изученный из сообщения Register. Такое сообщение называется **Join \(S, G\) — Source Specific Join**.

![Source-Specific Join](http://img-fotki.yandex.ru/get/6727/83739833.38/0_da320_f23cd1ed_XXL.png)  
Цель у него точно такая же, как у PIM Join \(_, G\) — построить дерево, только на этот раз от источника до RP.  
Join \(S, G\) распространяется также узел за узлом, как обычный Join \(_, G\). Только Join \(\*, G\) стремится к RP, а Join \(S, G\) к S — источнику. В качестве адрес получателя также служебный адрес 224.0.0.13 и TTL=1.

> Если существуют промежуточные узлы, например, R42, они также формируют запись \(S, G\) и список нисходящих интерфейсов для данной группы и пересылают Join дальше к источнику.

Путь, по которому прошёл Join от RP до источника, превращается в **Source Tree** — дерево от источника. Но более распространённое название — **SPT — Shortest Path Tree** — ведь трафик от источника до RP пойдёт по кратчайшему пути.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**9\)** R1 получив Join \(S, G\), добавляет интерфейс FE1/0, откуда пакет пришёл, в список нисходящих интерфейсов OIL и начинает туда вещать чистый мультикастовый трафик, незамутнённый инкапсуляцией. Запись \(S, G\) на R1 уже была, как только он получит первый мультикастовый пакет от Сервера-источник.

![\(S, G\)](http://img-fotki.yandex.ru/get/9820/83739833.38/0_da31e_c1e554e6_XL.png)

По построенному Source Tree мультикаст передаётся RP \(и всем промежуточным клиентам, если они есть, например, R42\).

Но надо иметь ввиду, что сообщения Register передавались всё это время и передаются до сих пор. То есть фактически R1 отправляет две копии трафика сейчас: один — чистый мультикаст по SPT, другой — инкапсулированный в юникастовый Register.

![PIM Register &#x438; UDP &#x43E;&#x434;&#x43D;&#x43E;&#x432;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x43E;](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da321_87614b7d_XXL.png)

> Сначала R1 отправляет мультикаст в Register — **пакет 231**. Потом R2 \(RP\) хочет подключиться к дереву, отправляет Join — **пакет 232**. R1 ещё какое-то время, пока обрабатывает запрос от R2, отправляет мультикаст в Register \(**пакеты с 233 по 238**\). Далее, когда нисходящий интерфейс добавлен в OIL на R1, он начинает передавать чистый мультикаст — **пакеты 239 и 242**, но пока не прекращает и Register — **пакеты 241 и 243**. А **пакет 240** — это R2 не выдержал и ещё раз попросил построить дерево.

![](http://img-fotki.yandex.ru/get/6729/83739833.39/0_da9ff_770594e6_M.png)

**10\)** Итак, незамутнённый мультикаст достигает RP. Она понимает, что это тот же самый трафик, который приходит в Register, потому что одинаковый адрес группы, одинаковый адрес источника и с одного интерфейса. Чтобы не получать две копии, он отправляет на R1 юникастовый **PIM Register-Stop**.

![PIM Register-Stop](http://img-fotki.yandex.ru/get/9763/83739833.38/0_da322_749fa33e_XXXL.png)

Register-Stop не означает, что R2 отказывается от трафика или не признаёт больше этот источник, это говорит лишь о том, что надо прекратить посылать **инкапсулированный** трафик.

Далее идёт ожесточённая борьба — R1 продолжает передавать накопившийся в буфере трафик, пока обрабатывает Register-Stop, и обычным мультикастом и внутри сообщений Register:

![&#x41C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x43E;&#x432;&#x44B;&#x435; &#x441;&#x43E;&#x440;&#x435;&#x432;&#x43D;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x44F;](http://img-fotki.yandex.ru/get/9795/83739833.39/0_de2aa_fa550ead_XXXL.png)

Но, рано или поздно R1 начинает вещать только чистый мультикастовый трафик.

![Multicast UDP](http://img-fotki.yandex.ru/get/9748/83739833.38/0_da324_a862421b_XXXL.png)

> При подготовке у меня возник, как мне казалось, закономерный вопрос: ну и к чему все эти туннелирования, PIM Register? Почему бы не поступать с мультикастовым трафиком, как с PIM Join — отправлять хоп за хопом с TTL=1 в сторону RP — рано или поздно ведь дойдёт? Так бы и дерево построилось бы заодно без лишних телодвижений.  
> Тут возникает несколько нюансов.  
> Во-первых, нарушается главный принцип PIM SM — трафик посылать только туда, откуда он был запрошен. **Нет Join — Нет дерева**!  
> Во-вторых, если клиентов для данной группы нет, FHR не узнает об этом и будет продолжать слать трафик по «своему дереву». К чему такое бездумное использование полосы пропускания? В мире связи такой протокол просто не выжил бы, как не выжил PIM DM или DVMRP.

Таким образом мы имеем одно большое дерево MDT для группы 224.2.2.4 от _Cервера-источника_ до _Клиента 1_ и _Клиента 2_. И это MDT составлено из двух кусков, которые строились независимо друг от друга: **Source Tree** от источника до RP и **RPT** от RP до клиентов. Вот оно отличие MDT от RPT и SPT. MDT — это довольно общий термин, означающий дерево передачи мультикаста вообще, в то время, как RPT/SPT — это его очень конкретный вид.

А что делать, если сервер уже вещает, а клиентов всё нет и нет? Мультикаст так и будет засорять участок между отправителем и RP?  
Нет, в этом случае также поможет PIM Register-Stop. Если на RP начали приходить сообщения Register для какой-то группы, а для неё ещё нет получателей, то RP не заинтересован в получении этого трафика, поэтому, **не отправляя** PIM Join \(S, G\), RP сразу посылает Register-Stop на R1.  
R1, получив Register-Stop и видя, что дерева для этой группы пока нет \(нет клиентов\), начинает отбрасывать мультикастовый трафик от сервера.  
То есть сам сервер по этому поводу совершенно не беспокоится и продолжает посылать поток, но, дойдя до интерфейса маршрутизатора, поток будет отброшен.  
При этом RP продолжает хранить запись \(S, G\). То есть трафик он не получает, но где находится источник для группы знает. Если в группе появляются получатели, RP узнаёт о них и посылает на источник Join \(S, G\), который строит дерево.

Кроме того, каждые 3 минуты R1 будет пытаться повторно зарегистрировать источник на RP, то есть отправлять пакеты Register. Это нужно для того, чтобы уведомить RP о том, что этот источник ещё живой.

> У особо пытливых читателей обязан возникнуть вопрос — а как быть с RPF? Этот механизм ведь проверяет адрес отправителя мультикастового пакета и, если трафик идёт не с правильного интерфейса, он будет отброшен. При этом RP и источник могут находиться за разными интерфейсам. Вот и в нашем примере для R3 RP — за FE1/1, а источник — за FE1/0.  
> Ответ предсказуем — в таком случае проверяется не адрес источника, а RP. То есть трафик должен придти с интерфейса в сторону RP.  
> Но, как вы увидите далее, это тоже не нерушимое правило.

Важно понимать, что RP — это не универсальный магнит — для каждой группы может бытья своя RP. То есть в сети их может быть и две, и три, и сто — одна RP отвечает за один набор групп, другая — за другой. Более того, есть такое понятие, как [**Anycast RP**](http://lookmeup.linkmeup.ru/#term314) и тогда разные RP могут обслуживать одну и ту же группу.

> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 2**](https://linkmeup.ru/blog/131.html)  
>   
> [Схема и начальная конфигурация](https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub).  
>   
> ![](http://img-fotki.yandex.ru/get/9820/83739833.37/0_da30b_7fe598c3_XXL.png)  
>   
> **Замечание к топологии**: в этой задаче только маршрутизаторы R1, R2, R3 находятся под управлением администраторов нашей сети. То есть, конфигурацию изменять можно только на них.  
>   
> Сервер 172.16.0.5 передает мультикаст трафик на группы 239.1.1.1 и 239.2.2.2.  
>   
> Настроить сеть таким образом, чтобы трафик группы 239.1.1.1 не передавался в сегмент между R3 и R5, и во все сегменты ниже R5.  
> Но при этом, трафик группы 239.2.2.2 должен передаваться без проблем.  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/131.html).

#### Бритва Оккама или отключение ненужных ветвей

После того, как последний клиент в сегменте отказался от подписки, PIM должен отрезать лишнюю ветку RPT.  
Пусть, например, единственный клиент на R4 выключил компьютер. Маршрутизатор по сообщению IGMP Leave или после трёх безответных IGMP Query понимает, что клиентов за FE0/0 больше нет, и отправляет в сторону RP сообщение **PIM Prune**. По формату оно точно такое же, как Join, но выполняет противоположную функцию.  
Адрес назначения также 224.0.0.13, и TTL равен 1.

![PIM Prune](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da325_7e915979_XXL.png)

Но маршрутизатор, получивший PIM Prune, перед тем, как удалить подписку, ждёт некоторое время \(обычно 3 секунды — Join Delay Timer\).  
Это сделано вот для такой ситуации:  
![Prune override](http://img-fotki.yandex.ru/get/9801/83739833.39/0_dd0c2_a1a89fc6_XL.png)  
В одном широковещательном домене 3 маршрутизатора. Один из них стоит выше и именно он передаёт в сегмент мультикастовый трафик. Это R1. Для обоих маршрутизаторов \(R2 и R3\) его OIL содержит только одну запись.  
Если теперь R2 решит отключиться и отправит PIM Prune, то он может подставить своего коллегу R3 — R1 ведь перестанет вещать в интерфейс вообще.  
Так вот, чтобы этого не произошло, R1 и даёт таймаут в 3 секунды. За это время R3 должен успеть среагировать. Учитывая широковещательность сети, он тоже получит Prune от R2 и поэтому, если хочет продолжать получать трафик, он мгновенно отправляет обычный PIM Join в сегмент, уведомляя R1, что не надо удалять интерфейс.

Этот процесс называется — Prune Override. R2 как бы объегорил R1, перехватил инициативу.

#### SPT Switchover — переключение RPT-SPT

До сих пор мы преимущественно рассматривали только _Клиента 1_. Теперь обратимся к _Клиенту 2_.  
По началу всё для него идентично _Клиенту 1_ — он пользуется RPT от RP, который мы рассматривали ранее. Кстати, поскольку оба — и _Клиент 1_ и _Клиент 2_ — используют одно дерево, такое дерево называется **Shared Tree** — это довольно общее название. Shared tree = RPT.

Вот как выглядит таблица мультикастовой маршрутизации на R5 в самом начале, сразу после построения дерева:

![\(\*,G\) SPT Switchover](http://img-fotki.yandex.ru/get/9323/83739833.38/0_da329_b68b8b6f_XL.png)

Здесь нет записи \(S, G\), но это не значит, что мультикастовый трафик не передаётся. Просто R5 не заботится о том, кто отправитель.

Обратите внимание по какому пути должен идти в этом случае трафик — R1-R2-R3-R5. Хотя ведь короче путь R1-R3-R5.

![&#x41D;&#x435;&#x43E;&#x43F;&#x442;&#x438;&#x43C;&#x430;&#x43B;&#x44C;&#x43D;&#x44B;&#x439; &#x43F;&#x443;&#x442;&#x44C; &#x43F;&#x440;&#x438; &#x438;&#x441;&#x43F;&#x43E;&#x43B;&#x44C;&#x437;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x438; RPT](http://img-fotki.yandex.ru/get/9746/83739833.39/0_dd0c3_29b4fb86_XXL.png)

А если сеть посложнее?

![&#x41D;&#x435;&#x43E;&#x431;&#x445;&#x43E;&#x434;&#x438;&#x43C;&#x43E;&#x441;&#x442;&#x44C; &#x43F;&#x435;&#x440;&#x435;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x44F; &#x441; RPT &#x43D;&#x430; SPT](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da327_cefb2f7_XL.png)

Как-то неаккуратненько.

Дело в том, что пока мы привязаны к RP — она корень RPT, только она поначалу знает, где кто находится. Однако если вдуматься, то после первого же мультикастового пакета все маршрутизаторы по пути трафика будут знать адрес источника, ведь он указан в заголовке IP.

![&#x410;&#x434;&#x440;&#x435;&#x441; &#x438;&#x441;&#x442;&#x43E;&#x447;&#x43D;&#x438;&#x43A;&#x430; &#x43C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x43E;&#x432;&#x43E;&#x433;&#x43E; &#x43F;&#x430;&#x43A;&#x435;&#x442;&#x430;](http://img-fotki.yandex.ru/get/9491/83739833.38/0_da328_e88c56cd_XXL.png)

Почему бы кому-нибудь не отправить самому Join в сторону источника и оптимизировать маршрут?

Зрите в корень. Такое переключение может инициировать **LHR \(Last Hop Router\)** — R5. После получения первого мультикастового пакета от R3 R5 отправляет уже знакомый нам Source Specific Join \(S, G\) в интерфейс FE0/1, который указан в его таблице маршрутизации, как исходящий для сети 172.16.0.0/24.  
![&#x41F;&#x43E;&#x441;&#x442;&#x440;&#x43E;&#x435;&#x43D;&#x438;&#x435; &#x434;&#x435;&#x440;&#x435;&#x432;&#x430; SPT](http://img-fotki.yandex.ru/get/9813/83739833.38/0_da32b_7c57d31d_XXL.png)

Получив такой Join, R3 отправляет его не на RP, как делал это с обычным Join \(\*, G\), а в сторону источника \(через интерфейс согласно таблице маршрутизации\).  
То есть в данном случае R3 отправляет Join \(172.16.0.5, 224.2.2.4\) в интерфейс FE1/0.

![](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da32c_9d458ee3_XXL.png)

Далее этот Join попадает на R1. А R1 по большому счёту без разницы, кто его отправлял — RP или кто-то другой — он просто добавляет FE1/1 в свой OIL для группы 224.2.2.4.

![SPT](http://img-fotki.yandex.ru/get/9763/83739833.38/0_da32d_55e6e0da_XL.png)

В этот момент между источником и получателем два пути и R3 получает два потока.

![&#x414;&#x432;&#x430; &#x434;&#x435;&#x440;&#x435;&#x432;&#x430; &#x43E;&#x434;&#x43D;&#x43E;&#x432;&#x440;&#x435;&#x43C;&#x435;&#x43D;&#x43D;&#x43E;: SPT &#x438; RPT](http://img-fotki.yandex.ru/get/9753/83739833.38/0_da32e_4a211019_XXL.png)

Время сделать выбор, чтобы обрезать лишнее. Причём именно R3 его делает, потому что R5 уже не сможет различить эти два потока — они оба придут через один интерфейс.  
Как только R3 зафиксировал два одинаковых потока с разных интерфейсов, он выбирает предпочтительный согласно таблице маршрутизации. В данном случае прямой, лучше, чем через RP. В этот момент R3 посылает Prune \(S, G\) в сторону RP, обрубая эту ветку RPT. И с этого момент остаётся только один поток напрямую от источника.

![&#x41E;&#x442;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x438;&#x435; &#x43E;&#x442; &#x434;&#x435;&#x440;&#x435;&#x432;&#x430; RPT](http://img-fotki.yandex.ru/get/6710/83739833.38/0_da32f_c7246ca5_XXL.png)

Таким образом PIM построил SPT — Shortest Path Tree. Оно же Source Tree. Это кратчайший путь от клиента до источника. Кстати, дерево от источника до RP, которое мы уже рассматривали выше, — по сути ровно то же самое SPT.  
Оно характеризуется записью \(S, G\). Если маршрутизатор имеет такую запись, значит он знает, что S является источником для группы G и построено дерево SPT.

> Корнем дерева SPT является источник и очень хочется сказать «кратчайший путь от **источника до клиента**». Но это технически некорректно, поскольку пути от источника до клиента и от клиента до источника могут быть разными. А именно от клиента начинает строиться ветка дерева: маршрутизатор отправляет PIM Join в сторону источника/RP и RPF также проверяет правильность интерфейса при **получении** трафика.

_Вы помните, что вначале этого параграфа на R5 была только запись \(, G\), теперь после всех этих событий их станет две: \(, G\) и \(S, G\)_.

Между прочим, даже если вы посмотрите на мультикастовую таблицу маршрутизации R3 в ту же секунду, как нажали Play в VLC, то увидите, что он уже получает трафик от R1 напрямую, о чём говорит наличие записи \(S, G\).  
То есть SPT Switchover уже произошёл — это действие по умолчанию на оборудовании многих производителей — инициировать переключение после получения первого же мультикастового пакета.

Вообще говоря, происходить такое переключение может в нескольких случаях:

* Не происходить вообще никогда \(команда **ip pim spt-threshold infinity**\).
* При достижении определённой утилизации полосы пропускания \(команда **ip pim spt-threshold X**\).
* Безусловно — сразу после получения первого пакета \(действие по умолчанию или **no ip pim spt-threshold X**\)

Как правило, решение о том, что «пора», принимает LHR.

> В этом случае во второй раз изменяется правило работы RPF — он снова проверяет местонахождение источника. То есть из двух потоков мультикаста — от RP и от источника — предпочтение отдаётся трафику от источника.

### DR, Assert, Forwarder

Ещё несколько важных моментов при рассмотрении PIM.

**DR — Designated Router**.  
Это выделенный маршрутизатор, который ответственен за отправку служебных пакетов на RP.  
**Source DR** — отвечает за принятие мультикастовых пакетов непосредственно от источника и его регистрацию на RP.  
Вот пример топологии:

![Source DR](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da334_5783f87b_XXL.png)

Здесь ни к чему, чтобы оба маршрутизатора передавали трафик на RP, пусть они резервируют друг друга, но ответственный должен быть только один.  
Поскольку оба маршрутизатора подключены в одну широковещательную сеть, они получают друг от друга PIM-Hello. На основе него они и делают свой выбор.  
PIM Hello несёт значение приоритета данного маршрутизатора на данном интерфейсе.

![DR Priority](http://img-fotki.yandex.ru/get/9748/83739833.38/0_da335_611e03dd_XL.png)

Чем больше значение, тем выше приоритет. Если они одинаковы, то выбирается узел с **наибольшим IP-адресом** \(тоже из сообщения Hello\).

![DR &#x443; &#x438;&#x441;&#x442;&#x43E;&#x447;&#x43D;&#x438;&#x43A;&#x430;](http://img-fotki.yandex.ru/get/9812/83739833.38/0_da336_2412b543_XXL.png)

Если другой маршрутизатор \(не DR\) в течение Holdtime \(по умолчанию 105 с\) не получал Hello от соседа, он автоматически берёт на себя роль DR.

По сути Source DR — это [**FHR — First Hop Router**](http://lookmeup.linkmeup.ru/#term322).

**Receiver DR** — то же, что Source DR, только для получателей мультикастового трафика — [**LHR \(Last Hop Router\)**](http://lookmeup.linkmeup.ru/#term323).  
Пример топологии:

![Receiver DR](http://img-fotki.yandex.ru/get/9323/83739833.38/0_da337_41bb6b64_XL.png)

Receiver DR ответственен за отправку на RP PIM Join. В вышеприведённой топологии, если оба маршрутизатора отправят Join, то оба будут получать мультикастовый трафик, но в этом нет необходимости. Только DR отправляет Join. Второй просто мониторит доступность DR.  
Поскольку DR отправляет Join, то он же и будет вещать трафик в LAN. Но тут возникает закономерный вопрос — а что, если PIM DR'ом стал один, а IGMP Querier'ом другой? А ситуация-то вполне возможна, ведь для Querier чем меньше IP, тем лучше, а для DR, наоборот.  
В этом случае DR'ом выбирается тот маршрутизатор, который уже является Querier и такая проблема не возникает.

![DR &#x443; &#x43F;&#x43E;&#x43B;&#x443;&#x447;&#x430;&#x442;&#x435;&#x43B;&#x44F;](http://img-fotki.yandex.ru/get/9753/83739833.38/0_da338_f9dd276f_XXL.png)

Правила выбора Receiver DR точно такие же, как и Source DR.

**Assert и PIM Forwarder**  
Проблема двух одновременно передающих маршрутизаторов может возникнуть и в середине сети, где нет ни конечных клиентов, ни источников — только маршрутизаторы.  
Очень остро этот вопрос стоял в PIM DM, где это была совершенно рядовая ситуация из-за механизма Flood and Prune.  
Но и в PIM SM она не исключена.  
Рассмотрим такую сеть:

![Assert &#x438; PIM Forwarder](http://img-fotki.yandex.ru/get/9323/83739833.38/0_da331_f43f9538_XL.png)

Здесь три маршрутизатора находятся в одном сегменте сети и, соответственно, являются соседями по PIM. R1 выступает в роли RP.  
R4 отправляет PIM Join в сторону RP. Поскольку этот пакет мультикастовый он попадает и на R2 и на R3, и оба они обработав его, добавляют нисходящий интерфейс в OIL.  
Тут бы должен сработать механизм выбора DR, но и на R2 и на R3 есть другие клиенты этой группы, и обоим маршрутизаторам так или иначе придётся отправлять PIM Join.  
Когда мультикастовый трафик приходит от источника на R2 и R3, в сегмент он передаётся обоими маршрутизаторами и задваивается там. PIM не пытается предотвратить такую ситуацию — тут он действует по факту свершившегося преступления — как только в свой нисходящий интерфейс для определённой группы \(из списка OIL\) маршрутизатор получает мультикастовый трафик этой самой группы, он понимает: что-то не так — другой отправитель уже есть в этом сегменте.

![&#x414;&#x443;&#x431;&#x43B;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x435; &#x442;&#x440;&#x430;&#x444;&#x438;&#x43A;&#x430; &#x432; &#x441;&#x435;&#x433;&#x43C;&#x435;&#x43D;&#x442;&#x435;](http://img-fotki.yandex.ru/get/9323/83739833.38/0_da332_11fb6a09_XL.png)

Тогда маршрутизатор отправляет специальное сообщение **PIM Assert**.  
Такое сообщение помогает выбрать **PIM Forwarder** — тот маршрутизатор, который вправе вещать в данном сегменте.

![PIM Assert](http://img-fotki.yandex.ru/get/6727/83739833.38/0_da35a_5c489e55_XL.png)

Не надо его путать с PIM DR. Во-первых, PIM DR отвечает за отправку **сообщений PIM Join и Prune**, а PIM Forwarder — за отправку **трафика**. Второе отличие — PIM DR выбирается всегда и в любых сетях при установлении соседства, А PIM Forwrder только при необходимости — когда получен мультикастовый трафик с интерфейса из списка OIL.

### Выбор RP

Выше мы для простоты задавали RP вручную командой **ip pim rp-address** _**X.X.X.X**_.  
И вот как выглядела команда **show ip pim rp**:

![show ip pim rp](http://img-fotki.yandex.ru/get/9806/83739833.38/0_da339_f2fdf5d0_XL.png)

Но представим совершенно невозможную в современных сетях ситуацию — R2 вышел из строя. Это всё — финиш. _Клиент 2_ ещё будет работать, поскольку произошёл SPT Switchover, а вот всё новое и всё, что шло через RP сломается, даже если есть альтернативный путь.  
Ну и нагрузка на администратора домена. Представьте себе: на 50 маршрутизаторах перебить вручную как минимум одну команду \(а для разных групп ведь могут быть разные RP\).

Динамический выбор RP позволяет и избежать ручной работы и обеспечить надёжность — если одна RP станет недоступна, в бой вступит сразу же другая.

В данный момент существует один общепризнанный протокол, позволяющий это сделать — **Bootstrap**. Циска в прежние времена продвигала несколько неуклюжий [Auto-RP](http://lookmeup.linkmeup.ru/#term306), но сейчас он почти не используется, хотя циска этого не признаёт, и в **show ip mroute** мы имеем раздражающий рудимент в виде группы 224.0.1.40.

> Надо на самом деле отдать должное протоколу Auto-RP. Он был спасением в прежние времена. Но с появлением открытого и гибкого Bootstrap, он закономерно уступил свои позиции.

Итак, предположим, что в нашей сети мы хотим, чтобы R3 подхватывал функции RP в случае выхода из строя R2.  
R2 и R3 определяются как кандидаты на роль RP — так они и называются **C-RP**. На этих маршрутизаторах настраиваем:

```text
RX(config)interface Loopback 0
RX(config-if)ip pim sparse-mode
RX(config-if)exit
RX(config)#ip pim rp-candidate loopback 0
```

Но пока ничего не происходит — кандидаты пока не знают, как уведомить всех о себе.

Чтобы информировать все мультикастовые маршрутизаторы домена о существующих RP вводится механизм **BSR — BootStrap Router**. Претендентов может быть несколько, как и C-RP. Они называются соответственно **C-BSR**. Настраиваются они похожим образом.

Пусть BSR у нас будет один и для теста \(исключительно\) это будет R1.

```text
R1(config)interface Loopback 0
R1(config-if)ip pim sparse-mode
R1(config-if)exit
R1(config)#ip pim bsr-candidate loopback 0
```

Сначала из всех C-BSR выбирается один главный BSR, который и будет всем заправлять. Для этого каждый C-BSR отправляет в сеть мультикастовый **BootStrap Message \(BSM\)** на адрес 224.0.0.13 — это тоже пакет протокола PIM. Его должны принять и обработать все мультикастовые маршрутизаторы и после разослать во все порты, где активирован PIM. BSM передаётся не в сторону чего-то \(RP или источника\), в отличии, от PIM Join, а во все стороны. Такая веерная рассылка помогает достигнуть BSM всех уголков сети, в том числе всех C-BSR и всех C-RP. Для того, чтобы BSM не блуждали по сети бесконечно, применяется всё тот же механизм RPF — если BSM пришёл не с того интерфейса, за которым находится сеть отправителя этого сообщения, такое сообщение отбрасывается.

![Bootstrap](http://img-fotki.yandex.ru/get/9763/83739833.38/0_da33a_5ce7b684_XXL.png)

С помощью этих BSM все мультикастовые маршрутизаторы определяют самого достойного кандидата на основе приоритетов. Как только C-BSR получает BSM от другого маршрутизатора с бОльшим приоритетом, он прекращает рассылать свои сообщения. В результате все обладают одинаковой информацией.

![show ip pim bsr-router](http://img-fotki.yandex.ru/get/9820/83739833.38/0_da33b_943c21dc_XL.png)

На этом этапе, когда выбран BSR, благодаря тому, что его BSM разошлись уже по всей сети, C-RP знают его адрес и юникастом отправляют на него сообщения **Candidte-RP-Advertisement**, в которых они несут список групп, которые они обслуживают — это называется **group-to-RP mapping**. BSR все эти сообщения агрегирует и создаёт **RP-Set** — информационную таблицу: какие RP каждую группу обслуживают.

![Candidate-RP-Adverisement](http://img-fotki.yandex.ru/get/9753/83739833.38/0_da33c_cbc248cb_XXL.png)

Далее BSR в прежней веерной манере рассылает те же BootStrap Message, которые на этот раз содержат RP-Set. Эти сообщения успешно достигают всех мультикастовых маршрутизаторов, каждый из которых **самостоятельно** делает выбор, какую RP нужно использовать для каждой конкретной группы.

![BSR](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da33d_b62a5449_XXL.png)

BSR периодически делает такие рассылки, чтобы с одной стороны все знали, что информация по RP ещё актуальна, а с другой C-BSR были в курсе, что сам главный BSR ещё жив.  
RP, кстати, тоже периодически шлют на BSR свои анонсы Candidate-RP-Advertisement.

Фактически всё, что нужно сделать для настройки автоматического выбора RP — указать C-RP и указать C-BSR — не так уж много работы, всё остальное за вас сделает PIM.  
Как всегда, в целях повышения надёжности рекомендуется указывать интерфейсы Loopback в качестве кандидатов.

**Завершая главу PIM SM, давайте ещё раз отметим важнейшие моменты**

1. Должна быть обеспечена обычная юникастовая связность с помощью IGP или статических маршрутов. Это лежит в основе алгоритма RPF.
2. Дерево строится только после появления клиента. Именно клиент инициирует построение дерева. Нет клиента — нет дерева.
3. RPF помогает избежать петель.
4. Все маршрутизаторы должны знать о том, кто является RP — только с её помощью можно построить дерево.
5. Точка RP может быть указана статически, а может выбираться автоматически с помощью протокола BootStrap.
6. В первой фазе строится RPT — дерево от клиентов до RP — и Source Tree — дерево от источника до RP. Во второй фазе происходит переключение с построенного RPT на SPT — кратчайший путь от получателя до источника.

Ещё перечислим все типы деревьев и сообщений, которые нам теперь известны.

**MDT — Multicast Distribution Tree**. Общий термин, описывающий любое дерево передачи мультикаста.  
**SPT — Shortest Path Tree**. Дерево с кратчайшим путём от клиента или RP до источника. В PIM DM есть только SPT. В PIM SM SPT может быть от источника до RP или от источника до получателя после того, как произошёл SPT Switchover. Обозначается записью **\(S, G\)** — известен источник для группы.  
**Source Tree** — то же самое, что SPT.  
**RPT — Rendezvous Point Tree**. Дерево от RP до получателей. Используется только в PIM SM. Обозначается записью **\(\*, G\)**.  
**Shared Tree** — то же, что RPT. Называется так потому, что все клиенты подключены к одному общему дереву с корнем в RP.

Типы сообщений PIM Sparse Mode:  
**Hello** — для установления соседства и поддержания этих отношений. Также необходимы для выбора DR.  
**Join \(\*, G\)** — запрос на подключение к дереву группы G. Не важно кто источник. Отправляется в сторону RP. С их помощью строится дерево RPT.  
**Join \(S, G\)** — Source Specific Join. Это запрос на подключение к дереву группы G с определённым источником — S. Отправляется в сторону источника — S. С их помощью строится дерево SPT.  
**Prune \(\*, G\)** — запрос на отключение от дерева группы G, какие бы источники для неё не были. Отправляется в сторону RP. Так обрезается ветвь RPT.  
**Prune \(S, G\)** — запрос на отключение от дерева группы G, корнем которого является источник S. Отправляется в сторону источника. Так обрезается ветвь SPT.  
**Register** — специальное сообщение, внутри которого передаётся мультикаст на RP, пока не будет построено SPT от источника до RP. Передаётся юникастом от FHR на RP.  
**Register-Stop** — отправляется юникастом с RP на FHR, приказывая прекратить посылать мультикастовый трафик, инкапсулированный в Register.  
**Bootstrap** — пакеты механизма BSR, которые позволяют выбрать маршрутизатор на роль BSR, а также передают информацию о существующих RP и группах.  
**Assert** — сообщение для выбора PIM Forwarder, чтобы в один сегмент не передавали трафик два маршрутизатора.  
**Candidate-RP-Advertisement** — сообщение, в котором RP отсылает на BSR информацию о том, какие группы он обслуживает.  
**RP-Reachable** — сообщение от RP, которым она уведомляет всех о своей доступности.  
_Есть и другие типы сообщений в PIM, но это уже детали_

А давайте теперь попытаемся абстрагироваться от деталей протокола? И тогда становится очевидной его сложность.

1\) Определение RP,  
2\) Регистрация источника на RP,  
3\) Переключение на дерево SPT.

Много состояний протокола, много записей в таблице мультикастовой маршрутизации. Можно ли что-то с этим сделать?

На сегодняшний день существует два диаметрально противоположных подхода к упрощению PIM: SSM и BIDIR PIM.

### SSM

Всё, что мы описывали до сих пор — это **ASM — Any Source Multicast**. Клиентам безразлично, кто является источником трафика для группы — главное, что они его получают. Как вы помните в сообщении IGMPv2 Report запрашивается просто подключение к группе.  
**SSM — Source Specific Multicast** — альтернативный подход. В этом случае клиенты при подключении указывают группу и источник.  
Что же это даёт? Ни много ни мало: возможность полностью избавиться от RP. LHR сразу знает адрес источника — нет необходимости слать Join на RP, маршрутизатор может сразу же отправить Join \(S, G\) в направлении источника и построить SPT.  
Таким образом мы избавляемся от

* Поиска RP \(протоколы Bootstrap и Auto-RP\),
* Регистрации источника на мультикасте \(а это лишнее время, двойное использование полосы пропускания и туннелирование\)
* Переключения на SPT.

Поскольку нет RP, то нет и RPT, соответственно ни на одном маршрутизаторе уже не будет записей \(\*, G\) — только \(S, G\).  
Ещё одна проблема, которая решается с помощью SSM — наличие нескольких источников. В ASM рекомендуется, чтобы адрес мультикастовой группы был уникален и только один источник вещал на него, поскольку в дереве RPT несколько потоков сольются, а клиент, получая два потока от разных источников, вероятно, не сможет их разобрать.  
В SSM трафик от различных источников распространяется независимо, каждый по своему дереву SPT, и это уже становится не проблемой, а преимуществом — несколько серверов могут вещать одновременно. Если вдруг клиент начал фиксировать потери от основного источника, он может переключиться на резервный, даже не перезапрашивая его — он и так получал два потока.

Кроме того, возможный вектор атаки в сети с активированной мультикастовой маршрутизацией — подключение злоумышленником своего источника и генерирование большого объёма мультикастового трафика, который перегрузит сеть. В SSM такое практически исключено.

Для SSM выделен специальный диапазон IP-адресов: 232.0.0.0/8.  
На маршрутизаторах для поддержки SSM включается режим PIM SSM.

```text
Router(config)# ip pim ssm
```

IGMPv3 и MLDv2 поддерживают SSM в чистом виде.  
При их использовании клиент может

* Запрашивать подключение к просто группе, без указания источников. То есть работает как типичный ASM.
* Запрашивать подключение к группе с определённым источником. Источников можно указать несколько — до каждого из них будет построено дерево.
* Запрашивать подключение к группе и указать список источников, от которых клиент **не хотел** бы получать трафик

![IGMPv3](http://img-fotki.yandex.ru/get/9806/83739833.39/0_db5cd_7173c5bc_XXXL.png)

IGMPv1/v2, MLDv1 не поддерживают SSM, но имеет место такое понятие, как **SSM Mapping**. На ближайшем к клиенту маршрутизаторе \(LHR\) каждой группе ставится в соответствие адрес источника \(или несколько\). Поэтому если в сети есть клиенты, не поддерживающие IGMPv3/MLDv2, для них также будет построено SPT, а не RPT, благодаря тому, что адрес источника всё равно известен.  
SSM Mapping может быть реализован как статической настройкой на LHR, так и посредством обращения к DNS-серверу.

Проблема SSM в том, что клиенты должны заранее знать адреса источников — никакой сигнализацией они им не сообщаются.  
Поэтому SSM хорош в тех ситуациях, когда в сети определённый набор источников, их адреса заведомо известны и не будут меняться. А клиентские терминалы или приложения жёстко привязаны к ним.  
Иными словами IPTV — весьма пригодная среда для внедрения SSM. Это хорошо описывает концепцию **One-to-Many** — один источник, много получателей.

### BIDIR PIM

А что если в сети источники могут появляться спонтанно то там, то тут, вещать на одинаковые группы, быстро прекращать передачу и исчезать?  
Например, такая ситуация возможна в сетевых играх или в ЦОД, где происходит репликация данных между различными серверами. Это концепция **Many-to-Many** — много источников, много клиентов.  
Как на это смотрит обычный PIM SM? _Понятное дело, что инертный PIM SSM здесь совсем не подходит?_  
Вы только подумайте, какой хаос начнётся: бесконечные регистрации источников, перестроение деревьев, огромное количество записей \(S, G\) живущих по несколько минут из-за таймеров протокола.  
На выручку идёт двунаправленный PIM \(**Bidirectional PIM, BIDIR PIM**\). В отличие от SSM в нём напротив полностью отказываются от SPT и записей \(S,G\) — остаются только Shared Tree с корнем в RP.  
И если в обычном PIM, дерево является односторонним — трафик всегда передаётся от источника вниз по SPT и от RP вниз по RPT — есть чёткое деление, где источник, где клиенты, то в двунаправленном от источника трафик к RP передаётся также вверх по Shared Tree — по тому же самому, по которому трафик течёт вниз к клиентам.

Это позволяет отказаться от регистрации источника на RP — трафик передаётся безусловно, без какой бы то ни было сигнализации и изменения состояний. Поскольку деревьев SPT нет вообще, то и SPT Switchover тоже не происходит.

Вот например:

![BIDIR PIM](http://img-fotki.yandex.ru/get/9837/83739833.39/0_dd500_450e22c9_XXL.png)

_Источник1_ начал передавать в сеть трафик группы 224.2.2.4 одновременно с _Источником2_. Потоки от них просто полились в сторону RP. Часть клиентов, которые находятся рядом начали получать трафик сразу, потому что на маршрутизаторах есть запись \(_, G\) \(есть клиенты\). Другая часть получает трафик по Shared Tree от RP. Причём получают они трафик от обоих источников одновременно.  
То есть, если взять для примера умозрительную сетевую игру, Источник1 это первый игрок в стрелялке, который сделал выстрел, а Источник2 — это другой игрок, который сделал шаг в сторону. Информация об этих двух событиях распространилась по всей сети. И \*каждый_ другой игрок \(_Получатель_\) должен узнать об обоих этих событиях.

> Если помните, то [чуть раньше](9.-multicast.md#PIM_Register) мы объяснили, зачем нужен процесс регистрации источника на RP — чтобы трафик не занимал канал, когда нет клиентов, то есть RP просто отказывался от него. Почему над этой проблемой мы не задумываемся сейчас? Причина проста: BIDIR PIM для ситуаций, когда источников много, но они вещают не постоянно, а периодически, относительно небольшими кусками данных. То есть канал от источника до RP не будет утилизироваться понапрасну.

Обратите внимание, что на изображении выше между R5 и R7 есть прямая линия, гораздо более короткая, чем путь через RP, но она не была использована, потому что Join идут в сторону RP согласно таблице маршрутизации, в которой данный путь не является оптимальным.

Выглядит довольно просто — нужно отправлять мультикастовые пакеты в направлении RP и всё, но есть один нюанс, который всё портит — RPF. В дереве RPT он требует, чтобы трафик приходил от RP и не иначе. А у нас он может приходить откуда угодно. Взять и отказаться от RPF мы, конечно, не можем — это единственный механизм, который позволяет избежать образования петель.

Поэтому в BIDIR PIM вводится понятие **DF — Designated Forwarder**. В каждом сегменте сети, на каждой линии на эту роль выбирается тот маршрутизатор, чей маршрут до RP лучше.  
В том числе это делается и на тех линиях, куда непосредственно подключены клиенты. В BIDIR PIM DF автоматически является DR.

![Designated Forwarder](http://img-fotki.yandex.ru/get/9648/83739833.39/0_de2c2_bb121369_XXL.png)

Список OIL формируется только из тех интерфейсов, на которых маршрутизатор был выбран на роль DF.

Правила довольно прозрачны:

* **Если запрос PIM Join/Leave приходит на тот интерфейс, который в данном сегменте является DF, он передаётся в сторону RP по стандартным правилам.**  

  Вот, например, R3. Если запросы пришли в DF интерфейсы, что помечены красным кругом, он их передаёт на RP \(через R1 или R2, в зависимости от таблицы маршрутизации\).

* **Если запрос PIM Join/Leave пришёл на не DF интерфейс, он будет проигнорирован.**  

  Допустим, что клиент, находящийся между R1 и R3, решил подключиться и отправил IGMP Report. R1 получает его через интерфейс, где он выбран DF \(помечен красным кругом\), и мы возвращаемся к предыдущему сценарию. А R3 получает запрос на интерфейс, который не является DF. R3 видит, что тут он не лучший, и игнорирует запрос.

* **Если мультикастовый трафик пришёл на DF интерфейс, он будет отправлен в интерфейсы из списка OIL и в сторону RP.**  

  Например, _Источник1_ начал передавать трафик. R4 получает его в свой DF интерфейс и передаёт его и в другой DF-интерфейс — в сторону клиента и в сторону RP, — это важно, потому что трафик должен попасть на RP и распространиться по всем получателям. Также поступает и R3 — одна копия в интерфейсы из списка OIL — то есть на R5, где он будет отброшен из-за проверки RPF, и другая — в сторону RP.

* **Если мультикастовый трафик пришёл на не DF интерфейс, он должен быть отправлен в интерфейсы из списка OIL, но** не будет **отправлен в сторону RP.**  

  К примеру, _Источник2_ начал вещать, трафик дошёл до RP и начал распространяться вниз по RPT. R3 получает трафик от R1, и он не передаст его на R2 — только вниз на R4 и на R5.

Таким образом DF гарантирует, что на RP в итоге будет отправлена только одна копия мультикастового пакета и образование петель исключено. При этом то общее дерево, в котором находится источник, естественно, получит этот трафик ещё до попадания на RP. RP, согласно обычным правилам разошлёт трафик во все порты OIL, кроме того, откуда пришёл трафик.

Кстати, нет нужды более и в сообщениях Assert, ведь DF выбирается в каждом сегменте. В отличие от DR он отвечает не только за отправку Join к RP, но и за передачу трафика в сегмент, то есть ситуация, когда два маршрутизатора передают в одну подсеть трафик, исключена в BIDIR PIM.

Пожалуй, последнее, что нужно сказать о двунаправленном PIM, это особенности работы RP. Если в PIM SM RP выполнял вполне конкретную функцию — регистрация источника, то в BIDIR PIM RP — это некая весьма условная точка, к которой стремится трафик с одной стороны и Join от клиентов с другой. Никто не должен выполнять декапсуляцию, запрашивать построение дерева SPT. Просто на каком-то маршрутизаторе вдруг трафик от источников начинает передаваться в Shared Tree. Почему я говорю «на каком-то»? Дело в том, что в BIDIR PIM RP — абстрактная точка, а не конкретный маршрутизатор, в качестве адреса RP вообще может выступать несуществующий IP-адрес — главное, чтобы он был маршрутизируемый \(такая RP называется [Phantom RP](http://lookmeup.linkmeup.ru/#term346)\).

Все термины, касающиеся PIM, можно найти в [глоссарии](http://lookmeup.linkmeup.ru/#term293).

## Мультикаст на канальном уровне

Итак, позади долгая трудовая неделя с недосыпами, переработками, тестами — вы успешно внедрили мультикаст и удовлетворили клиентов, директора и отдел продаж.  
Пятница — не самый плохой день, чтобы обозреть творение и позволить себе приятный отдых.  
Но ваш послеобеденный сон вдруг потревожил звонок техподдержки, потом ещё один и ещё — ничего не работает, всё сломалось. Проверяете — идут потери, разрывы. Всё сходится на одном сегменте из нескольких коммутаторов.

Расчехлили SSH, проверили CPU, проверили утилизацию интерфейсов и волосы дыбом — загрузка почти под 100% на всех интерфейсах одного VLAN'а. Петля! Но откуда ей взяться, если никаких работ не проводилось? Минут 10 проверки и вы заметили, что на восходящем интерфейсе к ядру у вас много входящего трафика, а на всех нисходящих к клиентам — исходящего. Для петли это тоже характерно, но как-то подозрительно: внедрили мультикаст, никаких работ по переключению не делали и скачок только в одном направлении.  
Проверили список мультикастовых групп на маршрутизаторе — а там подписка на все возможные каналы и все на один порт — естественно, тот, который ведёт в этот сегмент.  
Дотошное расследование показало, что компьютер клиента заражён и рассылает IGMP Query на все мультикастовые адреса подряд.

Потери пакетов начались, потому что коммутаторам пришлось пропускать через себя огромный объём трафика. Это вызвало переполнение буферов интерфейсов.

Главный вопрос — почему трафик одного клиента начал копироваться во все порты?

Причина этого кроется в природе мультикастовых MAC-адресов. Дело в том, пространство мультикастовых IP-адресов специальным образом отображается в пространство мультикастовых MAC-адресов. И загвоздка в том, что они никогда не будут использоваться в качестве MAC-адреса источника, а следовательно, не будут изучены коммутатором и занесены в таблицу MAC-адресов. А как поступает коммутатор с кадрами, адрес назначения которых не изучен? Он их рассылает во все порты. Что и произошло.  
Это действие по умолчанию.

![Multicast Flooding](http://img-fotki.yandex.ru/get/9806/83739833.38/0_da341_75d51cd6_XL.png)

### Мультикастовые MAC-адреса

Так какие же MAC-адреса получателей подставляются в заголовок Ethernet таких пакетов? Широковещательные? Нет. Существует специальный диапазон MAC-адресов, в которые отображаются мультикастовые IP-адреса.  
Эти специальные адреса начинаются так: **0x01005e и следующий 25-й бит должен быть 0** \(_попробуйте ответить, почему так_\). Остальные 23 бита \(напомню, всего их в МАС-адресе 48\) переносятся из IP-адреса.

Здесь кроется некоторая не очень серьёзная, но проблема. Диапазон мультикастовых адресов определяется маской 224.0.0.0/4, это означает, что первые 4 бита зарезервированы: 1110, а оставшиеся 28 бит могут меняться. То есть у нас 2^28 мультикастовых IP-адресов и только 2^23 MAC-адресов — для отображения 1 в 1 не хватает 5 бит. Поэтому берутся просто последние 23 бита IP-адреса и один в один переносятся в MAC-адрес, остальные 5 отбрасываются.

[![Multicast MAC Address](https://github.com/eucariot/SDSM/tree/7b345502febe9fd2568a2f2a3ba95b9749b5840f/habrastorage.org/files/1a7/99c/58e/1a799c58e33f4ddfaf61d7ee6a413fae.gif)](http://img-fotki.yandex.ru/get/9497/83739833.38/0_da344_9d589e31_XXL.png)

Фактически это означает, что в один мультикастовый MAC-адрес будет отображаться 2^5=32 IP-адреса. Например, группы 224.0.0.1, 224.128.0.1, 225.0.0.1 и так до 239.128.0.1 все будут отображаться в один MAC-адрес 0100:5e00:0001.

Если взять в пример дамп потокового видео, то можно увидеть:

![&#x414;&#x430;&#x43C;&#x43F; &#x43C;&#x443;&#x43B;&#x44C;&#x442;&#x438;&#x43A;&#x430;&#x441;&#x442;&#x430;](http://img-fotki.yandex.ru/get/9169/83739833.38/0_da343_9ffb645a_XXL.png)

IP адрес — 224.2.2.4, MAC-адрес: 01:00:5E:02:02:04.

Есть также другие мультикастовые MAC-адреса, которые никак не относятся к IPv4-мультикаст \([клик](https://en.wikipedia.org/wiki/Multicast_address#Ethernet)\). Все они, кстати, характеризуются тем, что последний бит первого октета равен 1.

Естественно, ни на одной сетевой карте, не может быть настроен такой MAC-адрес, поэтому он никогда не будет в поле Source MAC Ethernet-кадра и никогда не попадёт в таблицу MAC-адресов. Значит такие кадры должны рассылаться как любой [Unknown Unicast](http://lookmeup.linkmeup.ru/#term430) во все порты VLAN'а.

Всего, что мы рассматривали прежде, вполне достаточно для полноценной передачи любого мультикастового трафика от потокового видео до биржевых котировок. Но неужели мы в своём почти совершенном мире будем мирится с таким безобразием, как широковещательная передача того, что можно было бы передать избранным?  
Вовсе нет. _Специально для перфекционистов_ придуман механизм **IGMP Snooping**.

### IGMP Snooping

Идея очень простая — коммутатор «слушает» проходящие через него IGMP-пакеты.  
Для каждой группы отдельно он ведёт таблицу восходящих и нисходящих портов.

Если с порта пришёл IGMP Report для группы, значит там клиент, коммутатор добавляет его в список нисходящих для этой группы.  
Если с порта пришёл IGMP Query для группы, значит там маршрутизатор, коммутатор добавляет его в список восходящих.

Таким образом формируется таблица передачи мультикастового трафика на канальном уровне.  
В итоге, когда сверху приходит мультикастовый поток, он копируется только в нисходящие интерфейсы. Если на 16-портовом коммутаторе только два клиента, только им и будет доставлен трафик.

![IGMP Snooping](http://img-fotki.yandex.ru/get/9089/83739833.38/0_da342_9c370be2_XL.png)

Гениальность этой идеи заканчивается тогда, когда мы задумываемся о её природе. Механизм предполагает, что коммутатор должен прослушивать трафик на 3-м уровне.

Впрочем, IGMP Snooping ни в какое сравнение не идёт с NAT по степени игнорирования принципов сетевого взаимодействия. Тем более, кроме экономии в ресурсах, он несёт в себе массу менее очевидных возможностей. Да и в общем-то в современном мире, коммутатор, который умеет заглядывать внутрь IP — явление не исключительное.

> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 3**](https://linkmeup.ru/blog/132.html)  
>   
> [Схема и начальная конфигурация](https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub).  
>   
> ![](http://img-fotki.yandex.ru/get/9820/83739833.37/0_da30b_7fe598c3_XXL.png)  
>   
> Сервер 172.16.0.5 передает мультикаст трафик на группы 239.1.1.1, 239.2.2.2 и 239.0.0.x.  
> Настроить сеть таким образом, чтобы:  
> — клиент 1 не мог присоединиться к группе 239.2.2.2. Но при этом мог присоединиться к группе 239.0.0.x.  
> — клиент 2 не мог присоединиться к группе 239.1.1.1. Но при этом мог присоединиться к группе 239.0.0.x.  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/132.html).

#### IGMP Snooping Proxy

У пытливого читателя может возникнуть вопрос по тому, как IGMP Snooping узнаёт все клиентские порты, учитывая, что на IGMP Query отвечает только один самый быстрый клиент, как мы говорили выше. А очень просто: IGMP Snooping не позволяет сообщениям Report ходить между клиентами. Они отправляются только в восходящие порты к маршрутизаторам. Не видя Report от других получателей этой группы, клиент обязан ответить на Query в течение Max Response Time, указанном в этом Query.  
В итоге в сети на 1000 узлов на один IGMP Query в течение секунд 10 \(обычное значение Max Response Time\) придёт 1000 Report'ов маршрутизатору. Хотя ему достаточно было бы и одного для каждой группы.  
И происходит это каждую минуту.

В этом случае можно настроить проксирование IGMP-запросов. Тогда коммутатор не просто «слушает» проходящие пакеты, он их перехватывает.

Правила работы IGMP Snooping могут отличаться для разных производителей. Поэтому рассмотрим их концептуально:

1\) Если на коммутатор приходит самый первый запрос Report на группу, он отправляется вверх к маршрутизатору, а интерфейс вносится в список нисходящих. Если же такая группа уже есть, интерфейс просто добавляется в список нисходящих, а Report уничтожается.  
2\) Если на коммутатор приходит самый последний Leave, то есть других клиентов нет, этот Leave будет отправлен на маршрутизатор, а интерфейс удаляется из списка нисходящих. В противном случае просто удаляется интерфейс, Leave уничтожается.  
3\) Если IGMP Query приходит от маршрутизатора, коммутатор перехватывает его, отправляет в ответ IGMP Report для всех групп, которые в данный момент имеют получателей.  
А дальше, в зависимости от настроек и производителя, либо этот же самый Query рассылается во все клиентские порты, либо коммутатор блокирует запрос от маршрутизатора и сам выступает в роли Querier, периодически опрашивая всех получателей.

Таким образом снижается и доля лишнего служебного трафика в сети и нагрузка на маршрутизатор.

#### Multicast VLAN Replication

Сокращённо **MVR**. Это механизм для тех провайдеров, кто практикует [VLAN-per-user](http://lookmeup.linkmeup.ru/#term230), например.  
Вот типичный пример сети, где MVR жизненно необходим:

![MVR](http://img-fotki.yandex.ru/get/9820/83739833.38/0_da33e_e680062a_XL.png)

5 клиентов в разных VLAN'ах, и все хотят получать мультикастовый трафик одной группы 224.2.2.4. При этом клиенты должны оставаться изолированными друг от друга.

IGMP Snooping учитывает, разумеется и VLAN'ы. Если пять клиентов в разных VLAN'ах запрашивают одну группу — это будет пять разных таблиц. Соответственно и к маршрутизатору идут 5 запросов на подключение к группе. И каждый сабинтерфейс из этих пяти на маршрутизаторе будет добавлен отдельно в OIL. То есть получив 1 поток для группы 224.2.2.4 он отправит 5 копий, несмотря на то, что все они идут в один сегмент.

![Multicast VLAN Replication](http://img-fotki.yandex.ru/get/6729/83739833.38/0_da33f_932558b_XL.png)

Для решения этой проблемы и был разработан механизм Multicast VLAN Replication.  
Вводится дополнительный VLAN — **Multicast VLAN** — в нём, соответственно, будет передаваться мультикастовый поток. Он «проброшен» непосредственно до последнего коммутатора, где трафик из него копируется во все клиентские интерфейсы, которые хотят получать этот трафик — это и есть репликация.  
В зависимости от реализации репликация из Multicast VLAN может производиться в **User-VLAN** или в определённые физические интерфейсы.

![Multicast VLAN Replication](http://img-fotki.yandex.ru/get/9812/83739833.38/0_da35b_95f170a3_XL.png)  
А что с IGMP-сообщениями? Query от маршрутизатора, естественно, приходит по мультикастовому VLAN'у. Коммутатор их рассылает в клиентские порты. Когда Report или Leave приходит от клиента, коммутатор проверяет откуда именно \(VLAN, интерфейс\) и, если необходимо, перенаправляет в мультикастовый VLAN.  
Таким образом обычный трафик изолирован и по-прежнему ходит до маршрутизатора в пользовательском VLAN'е. А мультикастовый трафик и IGMP-пакеты передаются в Multicast VLAN.

> На оборудовании Cisco MVR и IGMP Snooping настраиваются независимо. То есть можно отключить один и второй будет работать. Вообще же MVR основан на IGMP Snooping и на коммутаторах других производителей для работы MVR может быть обязательным включение IGMP Snooping.

Кроме того, IGMP Snooping позволяет осуществлять на коммутаторах фильтрацию трафика, ограничивать количество групп, доступных пользователю, включение IGMP Querier, статическую настройку восходящих портов, перманентное подключение к какой-либо группе \(этот сценарий есть в сопутствующем [видео](http://www.youtube.com/watch?feature=player_embedded&v=7MqBF0wKNR0#t=60)\), быструю реакцию на изменение топологии путём рассылки дополнительных Query, SSM-Mapping для IGMPv2 итд.

Заканчивая разговор об IGMP Snooping, хочется повторить — это необязательный функционал — всё и без него будет работать. Но это сделает сеть более предсказуемой, а жизнь инженера спокойнее.  
Однако все плюсы IGMP Snooping можно обернуть и против себя. Один такой выдающийся случай можно почитать по [ссылке](http://nag.ru/articles/article/25136/takie-raznyie-problemyi.html).  
К слову у той же Cisco есть протокол [CGMP](http://lookmeup.linkmeup.ru/#term352) — аналог IGMP, который не нарушает принципы работы коммутатора, но он проприетарный и не сказать, что широко распространённый.

Итак, мой неутомимый читатель, мы приближаемся к концу выпуска и напоследок хочется показать, как может быть реализована услуга IPTV на стороне клиента.  
Самый простой способ, к которому мы уже не раз обращались в этой статье — запустить плеер, который может принять мультикастовый поток из сети. На нём можно вручную задать IP-адрес группы и наслаждаться видео.  
Другой программный вариант, который часто используют провайдеры — специальное приложение, обычно весьма кастомное, в котором зашит набор каналов, используемых в сети провайдера. Нет необходимости что-то задавать вручную — нужно просто переключать каналы кнопками.

Оба эти способа дают возможность смотреть потоковое видео только на компьютере.

Третий же вариант позволяет использовать телевизор, причём как правило, любой. Для этого в доме клиента ставит так называемый Set-Top-Box \(STB\) — коробочка, устанавливаемая на телевизор. Это шелезяка, которая включается в абонентскую линию и разделяет трафик: обычный юникаст она отдаёт в Ethernet или WiFi, чтобы клиенты имели доступ в Интернет, а мультикастовый поток передаётся на телевизор через кабель \(DVI, RGB, антенный итд.\).  
Часто вы, кстати, можете увидеть рекламу, где провайдер предлагает свои приставки для подключения телевидения — это и есть те самые STB

> [![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача № 4**](https://linkmeup.ru/blog/133.html)  
>   
> Напоследок нетривиальная задачка по мультикасту \(авторы не мы, в ответах будет ссылка на оригинал\).  
>   
> Самая простая схема:  
>   
> ![](http://img-fotki.yandex.ru/get/9828/83739833.39/0_de323_177b1832_L.png)  
>   
> С одной стороны сервер-источник, с дугой — компьютер, который готов принимать трафик.  
>   
> Адрес мультикастового потока вы можете устанавливать сами.  
>   
> И соответственно, два вопроса:  
> **1.** Что нужно сделать, чтобы компьютер мог получать поток и при этом не прибегать к мультикастовой маршрутизации?  
> **2.** Допустим, вы вообще не знаете, что такое мультикаст и не можете его настраивать, как передать поток от сервера к компьютеру?  
>   
> Задача легко ищется в поисковике, но попробуйте решить её сами.  
>   
> Подробности задачи [тут](https://linkmeup.ru/blog/133.html).

Незатронутыми в статье остались междоменная маршрутизация мультикастового трафика \([MSDP](http://lookmeup.linkmeup.ru/#term349), [MBGP](http://lookmeup.linkmeup.ru/#term238), [BGMP](http://lookmeup.linkmeup.ru/#term237)\), балансировка нагрузки между RP \([Anycast RP](http://lookmeup.linkmeup.ru/#term314)\), [PGM](http://habrahabr.ru/post/148444/), проприетарные протоколы. Но, я думаю, имея как точку старта эту статью, разобраться в остальном не составит труда.  
Все термины, касающиеся мультикаста, вы можете найти в телекоммуникационном глоссарии [lookmeup](http://lookmeup.linkmeup.ru/).  
За помощь в подготовке статьи спасибо [JDima](http://habrahabr.ru/users/jdima/).  
За техническую поддержку спасибо [Наташе Самойленко](http://xgu.ru/wiki/Категория:Автор_Наташа_Самойленко).

КДПВ нарисована [Ниной Долгополовой](http://www.nina-dolgopolova.com/) — замечательным художником и другом проекта.

В пуле статей СДСМ ещё много интересного до окончания, поэтому не нужно хоронить цикл из-за долгого отсутствия выпуска — с каждой новой статьёй сложность значительно возрастает. Впереди почти весь MPLS, IPv6, QoS и дизайн сетей.

