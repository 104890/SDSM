Сеть “Лифт ми Ап” вместе со своим штатом разрастается вдоль и поперёк. Обслуживание ИТ-инфраструктуры вынесли в отдельную специально созданную организацию “Линк ми Ап”.  
Буквально на днях были куплены ещё четыре филиала в различных городах и инвесторы открыли для себя новые измерения движения лифтов. А сеть выросла с четырёх маршрутизаторов сразу до десяти. При этом количество подсетей теперь увеличилось с 9 до 20, не считая линков точка-точка между маршрутизаторами. И тут во весь рост встаёт вопрос управления всем этим хозяйством. Согласитесь, добавлять на каждом из узлов маршруты во все сети вручную — мало удовольствия.  
Ситуация усложняется тем, что сеть в Калининграде уже имеет свою адресацию, и на ней запущен протокол динамической маршрутизации EIGRP.  
Итак, сегодня:  

*   Разбираемся с теорией протоколов динамической маршрутизации.
*   Внедряем в сеть “Лифт ми Ап” протокол OSPF
*   Настраиваем передачу (редистрибуцию) маршрутов между OSPF и EIGRP
*   В этом выпуске мы добавляем раздел “Задачи”. Идентифицировать по ходу статьи их будут такие пиктограммы:

![](https://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)  
Уровень сложности будет разный. Ко всем задачам будут ответы, которые можно посмотреть на [сайте цикла](https://linkmeup.ru/challenges/). В некоторых из них вам понадобится подумать, в других почитать документацию, в третьих разобраться в топологии и, может, даже смотреть отладочную информацию. Если задача нереализуема в РТ, мы сделаем специальную пометку об этом.  

#### Теория протоколов динамической маршрутизации

Для начала разберемся с понятием “динамическая маршрутизация”. До сего момента мы использовали так называемую статическую маршрутизацию, то есть прописывали руками таблицу маршрутизации на каждом роутере. Использование протоколов маршрутизации позволяет нам избежать этого нудного однообразного процесса и ошибок, связанных с человеческим фактором. Как понятно из названия, эти протоколы призваны строить таблицы маршрутизации сами, **автоматически**, исходя из текущей конфигурации сети. В общем, вещь нужная, особенно когда ваша сеть это не 3 роутера, а 30, например.  
Помимо удобства есть и другие аспекты. Например, **отказоустойчивость**. Имея сеть со статической маршрутизацией, вам крайне сложно будет организовать резервные каналы — некому отслеживать доступность того или иного сегмента.  

![](http://img-fotki.yandex.ru/get/6411/83739833.1f/0_9c865_87a035ec_L.jpg)  

Например, если в такой сети разорвать линк между R2 и R3, то пакеты с R1 будут уходить по прежнему на R2, где будут уничтожены, потому что их некуда отправить.  

![](http://img-fotki.yandex.ru/get/6412/83739833.1f/0_9c866_60569206_L.jpg)  

Протоколы динамической маршрутизации в течение нескольких секунд (а то и миллисекунд) узнают о проблемах на сети и перестраивают свои таблицы маршрутизации, и в вышеописанном случае пакеты будут отправляться уже по актуальному маршруту  

![](http://img-fotki.yandex.ru/get/6511/83739833.1f/0_9c867_d085ec2b_L.jpg)  

Ещё один важный момент — **балансировка трафика**. Протоколы динамической маршрутизации практически из коробки поддерживают эту фичу и вам не нужно добавлять избыточные маршруты вручную, высчитывая их.  

Ну и внедрение динамической маршрутизации сильно облегчает **масштабирование сети**. Когда вы добавляете новый элемент в сеть или подсеть на существующем маршрутизаторе, вам нужно выполнить всего несколько действий, чтобы всё заработало и вероятность ошибки минимальна, при этом информация об изменениях мгновенно расходится по всем устройствам. Ровно то же самое можно сказать и о глобальных изменениях топологии.  

Все протоколы маршрутизации можно разделить на две большие группы: внешние (**EGP** — Exterior Gateway Protocol) и внутренние (**IGP** — Interior Gateway Protocol). Чтобы объяснить различия между ними, нам потребуется термин “автономная система”. В общем смысле, автономной системой (доменом маршрутизации) называется группа роутеров, находящихся под общим управлением.  
В случае нашей обновлённой сети AS будет такой:  

![](http://img-fotki.yandex.ru/get/6611/83739833.1f/0_9c861_25440ef7_XL.jpg)  

Так вот, протоколы внутренней маршрутизации используются внутри автономной системы, а внешние — для соединения автономных систем между собой. В свою очередь, внутренние протоколы маршрутизации подразделяются на **Distance-Vector** (RIP, EIGRP) и **Link State** (OSPF, IS-IS). В этой статье мы не будем <s>пинать трупы</s> затрагивать протоколы RIP и IGRP в силу их почтенного возраста, а так же IS-IS в силу его отсутствия в ПТ.  

Коренные различия между этими двумя видами состоят в следующем:  
1) типе информации, которой обмениваются роутеры: таблицы маршрутизации у Distance-Vector и таблицы топологии у Link State,  
2) процессе выбора лучшего маршрута,  
3) количестве информации о сети, которое “держит в голове” каждый роутер: Distance-Vector знает только своих соседей, Link State имеет представление обо всей сети.  

Как мы видим, количество протоколов маршрутизации невелико, но все же не один-два. А что будет, если на роутере запустить несколько протоколов одновременно? Может оказаться, что у каждого протокола будет свое мнение о том, как лучше добраться до определенной сети. А если у нас еще и статические маршруты настроены? Кому роутер отдаст предпочтение и чей маршрут добавит в таблицу маршрутизации? Ответ на этот вопрос связан с новым термином: административная дистанция (на нащ вкус, довольно посредственная калька с английского Аdministrative distance, но лучше выдумать не смогли). Аdministrative distance это целое число от 0 до 255, выражающее “меру доверия” роутера к данному маршруту. Чем меньше AD, тем больше доверия. Вот табличка такого доверия с точки зрения Cisco:  

<table border="1">

<tbody>

<tr>

<th>Протокол</th>

<th>Административная дистанция</th>

</tr>

<tr>

<td>Connected interface</td>

<td>0</td>

</tr>

<tr>

<td>Static route</td>

<td>1</td>

</tr>

<tr>

<td>Enhanced Interior Gateway Routing Protocol (EIGRP) summary route</td>

<td>5</td>

</tr>

<tr>

<td>External Border Gateway Protocol (BGP)</td>

<td>20</td>

</tr>

<tr>

<td>Internal EIGRP</td>

<td>90</td>

</tr>

<tr>

<td>IGRP</td>

<td>100</td>

</tr>

<tr>

<td>OSPF</td>

<td>110</td>

</tr>

<tr>

<td>Intermediate System-to-Intermediate System (IS-IS)</td>

<td>115</td>

</tr>

<tr>

<td>Routing Information Protocol (RIP)</td>

<td>120</td>

</tr>

<tr>

<td>Exterior Gateway Protocol (EGP)</td>

<td>140</td>

</tr>

<tr>

<td>On Demand Routing (ODR)</td>

<td>160</td>

</tr>

<tr>

<td>External EIGRP</td>

<td>170</td>

</tr>

<tr>

<td>Internal BGP</td>

<td>200</td>

</tr>

<tr>

<td>Unknown</td>

<td>255</td>

</tr>

</tbody>

</table>

В сегодняшней статье мы разберём OSPF и EIGRP. Первый вам будет встречаться везде и постоянно, а второй очень хорош в сетях, где присутствует только оборудование Cisco.  
У каждого из них есть свои достоинства и недостатки. Можно сказать, что EIGRP выигрывает перед OSPF, но все плюсы нивелируются его проприетарностью. EIGRP — фирменный протокол Cisco и больше никто его не поддерживает.  
На самом деле у EIGRP много недостатков, но об этом не особо распространяются в популярных статьях. Вот только одна из проблем: [SIA](http://telecomtest.com.au/datasheets/packet-design/siawp.pdf)  

Итак, приступим.  

#### OSPF

Статей и видео о том, как настроить OSPF горы. Гораздо меньше описаний принципов работы. Вообще, тут такое дело, что OSPF можно просто настроить согласно мануалам, даже не зная про алгоритмы SPF и непонятные LSA. И всё будет работать и даже, скорее всего, прекрасно работать — на то он и рассчитан. То есть тут не как с вланами, где приходилось знать теорию вплоть до формата заголовка.  
Но инженера от эникейщика отличает то, что он понимает, почему его сеть функционирует так, а не иначе, и не хуже самогo OSPF знает, какой маршрут будет выбран протоколом.  
В рамках статьи, которая уже на этот момент составляет 8 000 символов, мы не сможем погрузиться в глубины теории, но рассмотрим принципиальные моменты.  
Очень просто и понятно, кстати, написано про OSPF на [xgu.ru](http://xgu.ru/wiki/OSPF) или в английской [википедии](http://en.wikipedia.org/wiki/Open_Shortest_Path_First).  
Итак, OSPFv2 работает поверх IP, а конкретно, он заточен только под IPv4 (OSPFv3 не зависит от протоколов 3-го уровня и потому может работать с IPv6).  

Рассмотрим его работу на примере вот такой упрощённой сети:  

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da12_d1d6fb5c_XL.jpg)  

Для начала надо сказать, что для того, чтобы между маршрутизаторами завязалась дружба (отношения смежности) должны выполниться следующие условия:  

1) в OSPF должны быть настроены одинаковые **Hello Interval** на тех маршрутизаторах, что подключены друг к другу. По умолчанию это 10 секунд в Broadcast сетях, типа Ethernet. Это своего рода KeepAlive сообщения. То есть каждые 10 секунд каждый маршрутизатор отправляет Hello пакет своему соседу, чтобы сказать: “Хей, я жив”,  
2) Одинаковыми должны быть и **Dead Interval** на них. Обычно это 4 интервала Hello — 40 секунд. Если в течение этого времени от соседа не получено Hello, то он считается недоступным и начинается <s>ПАНИКА</s> процесс перестроения локальной базы данных и рассылка обновлений всем соседям,  
3) Интерфейсы, подключенные друг к другу, должны быть в **одной подсети**,  
4) OSPF позволяет снизить нагрузку на CPU маршрутизаторов, разделив Автономную Систему на зоны. Так вот **номера зон** тоже должны совпадать,  
5) У каждого маршрутизатора, участвующего в процессе OSPF есть свой **уникальный** индентификатор — **Router ID**. Если вы о нём не позаботитесь, то маршрутизатор выберет его автоматически на основе информации о подключенных интерфейсах (выбирается высший адрес из интерфейсов, активных на момент запуска процесса OSPF). Но опять же у хорошего инженера всё под контролем, поэтому обычно создаётся Loopback интерфейс, которому присваивается адрес с маской /32 и именно он назначается Router ID. Это бывает удобно при обслуживании и траблшутинге.  
6) Должен совпадать размер MTU  

Далее пьеса в восьми частях.  

1) Штиль. Состояние OSPF — **DOWN**  
В это короткое мгновение в сети ничего не происходит — все молчат.  

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da15_c2a85553_XL.jpg)  

2) Поднимается ветер: маршрутизатор рассылает Hello-пакеты на мультикастный адрес [224.0.0.5](http://en.wikipedia.org/wiki/Multicast_address) со всех интерфейсов, где запущен OSPF. [TTL](http://ru.wikipedia.org/wiki/Time_to_live) таких сообщений равен одному, поэтому их получат только маршрутизаторы, находящиеся в том же сегменте сети. R1 переходит в состояние **INIT**.  

![](http://img-fotki.yandex.ru/get/6422/83739833.1f/0_9da19_bcc4c3f8_XL.jpg)  

В пакеты вкладывается следующая информация:  

*   Router ID
*   Hello Interval
*   Dead Interval
*   Neighbors
*   Subnet mask
*   Area ID
*   Router Priority
*   Адреса DR и BDR маршрутизаторов
*   Пароль аутентификации

Нас интересуют пока первые четыре или точнее вообще только Router ID и Neighbors.  
Сообщение Hello от маршрутизатора R1 несёт в себе его Router ID и не содержит Neighbors, потому что у него их пока нет.  
После получения этого мультикастного сообщения маршрутизатор R2 добавляет R1 в свою таблицу соседей (если совпали все необходимые параметры).  

![](http://img-fotki.yandex.ru/get/6521/83739833.1f/0_9da1c_13dc8099_XL.jpg)  

И отправляет на R1 уже юникастом новое сообщение Hello, где содержится Router ID этого маршрутизатора, а в списке Neigbors перечислены все его соседи. В числе прочих соседей в этом списке есть Router ID R1, то есть R2 уже считает его соседом.  

![](http://img-fotki.yandex.ru/get/6620/83739833.1f/0_9da20_235302c3_XL.jpg)  

3) Дружба. Когда R1 получает это сообщение Hello от R2, он пролистывает список соседей и находит в нём свой собственный Router ID, он добавляет R2 в свой список соседей.  

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da26_46263e45_XL.jpg)  

Теперь R1 и R2 друг у друга во взаимных соседях — это означает, что между ними установлены отношения смежности и маршрутизатор R1 переходит в состояние **TWO WAY**.  

![](http://img-fotki.yandex.ru/get/6421/83739833.1f/0_9da23_99cc98b_XL.jpg)  

Далее происходит выбор [DR и BDR](http://ru.wikipedia.org/wiki/OSPF#.D0.92.D1.8B.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BC.D0.B0.D1.80.D1.88.D1.80.D1.83.D1.82.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80_.28DR.29_.D0.B8_.D1.80.D0.B5.D0.B7.D0.B5.D1.80.D0.B2.D0.BD.D1.8B.D0.B9_.D0.B2.D1.8B.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BC.D0.B0.D1.80.D1.88.D1.80.D1.83.D1.82.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80_.28BDR.29), но мы не будем на этом останавливаться, хоть это и довольно важные вещи.  

4) Затишье перед бурей. Далее все переходят в состояние **EXSTART**. Здесь все соседи решают между собой, кто босс. Им становится маршрутизатор с наибольшим Router ID — R2.  

5) Когда выбран _Батька_, соседи переходят в состояние **Exchange** и обмениваются DBD-сообщениями (или DD) — Data Base Description, которые содержат описание LSDB (Link State Data Base), мол, я знаю про вот такие подсети.  
Тут надо пояснить, что такое LSDB. Если перевести на русский дословно: база данных о состоянии линков. В изначальном состоянии маршрутизатор знает только о тех линках (интерфейсах), на которых запущен процесс OSPF. По ходу пьесы, каждый маршрутизатор собирает всю информацию о сети и составляет топологию. Именно она и будет являться LSDB, которая должна быть одинакова на всех членах зоны.  
Первым отсылает свою DBD маршрутизатор, выбранный главным на данном интерфейсе — 2.2.2.2\. Следом за ним то же делает и 1.1.1.1.  

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da2a_2882c479_XL.jpg)  

6) Получив сообщение, маршрутизаторы R1 и R2 отправляют подтверждение о приёме DBD (LSAck), а затем сравнивают новую информацию с той, что содержится у них в LSDB и, если есть отличия, посылают LSR (Link State Request) друг другу, тем самым переходя в новое состояние **LOADING**. В LSR они говорят — “Я про вот эту сеть ничего не знаю. Расскажи мне подробнее”.  

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da2e_7c726edb_XL.jpg)  

7) R2, получив LSR от R1, высылает LSU (Link State Update), которые содержат в себе LSA (Link State Advertisement) c детальной информацией о нужных подсетях.  

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da32_4552fd75_XL.jpg)  

И вот, как только R1 получит последнюю порцию данных о всех подсетях и сформирует свою LSDB, он переходит в своё конечное состояние **FULL STATE**.  

![](http://img-fotki.yandex.ru/get/6623/83739833.1f/0_9da36_d2c831e1_XL.jpg)  

К тому моменту, как все маршрутизаторы зоны придут к состоянию Full State на всех на них должна быть полностью одинаковая LSDB — они же одну и ту же сеть изучали. То есть фактически это означает, что маршрутизатор знает всю вашу сеть, что, как и куда подключено.  

> Авторы осознают, что понять и запомнить все эти аббревиатуры и правила довольно сложно, но прочитав это 5 -7 раз в разных местах с некоторой периодичностью, можно будет составить представление о том, как OSPF работает.

8) Итак, сейчас у нас все маршрутизаторы знают всё о сети, но это знание не помогает в маршрутизации.  
Следующим шагом OSPF, используя алгоритм Дейкстры (или его ещё называют SPF — Shortest Path First), вычисляет кратчайший маршрут до каждого маршрутизатора в зоне — он ведь знает всю топологию. В этом ему помогают метрики. Чем она ниже, тем маршрут лучше. Метрика — это стоимость движения по маршруту.  

![](http://img-fotki.yandex.ru/get/6422/83739833.1f/0_9da0e_4fc28d4_XL.jpg)  

Например, в такой сети из R1 в R3 можно добраться напрямую или через R2.  
Естественно первый вариант будет стоить меньше. Но это при условии, что у вас везде одинаковый тип интерфейсов. А если, например, между R1 и R3 у вас модемное соединение в 56к или крайне нестабильный GPRS линк? Тогда у них будет очень высокая стоимость и OSPF предпочтёт более длинный, но быстрый путь.  
Найденный путь потом добавляется в таблицу маршрутизации.  

Теперь каждые 10 секунд каждый маршрутизатор будет отправлять Hello-пакеты, а каждые 30 минут рассылаются LSA — это типа данные уже считаются устаревшими, надо бы обновить, даже если изменений не было.  

В идеальном мире на этом бы и установилось равновесие. Но мы живём в мире жестоком и равнодушном, где инженер — это итшник, а то и компьютерщик вообще, а лифты научились ездить вниз всего [три выпуска](https://linkmeup.ru/blog/14.html) назад. И в этом будничном мире кипят страсти: рвут оптику, вырубают питание, мыши перегрызают ножки процессоров (или это не в этом мире?) — иными словами, топология непрестанно меняется. И чем больше сеть, тем чаще и глобальнее изменения.  

Разумеется, было бы несколько странно ждать 40 секунд (Dead Interval) и только потом начинать перестраивать таблицу. Это было бы простительно ещё RIP’у, но не протоколу, который используется в огромном количестве современных сетей. Итак, как только падает какой-либо из линков (или несколько), маршрутизатор изменяет свою LSDB и генерирует LSU, присваивая ей номер больше, чем он был прежде (у каждой LSDB есть номер, который берётся из последнего полученного LSA).  

Это LSU сообщение рассылается на мультикастовый адрес 224.0.0.5\. Маршрутизаторы получившие его, проверяют номер LSA, содержащихся в LSU.  
1) Если номер больше, чем номер текущей LSA маршрутизатора — LSDB меняется. (Версия LSDB старая, информация новая),  
2) Если номер такой же, ничего не происходит. Этот маршрутизатор уже получил данный LSA по какому-то другому пути,  
3) Если номер полученного LSA меньше локальной LSDB, это означает, что у маршрутизатора уже более актуальная информация, и он посылает новый LSA (на основе своей LSDB) отправителю прежнего.  

После произведённых (или непроизведённых) действий соседу, от которого пришёл LSU пересылаются LSAck (мол, «посылку получили — всё в порядке»), а другим соседям отправляется изначальный LSU без изменений. На данном маршрутизаторе снова запускается алгоритм SPF и, при необходимости, обновляется таблица маршрутизации.  

В общем, всё это происходит в целях поддержания актуальности информации на всех устройствах — LSDB должна быть одинаковой у всех.  

> Тут надо оговориться, что маршрутизатор замечает изменения только при прямом подключении к своему соседу. Если между ними будет, например, коммутатор, то устройство не обнаружит падения физического интерфейса и ничего не будет делать. Для таких ситуаций есть два решения.  
> 1) Настроить таймеры. Для OSPF их можно уменьшить до уровня миллисекунд.  
> 2) Использовать очень крутой протокол BFD ([Bidirectional Forwarding Detection](http://en.wikipedia.org/wiki/Bidirectional_Forwarding_Detection)). Он позволяет отслеживать состояние линков также на миллисекундном уровне. В конфигурации BFD связывается с другими протоколами и позволяет очень быстро сообщить кому надо, что есть проблемы на сети. Конкретно с BFD мы будем разбираться в другой части.

Как вы заметили, на все сообщения есть подтверждения: либо это LSAck, либо ответ Hello на Hello. Это плата за отказ от TCP — как-то ведь надо убеждаться в успешной доставке.  

> Всего существует 7 типов LSA, которые тесно завязаны на зоны, коих тоже 5 штук. Маршрутизаторы тоже бывают четырёх типов. А так же есть понятия Designated Router (DR) и Backup DR (BDR), ABR и ASBR. Есть формулы расчёт метрик и прочее, прочее. Оставляем это на самостоятельное изучение.

##### Практика OSPF

Помните, как мы мучились, настраивая маршрутизацию в прошлый раз: на каждом устройстве до каждой сети и не дай бог что-нибудь забыть. Теперь это в прошлом — да здравствуют IGP!  
Не будем терять время, объясняя отдельно команды, а сразу окунёмся в удивительный мир конфигурации.  
Такс, имеет место сейчас следующая логическая схема:  

![](http://img-fotki.yandex.ru/get/6611/83739833.1f/0_9c86f_a16926ef_XL.jpg)  

Пока нас интересует вот это большое Сибирское кольцо через Красноярск, Хабаровск и Владивосток. Здесь и на нашей уже построенной сети мы запустим OSPF. Там, где прежде была статика, нам придётся от неё отказаться и плавно перейти на динамические протоколы.  
Предположим, что Красноярск у нас так же подключен через «Балаган телеком», как и предыдущие точки, а далее через разных провайдеров нам организованы линки к другим городам. Кольцо замыкается в Москве через провайдера “Филькин сертификат”. Предположим, что везде между городами у нас куплен L2-VPN и IP-трафик ходит прозрачно.  

Что внедрение IGP даст конкретно нашей сети?  
1) Простоту конфигурации, разумеется. На каждом узле нужно знать только локальные сети, вопросом их распространения озадачится OSPF.  
2) Избыточные линки, которые обеспечат нам резервирование каналов связи. Если, например, бомжи срежут оптику между Москвой и Красноярском, ни один филиал не останется без связи: весь трафик пойдёт через Владивосток  

![](http://img-fotki.yandex.ru/get/6410/83739833.1f/0_9cae9_6c74cdad_XL.jpg)  

3) Автоматическое обнаружение проблем, перестроение топологии и изменение таблицы маршрутизации. Именно это обеспечивает возможность выполнения пункта 2.  
4) Нет опасности создать петлю маршрутизации, когда пакет у нас будет метаться между двумя узлами, пока TTL не истечёт. При статической настройке такая ситуация более, чем возможна.  
5) Удобство расширения. Представьте, что вам нужно добавить новый филиал, например в Томске и подключать его будете через Кемерово. Тогда статические маршруты вам придётся прописывать в Москве, Кемерово и в самом Томске. При использовании динамики вы настраиваете только новый маршрутизатор… и всё.  

IP-план подсетей филиалов и линков Point-to-Point мы уже [подготовили](https://docs.google.com/spreadsheet/pub?key=0AooexOHebRpTdGc1eFhvZHdBa0ZrTUljRG5lYVVQM0E&output=html). Предположим, что и все начальные настройки тоже выполнили на всех узлах:  

*   hostname
*   параметры безопасности (пароли на телнет, ssh)
*   IP-адреса линковых интерфейсов
*   IP адреса подсетей LAN
*   IP-адреса Loopback-интерфейсов.

> Мы тут вводим новое понятие Loopback-интерфейса. Он будет сконфигурирован на каждом маршрутизаторе. Для этого выделена специальная подсеть 172.16.255.0/24\. Нужно оно нам сейчас для OSPF, а в будущем может понадобиться для BGP, MPLS.  
> Положа руку на сердце, сам долгое время не понимал значения этих интерфейсов. Вообще говоря, это виртуальный интерфейс, состояние которого всегда UP, независимо от состояния физических интерфейсов (если только на нём самом shutdown не выполнили). Попытаемся объяснить одну из его ролей:  
> Вот, к примеру, есть у вас сервер мониторинга Nagios. В нём вы завели для наблюдения маршрутизатор R1 и для связи с ним использовали адрес интерфейса FE0/0 — 10.1.0.1.  
>   
> ![](http://img-fotki.yandex.ru/get/6511/83739833.1f/0_9c863_4dcd7246_XL.jpg)  
>   
> На первый взгляд все прекрасно — всё работает. Но предположим теперь, что этот кабель порвали.  
>   
> ![](http://img-fotki.yandex.ru/get/6411/83739833.1f/0_9c864_4d813b1e_XL.jpg)  
>   
> Благодаря динамической маршрутизации, связь до роутера А не нарушится, и он будет доступен через FE0/1\. А в Nagios’е у вас будет авария, всё будет красное, повалятся смс и почта. При падении линка, IP-адрес этого интерфейса (10.1.0.1) становится недоступен.  
> А вот если вы настроите в Nagios’е адрес Loopback-интерфейса, то тем или иным путём он всегда будет доступен, опять же благодаря динамической маршрутизации.  
>   
> В качестве маски IP-адреса Loopback-интерфейса практически всегда выбирается /32, то есть 11111111.11111111.11111111.1111111 — один единственный адрес — а больше и не надо.

Поскольку все приготовления уже закончились, перед нами стоит очень простая задача: пройтись по всем маршрутизаторам и активировать процесс OSPF.  

1) Первое, что нам нужно сделать — запустить процесс OSPF маршрутизаторе:  

    msk-arbat-gw1(config)# router OSPF 1

Первым словом указываем, что запускаем протокол динамической маршрутизации, далее указываем какой именно и в последнюю очередь номер процесса (теоретически их может быть несколько на одном роутере).  

Сразу после этого автоматически назначается router ID. По умолчанию это наибольший адрес Loopbaсk-интерфейсов.  

2) Не оставляем это дело на самотёк. Главное правило: Router ID обязан быть уникальным. Нет, вы, конечно, можете их сделать и одинаковыми, но в этом случае у вас начнутся странности.  

> Одна из моих заявок была такой: на оборудовании заканчиваются метки LDP. Из 8 с гаком тысяч осталась только одна свободная. Никакие новые VPN не создавались и не работали. Разбирались, разбирались и в итоге увидели что процесс OSPF создаёт и удаляет тысячи записей в минуту в таблице маршрутизации. Топология постоянно перестраивается и на каждое такое перестроение выделяются новые метки LDP, после чего не освобождаются. А всё дело в случайно настроенных одинаковых Router ID.

Настраивать его можно, в принципе, как угодно, можно даже не настраивать, маршрутизатор назначит его сам, но для порядку мы это сделаем — в будущем обслуживать будет проще. Назначаем его в соответствии с адресом Loopback-интерфейса.  

    msk-arbat-gw1(config-router)#router-id 172.16.255.1

3) Теперь мы объявляем, какие сети мы будем анонсировать (передавать соседям OSPF). Обратите внимание, что в этой команде используется wildcard-маска, как в ACL  

    msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0 

Тут остановимся подробно. Командой **network** мы задаём не ту сеть, что будет вещать наш маршрутизатор, мы определяем интерфейсы, участвующие в процессе.  
Все интерфейсы маршрутизатора, IP адреса которых попадают в настроенный диапазон 172.16.0.0 0.0.255.255 (172.16.0.0-172.16.255.255), включатся в процесс.  
Это означает следующее:  
а) с данных интерфейсов будут рассылаться Hello-сообщения, через них будут устанавливаться отношения соседства и отправляться обновления о топологии сети.  
б) OSPF изучает подсети данных интерфейсов и именно их будет аносировать и следить за их состоянием. То есть не 172.16.0.0 0.0.255.255, как мы настроили, а те, что удовлетворяют этому диапазону  

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9cf8c_547f90dd_XL.jpg)  

В нашем случае не имеет значения как мы настроим:  

    msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0 

или  

    msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.15.255 area 0 

или  

    msk-arbat-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0 
    msk-arbat-gw1(config-router)#network 172.16.1.0 0.0.255.255 area 0 
    msk-arbat-gw1(config-router)#network 172.16.2.0 0.0.255.255 area 0 
    …..
    msk-arbat-gw1(config-router)#network 172.16.15.0 0.0.255.255 area 0 

Все эти команды сработают одинаково в нашем случае.  
Поскольку у нас все локальные сети имеют адреса из сети 172.16.0.0/16, то мы будем использовать наиболее общую запись. При этом туда, разумеется, не попадёт внешний интерфейс в интернет FastEthernet0/1.6, потому что его адрес — 198.51.100.2 — не из этого диапазона.  
При такой настройке любой новый интерфейс, на котором вы укажете адрес из диапазона 172.16.0.0 — 172.16.255.255, автоматически становится участником процесса OSPF. Плохо это или хорошо, зависит от ваших желаний.  
**area 0** означает принадлежность данных подсетей зоне с номером ноль (в наших примерах только такая и будет).  

> Area 0 это не простая зона — это так называемая Backbone-area. Это означает, что она объединяет все остальные зоны, т.е. пакет, идущий от любой ненулевой зоны в любую ненулевую, обязан проходить через area 0

Как только вы задали команду **network** с правильных интерфейсов слетают слова приветствия, но отвечать на них пока некому — соседей нет:  

    msk-arbat-gw1#sh ip OSPF neighbor 
    msk-arbat-gw1#

Теперь пропишем настройки OSPF в Кемерово (router ID=IP адрес Loopback интерфейса, взятый из IP-плана):  

    kmr-gorka-gw1(config)#router OSPF 1
    kmr-gorka-gw1(config-router)#router-id 172.16.255.48
    kmr-gorka-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0

И сразу после этого вы видите в консоли сообщение  

    02:27:33: %OSPF-5-ADJCHG: Process 1, Nbr 172.16.255.1 on FastEthernet0/0.5 from LOADING to FULL, Loading Done

Такое же показывает и маршрутизатор в Москве:  

    02:27:33: %OSPF-5-ADJCHG: Process 1, Nbr 172.16.255.48 on FastEthernet0/1.5 from LOADING to FULL, Loading Done.

Здесь вы можете видеть, что были успешно установлены отношения смежности и произошёл обмен LSA. Каждый маршрутизатор построил свою LSDB.  

Подробная информация по соседу:  

> msk-arbat-gw1#sh ip OSPF neighbor detail  
> Neighbor **172.16.255.48**, interface address **172.16.2.18**  
> In the area 0 via interface **FastEthernet0/1.5**  
> Neighbor priority is 1, State is **FULL**, 4 state changes  
> DR is 172.16.2.17 BDR is 172.16.2.18  
> Options is 0x00  
> **Dead timer due in 00:00:38**  
> Neighbor is up for 00:02:51  
> Index 1/1, retransmission queue length 0, number of retransmission 0  
> First 0x0(0)/0x0(0) Next 0x0(0)/0x0(0)  
> Last retransmission scan length is 0, maximum is 0  
> Last retransmission scan time is 0 msec, maximum is 0 msec

Тут вся ключевая информация о состоянии соседа:  
Его router-id (172.16.255.48), который суть loopback, адрес интерфейса удалённой стороны, через который установлено соседство (172.16.2.18), тип и номер физического интерфейса (FastEthernet0/1.5), текущий статус (FULL) и Dead timer. Последний не доходит до нуля, если вы за ним понаблюдаете. Его значение уменьшается, уменьшается, а потом Оп! и снова 40\. Это потому что каждые 10 секунд маршрутизаторы получают сообщения Hello и <s>обсороколяют</s> обнуляют Dead-интервал.  

Командой **show ip route** мы можем посмотреть, как изменилась таблица маршрутизации:  

> msk-arbat-gw1#show ip route  
> Codes: C — connected, S — static, I — IGRP, R — RIP, M — mobile, B — BGP  
> D — EIGRP, EX — EIGRP external, O — OSPF, IA — OSPF inter area  
> N1 — OSPF NSSA external type 1, N2 — OSPF NSSA external type 2  
> E1 — OSPF external type 1, E2 — OSPF external type 2, E — EGP  
> i — IS-IS, L1 — IS-IS level-1, L2 — IS-IS level-2, ia — IS-IS inter area  
> * — candidate default, U — per-user static route, o — ODR  
> P — periodic downloaded static route  
>   
> Gateway of last resort is 198.51.100.1 to network 0.0.0.0  
>   
> 172.16.0.0/16 is variably subnetted, 17 subnets, 5 masks  
> C 172.16.0.0/24 is directly connected, FastEthernet0/0.3  
> C 172.16.1.0/24 is directly connected, FastEthernet0/0.2  
> C 172.16.2.0/30 is directly connected, FastEthernet0/1.4  
> S 172.16.2.4/30 [1/0] via 172.16.2.2  
> C 172.16.2.16/30 is directly connected, FastEthernet0/1.5  
> C 172.16.2.32/30 is directly connected, FastEthernet0/1.7  
> C 172.16.2.128/30 is directly connected, FastEthernet0/1.8  
> C 172.16.2.196/30 is directly connected, FastEthernet1/0.911  
> C 172.16.3.0/24 is directly connected, FastEthernet0/0.101  
> C 172.16.4.0/24 is directly connected, FastEthernet0/0.102  
> C 172.16.5.0/24 is directly connected, FastEthernet0/0.103  
> C 172.16.6.0/24 is directly connected, FastEthernet0/0.104  
> S 172.16.16.0/21 [1/0] via 172.16.2.2  
> S 172.16.24.0/22 [1/0] via 172.16.2.18  
> **O 172.16.24.0/24 [110/2] via 172.16.2.18, 00:13:03, FastEthernet0/1.5**  
> C 172.16.255.1/32 is directly connected, Loopback0  
> **O 172.16.255.48/32 [110/2] via 172.16.2.18, 00:13:03, FastEthernet0/1.5**  
> 198.51.100.0/28 is subnetted, 1 subnets  
> C 198.51.100.0 is directly connected, FastEthernet0/1.6  
> S* 0.0.0.0/0 [1/0] via 198.51.100.1

Кроме известных ранее сетей (C — directly connected и S — Static) у нас появились два новых маршрута с пометкой O (OSPF). Тут всё должно быть понятно, но наблюдательный читатель спросит: “почему в таблице маршрутизации присутствуют два маршрута в сеть 172.16.24.0\. Почему не останется более предпочтительный статический?” и будет прав. Вообще говоря, в таблицу маршрутизации попадает только лучший маршрут до сети — по умолчанию один. Но обратите внимание, что статический Bidirectional Forwarding Detectionмаршрут идёт до подсети 172.16.24.0/22, а полученный от OSPF до 172.16.24.0/24\. Это разные подсети, поэтому обеим им нашлось место до солнцем. Дело в том, что OSPF понятия не имеет чего вы там напланировали и какой диапазон выделили — он оперирует реальными данными, то есть IP-адресом и маской:  

    interface FastEthernet0/0.2
    ip address 172.16.24.1 255.255.255.0

Что у нас творится в Кемерово:  

> kmr-gorka-gw1#sh ip route  
>   
> Gateway of last resort is 172.16.2.17 to network 0.0.0.0  
>   
> 172.16.0.0/16 is variably subnetted, 14 subnets, 3 masks  
> **O 172.16.0.0/24 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.1.0/24 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.2.0/30 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5**  
> C 172.16.2.16/30 is directly connected, FastEthernet0/0.5  
> **O 172.16.2.32/30 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.2.128/30 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.2.196/30 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.3.0/24 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.4.0/24 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.5.0/24 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5  
> O 172.16.6.0/24 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5**  
> C 172.16.24.0/24 is directly connected, FastEthernet0/0.2  
> **O 172.16.255.1/32 [110/2] via 172.16.2.17, 00:32:42, FastEthernet0/0.5**  
> C 172.16.255.48/32 is directly connected, Loopback0  
> S* 0.0.0.0/0 [1/0] via 172.16.2.17

Как видим, помимо настроенного прежде маршрута по умолчанию, тут появились все подсети из Москвы.  
Обратите внимание на цифры в квадратных скобках:  

> S* 0.0.0.0/0 [**1/0**]  
> O 172.16.6.0/24 [**110/2**]

Первая цифра — это административная дистанция, которая у OSPF значительно больше, чем у статики и, соответственно, приоритет ниже.  

На самом деле до подсети 172.16.24.0/24 трафик уже пошёл по маршруту предоставленному OSPF, потому что у него более узкая маска (24 против 22).  
Но попробуем удалить статические маршруты и посмотрим, что получится.  

Совершенно предсказуемо всё работает:  

    msk-arbat-gw1#ping 172.16.24.1

    Type escape sequence to abort.
    Sending 5, 100-byte ICMP Echos to 172.16.24.1, timeout is 2 seconds:
    !!!!!
    Success rate is 100 percent (5/5), round-trip min/avg/max = 8/10/15 ms

И это прекрасно.  
Настроим OSPF в Питере:  

    spb-vsl-gw1(config)#router OSPF 1
    spb-vsl-gw1(config-router)#router-id 172.16.255.32
    spb-vsl-gw1(config-router)#network 172.16.0.0 0.0.255.255 area 0

Настройки, как видите, везде предельно простые. При этом замечу, что номер процесса OSFP на разных маршрутизаторах не обязательно должен быть одинаковым, но лучше, если это будет так.  

На msk-arbat-gw1 у нас теперь два соседа  

    msk-arbat-gw1#sh ip OSPF neighbor 

    Neighbor ID Pri State Dead Time Address Interface
    172.16.255.32 1 FULL/DROTHER 00:00:39 172.16.2.2 FastEthernet0/1.4
    172.16.255.48 1 FULL/DROTHER 00:00:31 172.16.2.18 FastEthernet0/1.5

А вот в Питере (и в Кемерово) один:  

    spb-vsl-gw1#sh ip OSPF neighbor 

    Neighbor ID Pri State Dead Time Address Interface
    172.16.255.1 1 FULL/DR 00:00:34 172.16.2.1 FastEthernet1/0.4

Дело в том, что отношения смежности устанавливаются только между непосредственно подключенными устройствами (коммутаторы между ними не считаются), а spb-vsl-gw1 коммуницирует с kmr-gorka-gw1 через msk-arbat-gw1, поэтому их нет в соседях друг у друга.  

Последний оплот консерватизма — spb-ozerki-gw1 сдастся вам без особых проблем, как и три маршрутизатора Сибирского кольца. Делается всё по аналогии — по сути меняется только Router ID. И не забудьте удалить статические маршруты.  

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)
**Задача №1**](https://linkmeup.ru/blog/17.html)  
Между маршрутизаторами в Питере надо уменьшить время обнаружения пропажи соседа. Маршрутизаторы должны отправлять сообщения Hello каждые 3 секунды, и считать друг друга недоступными, если 12 секунд не было сообщение Hello от соседа.  
[Ответ](https://linkmeup.ru/blog/17.html)  

**Общий совет по всем задачам:**  

> Даже если Вы сразу не знаете ответа и решения, постарайтесь подумать к чему относится условие задачи:  
> — К каким особенностям, настройкам протокола?  
> — Глобальные эти настройки или привязаны к конкретному интерфейсу?  
> Если Вы не знаете или забыли команду, такие размышления, скорее всего, приведут Вас к правильному контексту, где Вы просто, с помощью подсказки в командной строке, можете догадаться или вспомнить как настроить то, что требуется в задании.  
> Постарайтесь поразмышлять в таком ключе прежде чем пойдете в гугл или на какой-то сайт в поиске команд.

На реальной сети при выборе диапазона анонсируемых подсетей нужно руководствоваться регламентом и насущными потребностями.  

Прежде чем мы перейдём к тестированию резервных линков и скорости, сделаем ещё одну полезную вещь.  
Если бы у нас была возможность отловить трафик на интерфейсе FE0/0.2 msk-arbat-gw1, который смотрит в сторону серверов, то мы бы увидели, что каждые 10 секунд в неизвестность улетают сообщения Hello. Ответить на Hello некому, отношения смежности устанавливать не с кем, поэтому и пытаться рассылать отсюда сообщения смысла нет.  
Выключается это очень просто:  

    msk-arbat-gw1(config)#router OSPF 1
    msk-arbat-gw1(config-router)#passive-interface fastEthernet 0/0.2 

Такую команду нужно дать для всех интерфейсов, на которых точно нет соседей OSPF (в том числе в сторону интернета).  
В итоге картина у вас будет такая:  

![](http://img-fotki.yandex.ru/get/6423/83739833.1f/0_9da8b_920c7b5b_XL.jpg)  
*Не представляю, как вы до сих пор не запутались*  

Кроме того, эта команда повышает безопасность — никто из этой сети не прикинется маршрутизатором и не будет пытаться поломать нас полностью.  

Теперь займёмся самым интересным — тестированием.  
Ничего сложного нет в настройке OSPF на всех маршрутизаторах в Сибирском кольце — сделаете сами.  
И после этого картина должна быть следующей:  

    msk-arbat-gw1#sh ip OSPF neighbor 

    Neighbor ID Pri State Dead Time Address Interface
    172.16.255.32 1 FULL/DR 00:00:31 172.16.2.2 FastEthernet0/1.4
    172.16.255.48 1 FULL/DR 00:00:31 172.16.2.18 FastEthernet0/1.5
    172.16.255.80 1 FULL/BDR 00:00:36 172.16.2.130 FastEthernet0/1.8
    172.16.255.112 1 FULL/BDR 00:00:37 172.16.2.197 FastEthernet1/0.911

Питер, Кемерово, Красноярск и Владивосток — непосредственно подключенные.  

> msk-arbat-gw1#show ip route  
>   
> Gateway of last resort is 198.51.100.1 to network 0.0.0.0  
>   
> 172.16.0.0/16 is variably subnetted, 25 subnets, 6 masks  
> C 172.16.0.0/24 is directly connected, FastEthernet0/0.3  
> C 172.16.1.0/24 is directly connected, FastEthernet0/0.2  
> C 172.16.2.0/30 is directly connected, FastEthernet0/1.4  
> S 172.16.2.4/30 [1/0] via 172.16.2.2  
> C 172.16.2.16/30 is directly connected, FastEthernet0/1.5  
> C 172.16.2.32/30 is directly connected, FastEthernet0/1.7  
> C 172.16.2.128/30 is directly connected, FastEthernet0/1.8  
> O 172.16.2.160/30 [110/2] via 172.16.2.130, 00:05:53, FastEthernet0/1.8  
> O 172.16.2.192/30 [110/2] via 172.16.2.197, 00:04:18, FastEthernet1/0.911  
> C 172.16.2.196/30 is directly connected, FastEthernet1/0.911  
> C 172.16.3.0/24 is directly connected, FastEthernet0/0.101  
> C 172.16.4.0/24 is directly connected, FastEthernet0/0.102  
> C 172.16.5.0/24 is directly connected, FastEthernet0/0.103  
> C 172.16.6.0/24 is directly connected, FastEthernet0/0.104  
> S 172.16.16.0/21 [1/0] via 172.16.2.2  
> S 172.16.24.0/22 [1/0] via 172.16.2.18  
> O 172.16.24.0/24 [110/2] via 172.16.2.18, 00:24:03, FastEthernet0/1.5  
> O 172.16.128.0/24 [110/2] via 172.16.2.130, 00:07:18, FastEthernet0/1.8  
> O 172.16.129.0/26 [110/2] via 172.16.2.130, 00:07:18, FastEthernet0/1.8  
> C 172.16.255.1/32 is directly connected, Loopback0  
> O 172.16.255.32/32 [110/2] via 172.16.2.2, 00:24:03, FastEthernet0/1.4  
> O 172.16.255.48/32 [110/2] via 172.16.2.18, 00:24:03, FastEthernet0/1.5  
> O 172.16.255.80/32 [110/2] via 172.16.2.130, 00:07:18, FastEthernet0/1.8  
> O 172.16.255.96/32 [110/3] via 172.16.2.130, 00:04:18, FastEthernet0/1.8  
> [110/3] via 172.16.2.197, 00:04:18, FastEthernet1/0.911  
> O 172.16.255.112/32 [110/2] via 172.16.2.197, 00:04:28, FastEthernet1/0.911  
> 198.51.100.0/28 is subnetted, 1 subnets  
> C 198.51.100.0 is directly connected, FastEthernet0/1.6  
> S* 0.0.0.0/0 [1/0] via 198.51.100.1

Все обо всех всё знают.  
Каким маршрутом трафик доставляется из Москвы в Красноярск? Из таблицы видно, что krs-stolbi-gw1 подключен напрямую и это же видно из трассировки:  

![](http://img-fotki.yandex.ru/get/6511/83739833.1f/0_9c868_9702fcf4_XL.jpg)  

    msk-arbat-gw1#traceroute 172.16.128.1
    Type escape sequence to abort.
    Tracing the route to 172.16.128.1

    1 172.16.2.130 35 msec 8 msec 5 msec 

Теперь рвём интерфейс между Москвой и Красноярском и смотрим, через сколько линк восстановится.  
Не проходит и 5 секунд, как все маршрутизаторы узнали о происшествии и пересчитали свои таблицы маршрутизации:  

    msk-arbat-gw1(config-subif)#do sh ip ro 172.16.128.0
    Routing entry for 172.16.128.0/24
    Known via "OSPF 1", distance 110, metric 4, type intra area
    Last update from 172.16.2.197 on FastEthernet1/0.911, 00:00:53 ago
    Routing Descriptor Blocks:
    * 172.16.2.197, from 172.16.255.80, 00:00:53 ago, via FastEthernet1/0.911
    Route metric is 4, traffic share count is 1

    vld-gw1#sh ip route 172.16.128.0
    Routing entry for 172.16.128.0/24
    Known via "OSPF 1", distance 110, metric 3, type intra area
    Last update from 172.16.2.193 on FastEthernet1/0, 00:01:57 ago
    Routing Descriptor Blocks:
    * 172.16.2.193, from 172.16.255.80, 00:01:57 ago, via FastEthernet1/0
    Route metric is 3, traffic share count is 1

    msk-arbat-gw1#traceroute 172.16.128.1
    Type escape sequence to abort.
    Tracing the route to 172.16.128.1

    1 172.16.2.197 4 msec 10 msec 10 msec 
    2 172.16.2.193 8 msec 11 msec 15 msec 
    3 172.16.2.161 15 msec 13 msec 6 msec 

То есть теперь Красноярска трафик достигает таким путём:  

![](http://img-fotki.yandex.ru/get/6613/83739833.1f/0_9c869_7d771721_XL.jpg)  

Как только вы поднимете линк, маршрутизаторы снова вступают в связь, обмениваются своими базами, пересчитываются кратчайшие пути и заносятся в таблицу маршрутизации.  
На видео всё это более наглядно. Рекомендую [ознакомиться](http://www.youtube.com/watch?v=8zxdW6ag8Us).  
[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №2**](https://linkmeup.ru/blog/20.html)  
После настройки OSPF на маршрутизаторах в сибирском кольце, все сети, которые находятся за маршрутизатором в центральном офисе в Москве (msk-arbat-gw1), для Хабаровска доступны по двум маршрутам (через Красноярск и через Владивосток). Но, так как канал через Красноярск лучше, то надо изменить настройки по умолчанию таким образом, чтобы Хабаровск использовал канал через Красноярск, когда он доступен. И переключался на Владивосток только если что-то случилось с каналом на Красноярск.  
[Ответ](https://linkmeup.ru/blog/20.html)  

Как любой хороший протокол, OSPF поддерживает аутентификацию — два соседа перед установлением соотношений соседства могут проверять подлинность полученных OSPF-сообщений. Оставляем на самостоятельное изучение — довольно просто.  

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №3**](https://linkmeup.ru/blog/24.html)  
С провайдером «Филькин сертификат» случилась неприятная история. Из-за их ошибки в настройках VPN на маршрутизатор во Владивостоке начали приходить какие-то непонятные маршруты, вероятно, от другого клиента или внутренние самого сети провайдера. Некоторые сети пересекались с локальными сетями и была потеряна связь с некоторыми участками сети. После этого случая было решено защититься на будущее от подобных ситуаций.  
Ситуация, вообще говоря, надуманная и маловероятная, но в качестве задачки подойдёт.  
На участке между Москвой и Владивостоком необходимо настроить маршрутизаторы таким образом, чтобы они, при установке отношений соседства, проверяли ещё и установленный пароль. Пароль должен быть: MskVladPass и передаваться он должен в виде хеша md5 (номер ключа 1).  
[Ответ](https://linkmeup.ru/blog/24.html)  

#### EIGRP

Теперь займёмся другим очень важным протоколом  

Итак, чем хорош EIGRP?  
— прост в конфигурации  
— быстрое переключение на **заранее просчитанный** запасной маршрут  
— требует меньше ресурсов роутера (по сравнению с OSPF)  
— суммирование маршрутов на любом роутере (в OSPF только на ABR\ASBR)  
— балансировка трафика на неравноценных маршрутах (OSPF только на равноценных)  

> Мы решили перевести одну из [записей](http://blog.ioshints.info/2010/08/EIGRP-myths-debunked.html) блога Ивана Пепельняка, в которой разбирается ряд популярных мифов про EIGRP:  
> — “EIGRP это гибридный протокол маршрутизации”. Если я правильно помню, это началось с первой презентации EIGRP много лет назад и обычно понимается как «EIGRP взял лучшее от link-state и distance-vector протоколов». Это совершенно не так. У EIGRP нет никаких отличительных особенностей link-state. Правильно будет говорить «EIGRP это продвинутый distance-vector- протокол маршрутизации».  
> — “EIGRP это distance-vector протокол”. Неплохо, но не до конца верно тоже. EIGRP отличается от других DV способом, которым обрабатывает потерянные маршруты (или маршруты с возрастающей метрикой). Все остальные протоколы пассивно ждут обновления информации от соседа (некоторые, например, RIP, даже блокируют маршрут для предотвращения петель маршрутизации), в то время как EIGRP ведет себя активнее и запрашивает информацию сам.  
> — “EIGRP сложен во внедрении и обслуживании”. Неправда. В свое время, EIGRP в больших сетях с низкоскоростными линками было сложновато правильно внедрить, но ровно до того момента, как были введены stub routers. С ними (а также несколькими исправлениями работы DUAL-алгоритма), он не чуть не хуже, чем OSPF.  
> — “Как и LS протоколы, EIGRP хранит таблицу топологии маршрутов, которыми обменивается”. Просто удивительно, насколько это неверно. EIGRP не имеет вообще никакого понятия о том, что находится дальше ближайших соседей, в то время как LS протоколы точно знают топологию всей области, к которой они подключены.  
> — “EIGRP это DV протокол, который действует, как LS”. Неплохая попытка, но по-прежнему, абсолютно неверно. LS протоколы строят таблицу маршрутизации, проходя через следующие шаги:  
> — каждый маршрутизатор описывает сеть, исходя из информации, доступной ему локально (его линки, подсети, в которых он находится, соседи, которых он видит) посредством пакета (или нескольких), называемого LSA (в OSPF) или LSP (IS-IS)  
> — LSA распространяются по сети. Каждый маршрутизатор должен получить каждую LSA, созданную в его сети. Информация, полученная из LSA, заносится в таблицу топологии.  
> — каждый маршрутизатор независимо анализирует свою таблицу топологии и запускает SPF алгоритм для подсчета лучших маршрутов к каждому из других маршрутизаторов  
> Поведение EIGRP даже близко не напоминает эти шаги, поэтому непонятно, с какой стати он «действует, как LS»  
>   
> Единственное, что делает EIGRP — это хранит информацию, полученную от соседа (RIP сразу же забывает то, что не может быть использовано в данный момент). В этом смысле, он похож на BGP, который тоже хранит все в таблице BGP и выбирает лучший маршрут оттуда. Таблица топологии (содержащая всю информацию, полученную от соседей), дает EIGRP преимущество перед RIP – она может содержать информацию о запасном (не используемом в данный момент) маршруте.

Теперь чуть ближе к теории работы:  

Каждый процесс EIGRP обслуживает 3 таблицы:  
— Таблицу соседей (neighbor table), в которой содержится информация о “соседях”, т.е. других маршрутизаторах, непосредственно подключенных к текущему и участвующих в обмене маршрутами. Можно посмотреть с помощью команды **show ip eigrp neighbors**  
— Таблицу топологии сети (topology table), в которой содержится информация о маршрутах, полученная от соседей. Смотрим командой **show ip eigrp topology**  
— Таблицу маршрутизации (routing table), на основе которой роутер принимает решения о перенаправлении пакетов. Просмотр через **show ip route**  

Метрика.  
Для оценки качества определенного маршрута, в протоколах маршрутизации используется некое число, отражающее различные его характеристики или совокупность характеристик- метрика. Характеристики, принимаемые в расчет, могут быть разными- начиная от количества роутеров на данном маршруте и заканчивая средним арифметическим загрузки всех интерфейсов по ходу маршрута. Что касается метрики EIGRP, процитируем Jeremy Cioara: “у меня создалось впечатление, что создатели EIGRP, окинув критическим взглядом свое творение, решили, что все слишком просто и хорошо работает. И тогда они придумали формулу метрики, что бы все сказали “ВАУ, это действительно сложно и профессионально выглядит”. Узрите же полную формулу подсчета метрики EIGRP: (K1 * bw + (K2 * bw) / (256 — load) + K3 * delay) * (K5 / (reliability + K4)), в которой:  
— bw это не просто пропускная способность, а (10000000/самая маленькая пропускная способность по дороге маршрута в килобитах) * 256  
— delay это не просто задержка, а сумма всех задержек по дороге в **десятках микросекунд** * 256 (delay в командах show interface, show ip eigrp topology и прочих показывается в микросекундах!)  
— K1-K5 это коэффициенты, которые служат для того, чтобы в формулу “включился” тот или иной параметр.  

Страшно? было бы, если бы все это работало, как написано. На деле же из всех 4 возможных слагаемых формулы, по умолчанию используются только два: bw и delay (коэффициенты K1 и K3=1, остальные нулю), что сильно ее упрощает — мы просто складываем эти два числа (не забывая при этом, что они все равно считаются по своим формулам). Важно помнить следующее: метрика считается по **худшему показателю пропускной способности по всей длине маршрута**.  
Если K5=0, то используется следующая формула: Metric = (K1 * bw + (K2 * bw) / (256 — load) + (K3 * delay)  

> Интересная штука получилась с MTU: довольно часто можно встретить сведения о том, что MTU имеет отношение к метрике EIGRP. И действительно, значения MTU передаются при обмене маршрутами. Но, как мы можем видеть из полной формулы, никакого упоминания об MTU там нет. Дело в том, что этот показатель принимается в расчет в довольно специфических случаях: например, если роутер должен отбросить один из равнозначных по остальным характеристикам маршрутов, он выберет тот, у которого меньший MTU. Хотя, [не все так просто](http://blog.ioshints.info/2010/06/eigrp-mtu-metric.html) (см. комментарии).

Определимся с терминами, применяемыми внутри EIGRP. Каждый маршрут в EIGRP характеризуется двумя числами: Feasible Distance и Advertised Distance (вместо Advertised Distance иногда можно встретить Reported Distance, это одно и то же). Каждое из этих чисел представляет собой метрику, или стоимость (чем больше-тем хуже) данного маршрута с разных точек измерения: FD это “от меня до места назначения”, а AD- “от соседа, который мне рассказал об этом маршруте, до места назначения”. Ответ на закономерный вопрос “Зачем нам надо знать стоимость от соседа, если она и так включена в FD?”- чуть ниже (пока можете остановиться и поломать голову сами, если хотите).  

У каждой подсети, о которой знает EIGRP, на каждом роутере существует Successor- роутер из числа соседей, через который идет лучший (с меньшей метрикой), по мнению протокола, маршрут к этой подсети. Кроме того, у подсети может также существовать один или несколько запасных маршрутов (роутер-сосед, через которого идет такой маршрут, называется Feasible Successor). EIGRP- единственный протокол маршрутизации, запоминающий запасные маршруты (в OSPF они есть, но содержатся, так сказать, в “сыром виде” в таблице топологии- их еще надо обработать алгоритмом SPF), что дает ему плюс в быстродействии: как только протокол определяет, что основной маршрут (через successor) недоступен, он сразу переключается на запасной. Для того, чтобы роутер мог стать feasible successor для маршрута, его AD должно быть меньше FD successor’а этого маршрута (вот зачем нам нужно знать AD). Это правило применяется для того, чтобы избежать колец маршрутизации.  

Предыдущий абзац взорвал мозг? Материал трудный, поэтому еще раз на примере. У нас есть вот такая сеть:  

![](http://img-fotki.yandex.ru/get/6419/83739833.20/0_9e454_30108738_L.jpg)  

С точки зрения R1, R2 является Successor’ом для подсети 192.168.2.0/24\. Чтобы стать FS для этой подсети, R4 требуется, чтобы его AD была меньше FD для этого маршрута. FD у нас ((10000000/1544)*256)+(2100*256) =2195456, AD у R4 (с его точки зрения это FD, т.е. сколько ему стоит добраться до этой сети) = ((10000000/100000)*256)+(100*256)=51200\. Все сходится, AD у R4 меньше, чем FD маршрута, он становится FS. *тут мозг такой и говорит: “БДЫЩЬ”*. Теперь смотрим на R3- он анонсирует свою сеть 192.168.1.0/24 соседу R1, который, в свою очередь, рассказывает о ней своим соседям R2 и R4\. R4 не в курсе, что R2 знает об этой подсети, и решает ему рассказать. R2 передает информацию о том, что он имеет доступ через R4 к подсети 192.168.1.0/24 дальше, на R1\. R1 строго смотрит на FD маршрута и AD, которой хвастается R2 (которая, как легко понять по схеме, будет явно больше FD, так как включает и его тоже) и прогоняет его, чтобы не лез со всякими глупостями. Такая ситуация довольно маловероятна, но может иметь место при определенном стечении обстоятельств, например, при отключении механизма “расщепления горизонта” (split-horizon). А теперь к более вероятной ситуации: представим, что R4 подключен к сети 192.168.2.0/24 не через FastEthernet, а через модем на 56k (задержка для dialup составляет 20000 usec), соответственно, добраться ему стоит ((10000000/56)*256)+(2000*256)= 46226176\. Это больше, чем FD для этого маршрута, поэтому R4 не станет Feasible Successor’ом. Но это не значит, что EIGRP вообще не будет использовать данный маршрут. Просто переключение на него займет больше времени (подробнее об этом дальше).  

###### Соседство

Роутеры не разговаривают о маршрутах с кем попало — прежде чем начать обмениваться информацией, они должны установить отношения соседства. После включения процесса командой router eigrp с указанием номера автономной системы, мы, командой network говорим, какие интерфейсы будут участвовать и одновременно, информацию о каких сетях мы желаем распространять. Незамедлительно, через эти интерфейсы начинают рассылаться hello-пакеты на мультикаст- адрес 224.0.0.10 (по умолчанию каждые 5 секунд для ethernet). Все маршрутизаторы с включенным EIGRP получают эти пакеты, далее каждый маршрутизатор-получатель делает следующее:  
— сверяет адрес отправителя hello-пакета, с адресом интерфейса, из которого получен пакет, и удостоверяется, что они из одной подсети  
— сверяет значения полученных из пакета K-коэффициентов (проще говоря, какие переменные используются в подсчете метрики) со своими. Понятно, что если они различаются, то метрики для маршрутов будут считаться по разным правилам, что недопустимо  
— проверяет номер автономной системы  
— опционально: если настроена аутентификация, проверяет соответствие ее типа и ключей.  

Если получателя все устраивает, он добавляет отправителя в список своих соседей, и посылает ему (уже юникастом) update-пакет, в котором содержится список всех известных ему маршрутов (aka full-update). Отправитель, получив такой пакет, в свою очередь, делает то же самое. Для обмена маршрутами EIGRP использует Reliable Transport Protocol (RTP, не путать с Real-time Transport Protocol, который используется в ip-телефонии), который подразумевает подтверждение о доставке, поэтому каждый из роутеров, получив update- пакет, отвечает ack -пакетом (сокращение от acknowledgement- подтверждение). Итак, отношение соседства установлены, роутеры узнали друг у друга исчерпывающую информацию о маршрутах, что дальше? Дальше они будут продолжать посылать мультикаст hello-пакеты в подтверждение того, что они на связи, а в случае изменения топологии- update-пакеты, содержащие сведения только об изменениях (partial update).  

Теперь вернемся к предыдущей схеме с модемом.  

![](http://img-fotki.yandex.ru/get/6423/83739833.20/0_9ed88_746dfb1e_XL.jpg)  

R2 по каким-то причинам потерял связь с 192.168.2.0/24\. До этой подсети у него нет запасных маршрутов (т.е. отсутствует FS). Как всякий ответственный роутер с EIGRP, он хочет восстановить связь. Для этого он начинает рассылать специальные сообщения (query- пакеты) всем своим соседям, которые, в свою очередь, не находя нужного маршрута у себя, расспрашивают всех своих соседей, и так далее. Когда волна запросов докатывается до R4, он говорит “погодите-ка, у меня есть маршрут к этой подсети! Плохонький, но хоть что-то. Все про него забыли, а я-то помню”. Все это он упаковывает в reply-пакет и отправляет соседу, от которого получил запрос (query), и дальше по цепочке. Понятное дело, это все занимает больше времени, чем просто переключение на Feasible Successor, но, в итоге, мы получаем связь с подсетью.  

А сейчас опасный момент: может, вы уже обратили внимание и насторожились, прочитав момент про эту веерную рассылку. Падение одного интерфейса вызывает нечто похожее на широковещательный шторм в сети (не в таких масштабах, конечно, но все-таки), причем чем больше в ней роутеров, тем больше ресурсов потратится на все эти запросы-ответы. Но это еще пол-беды. Возможна ситуация и похуже: представим, что роутеры, изображенные на картинке- это только часть большой и распределенной сети, т.е. некоторые могут находится за много тысяч километров от нашего R2, на плохих каналах и прочее. Так вот, беда в том, что, послав query соседу, роутер обязан дождаться от него reply. Неважно, что в ответе- но он должен прийти. Даже если роутер **уже** получил положительный ответ, как в нашем случае, он не может поставить этот маршрут в работу, пока не дождется ответа на все свои запросы. А запросы-то, может, еще где-нибудь на Аляске бродят. Такое состояние маршрута называется stuck-in-active. Тут нам нужно познакомится с терминами, отражающими состояние маршрута в EIGRP: active\passive route. Обычно они вводят в заблуждение. Здравый смысл подсказывает, что active значит маршрут “активен”, включен, работает. Однако тут все наоборот: passive это “все хорошо”, а состояние active означает, что данная подсеть недоступна, и маршрутизатор находится в активном поиске другого маршрута, рассылая query и ожидая reply. Так вот, состояние stuck-in-active (застрял в активном состоянии) может продолжатся до 3 минут! По истечение этого срока, роутер обрывает отношения соседства с тем соседом, от которого он не может дождаться ответа, и может использовать новый маршрут через R4\. [Подробно о проблеме](http://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a008010f016.shtml)  

История, леденящая кровь сетевого инженера. 3 минуты даунтайма это не шутки. Как мы можем избежать <s>инфаркта</s> этой ситуации? Выхода два: суммирование маршрутов и так называемая stub-конфигурация.  

> Вообще говоря, есть еще один выход, и он называется фильтрация маршрутов (route filtering). Но это настолько объемная тема, что впроу отдельную статью под нее писать, а у нас и так уже пол-книги получилось в этот раз. Поэтому на ваше усмотрение.

Как мы уже упоминали, в EIGRP суммирование маршрутов можно проводить на любом роутере. Для иллюстрации, представим, что к нашему многострадальному R2 подключены подсети от 192.168.0.0/24 до 192.168.7.0/24, что очень удобненько суммируется в 192.168.0.0/21 (вспоминаем [binary math](http://habrahabr.ru/post/129664/)). Роутер анонсирует этот суммарный маршрут, и все остальные знают: если адрес назначения начинается на 192.168.0-7, то это к нему. Что будет происходить, если одна из подсетей пропадет? Роутер будет рассылать query-пакеты с адресом этой сети (конкретным, например, 192.168.5.0/24), но соседи, вместо того, чтобы уже от своего имени продолжить порочную рассылку, будут сразу в ответ слать отрезвляющие реплаи, мол, это твоя подсеть, ты и разбирайся.  

Второй вариант- stub- конфигурация. Образно говоря, stub означает “конец пути”, “тупик” в EIGRP, т.е., чтобы попасть в какую-то подсеть, не подключенную **напрямую** к такому роутеру, придется идти назад. Роутер, сконфигурированный, как stub, не будет пересылать трафик между подсетями, которые ему стали известны от EIGRP (проще говоря, которые в show ip route помечены буквой D). Кроме того, его соседи не будут отправлять ему query-пакеты. Самый распространенный случай применения- hub-and-spoke топологии, особенно с избыточными линками. Возьмем такую сеть: слева- филиалы, справа- основной сайт, главный офис и т.п. Для отказоустойчивости избыточные линки. Запущен EIGRP с дефолтными настройками.  

![](http://img-fotki.yandex.ru/get/6423/83739833.20/0_9eab6_728d6664_XL.jpg)  

А теперь “внимание, вопрос”: что будет, если R1 потеряет связь с R4, а R5 потеряет LAN? Трафик из подсети R1 в подсеть главного офиса будет идти по маршруту R1->R5->R2(или R3)->R4\. Будет это эффективно? Нет. Будет страдать не только подсеть за R1, но и подсеть за R2 (или R3), из-за увеличения объемов трафика и его последствий. Вот для таких-то ситуаций и придуман stub. За роутерами в филиалах нет других роутеров, которые вели бы в другие подсети, это “конец дороги”, дальше только назад. Поэтому мы с легким сердцем можем сконфигурировать их как stub’ы, что, во-первых, избавит нас от проблемы с “кривым маршрутом”, изложенной чуть выше, а во-вторых, от флуда query-пакетов в случае потери маршрута.  

Существуют различные режимы работы stub-роутера, задаются они командой eigrp stub:  

> R1(config)#router eigrp 1  
> R1(config-router)#eigrp stub?  
> connected Do advertise connected routes  
> leak-map Allow dynamic prefixes based on the leak-map  
> receive-only Set IP-EIGRP as receive only neighbor  
> redistributed Do advertise redistributed routes  
> static Do advertise static routes  
> summary Do advertise summary routes

По умолчанию, если просто дать команду eigrp stub, включаются режимы сonnected и summary. Интерес представляет режим receive-only, в котором роутер не анонсирует никаких сетей, только слушает, что ему говорят соседи (в RIP есть команда passive interface, которая делает то же самое, но в EIGRP она полностью отключает протокол на выбранном интерфейсе, что не позволяет установить соседство).  

Важные моменты в теории EIGRP, не попавшие в статью:  

*   В EIGRP можно настроить [аутентификацию](http://www.cisco.com/en/US/tech/tk365/technologies_configuration_example09186a00807f5a63.shtml) соседей
*   Концепция [graceful shutdown](http://blog.ioshints.info/2007/03/eigrp-goodbye-message.html)
*   [Балансировка нагрузки](http://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a008009437d.shtml)

##### Практика EIGRP

“Лифт ми Ап” купили фабрику в Калининграде. Там производят мозги лифтов: микросхемы, ПО. Фабрика очень крупная — три точки по городу — три маршрутизатора соединены в кольцо.  

![](http://img-fotki.yandex.ru/get/6510/83739833.1f/0_9c886_5ef640c3_XL.jpg)  

Но вот незадача — на них уже запущен EIGRP в качестве протокола динамической маршрутизации. Причём адресация конечных узлов совсем из другой подсети — 10.0.0.0/8\. Все другие параметры (линковые адреса, адреса лупбэк интерфейсов) мы поменяли, но несколько тысяч адресов локальной сети с серверами, принтерами, точками доступа — работа не на пару часов — отложили на потом, а в IP-плане зарезервировали на будущее для Калининграда подсеть 172.16.32.0/20.  

Сейчас у нас используются такие сети:  

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9db51_8e454e39_XL.jpg)  

![](http://img-fotki.yandex.ru/get/6620/83739833.1f/0_9dbbc_b8016659_XL.jpg)  

Как настраивается это чудо? Незамысловато, на первый взгляд:  

    router eigrp 1
    network 172.16.0.0 0.0.255.255
    network 10.0.0.0

В EIGRP обратную маску можно задавать, указывая тем самым более узкие рамки, либо не задавать, тогда будет выбрана стандартная маска для этого класса (16 для класса B — 172.16.0.0 и 8 для класса А — 10.0.0.0)  

Такие команды даются на всех маршрутизаторах Автономной Системы. АС определяется цифрой в команде router eigrp, то есть в нашем случае имеем АС №1\. Эта цифра должна быть одинаковой на всех маршрутизаторах (в отличии от OSPF).  

Но есть в EIGRP серьёзный подвох: по умолчанию включено автоматическое суммирование маршрутов в классовом виде (в версиях IOS до 15).  
Сравним таблицы маршрутизации на трёх калининградских маршрутизаторах:  

Сеть 10.0.0.1/24 подключена у нас к klgr-center-gw1 и он о ней знает:  

    klgr-center-gw1:
    10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
    D 10.0.0.0/8 is a summary, 00:35:23, Null0
    C 10.0.0.0/24 is directly connected, FastEthernet1/0

Но не знает о 10.0.1.0/24 и 10.0.2.0/24/  

klgr-balt-gw1 знает о своих двух сетях 10.0.1.0/24 и 10.0.2.0/24, но вот сеть 10.0.0.0/24 он куда-то спрятал.  

    10.0.0.0/8 is variably subnetted, 3 subnets, 2 masks
    D 10.0.0.0/8 is a summary, 00:42:05, Null0
    C 10.0.1.0/24 is directly connected, FastEthernet1/1.2
    C 10.0.2.0/24 is directly connected, FastEthernet1/1.3

Они оба создали маршрут 10.0.0.0/8 с адресом next hop Null0\.  

А вот klgr-center-gw2 знает, что подсети 10.0.0.0/8 находятся за обоими его WAN интерфейсами.  

    D 10.0.0.0/8 [90/30720] via 172.16.2.41, 00:42:49, FastEthernet0/1
    [90/30720] via 172.16.2.45, 00:38:05, FastEthernet0/0

Что-то очень странное творится.  
Но, если вы проверите конфигурацию этого маршрутизатора, то, вероятно, заметите:  

    router eigrp 1
    network 172.16.0.0
    network 10.0.0.0
    auto-summary

Во всём виновато автоматическое суммирование. Это самое большое зло EIGRP. Рассмотрим более подробно, что происходит. klgr-center-gw1 и klgr-balt-gw1 имеют подсети из 10.0.0.0/8, они их суммируют по умолчанию, когда передают соседям.  
То есть, например, klgr-balt-gw1 передаёт не две сети 10.0.1.0/24 и 10.0.2.0/24, а одну обобщённую: 10.0.0.0/8\. То есть его сосед будет думать, что за klgr-balt-gw1 находится вся эта сеть.  
Но, что произойдёт, если вдруг на balt-gw1 попадёт пакет с адресатом 10.0.50.243, о котором тот ничего не знает? На этот случай и создаётся так называетмый Blackhole-маршрут:  
10.0.0.0/8 is a summary, 00:42:05, Null0  
Полученный пакет будет выброшен в эту чёрную дыру. Это делается во избежание петель маршрутизации.  
Так вот оба эти маршрутизатора создали свои blackhole-маршруты и игнорируют чужие анонсы. Реально на такой сети эти три девайса друг друга так и не смогут пинговать, пока… пока вы не отключите auto-summary.  

Первое, что вы должны сделать при настройке EIGRP:  

    router eigrp 1
    no auto-summary

На всех устройствах. И всем будет хорошо:  

klgr-center-gw1:  

    10.0.0.0/24 is subnetted, 3 subnets
    C 10.0.0.0 is directly connected, FastEthernet1/0
    D 10.0.1.0 [90/30720] via 172.16.2.37, 00:03:11, FastEthernet0/0
    D 10.0.2.0 [90/30720] via 172.16.2.37, 00:03:11, FastEthernet0/0

klgr-balt-gw1  

    10.0.0.0/24 is subnetted, 3 subnets
    D 10.0.0.0 [90/30720] via 172.16.2.38, 00:08:16, FastEthernet0/1
    C 10.0.1.0 is directly connected, FastEthernet1/1.2
    C 10.0.2.0 is directly connected, FastEthernet1/1.3

klgr-center-gw2:  

    10.0.0.0/24 is subnetted, 3 subnets
    D 10.0.0.0 [90/30720] via 172.16.2.45, 00:11:50, FastEthernet0/0
    D 10.0.1.0 [90/30720] via 172.16.2.41, 00:11:48, FastEthernet0/1
    D 10.0.2.0 [90/30720] via 172.16.2.41, 00:11:48, FastEthernet0/1

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №4**](https://linkmeup.ru/blog/25.html)  
Из-за настроек различных механизмов QoS на маршрутизаторах Калининграда, было изменено значение пропускной способности на интерфейсах, эти значения теперь не соответствуют действительности. Поэтому было решено, что необходимо изменить подсчет метрики EIGRP на маршрутизаторах Калининграда таким образом, чтобы учитывалась только задержка (delay) и не учитывалась пропускная способность интерфейса (bandwidth).  
[Ответ](https://linkmeup.ru/blog/25.html)  

#### Настройка передачи маршрутов между различными протоколами

Наша задача организовать передачу маршрутов между этими протоколами: из OSPF в EIGRP и наоборот, чтобы все знали маршрут до любой подсети.  
Это называется редистрибуцией (перераспределением) маршрутов.  

Для её осуществления нам нужна хотя бы одна точка стыка, где будут запущены одновременно два протокола. Это может быть msk-arbat-gw1 или klgr-balt-gw1\. Выберем второй.  

Из в EIGRP d OSPF:  

    klgr-gw1(config)#router ospf 1
    klgr-gw1(config-router)#redistribute eigrp 1 subnets 

Смотрим маршруты на msk-arbat-gw1:  

> msk-arbat-gw1#sh ip route  
> Codes: C — connected, S — static, I — IGRP, R — RIP, M — mobile, B — BGP  
> D — EIGRP, EX — EIGRP external, O — OSPF, IA — OSPF inter area  
> N1 — OSPF NSSA external type 1, N2 — OSPF NSSA external type 2  
> E1 — OSPF external type 1, E2 — OSPF external type 2, E — EGP  
> i — IS-IS, L1 — IS-IS level-1, L2 — IS-IS level-2, ia — IS-IS inter area  
> * — candidate default, U — per-user static route, o — ODR  
> P — periodic downloaded static route  
>   
> Gateway of last resort is 198.51.100.1 to network 0.0.0.0  
>   
> 10.0.0.0/8 is variably subnetted, 3 subnets, 2 masks  
> O E2 10.0.0.0/8 [110/20] via 172.16.2.34, 00:25:11, FastEthernet0/1.7  
> O E2 10.0.1.0/24 [110/20] via 172.16.2.34, 00:25:11, FastEthernet0/1.7  
> O E2 10.0.2.0/24 [110/20] via 172.16.2.34, 00:24:50, FastEthernet0/1.7  
> 172.16.0.0/16 is variably subnetted, 30 subnets, 5 masks  
> O E2 172.16.0.0/16 [110/20] via 172.16.2.34, 00:25:11, FastEthernet0/1.7  
> C 172.16.0.0/24 is directly connected, FastEthernet0/0.3  
> C 172.16.1.0/24 is directly connected, FastEthernet0/0.2  
> C 172.16.2.0/30 is directly connected, FastEthernet0/1.4  
> C 172.16.2.16/30 is directly connected, FastEthernet0/1.5  
> C 172.16.2.32/30 is directly connected, FastEthernet0/1.7  
> O E2 172.16.2.36/30 [110/20] via 172.16.2.34, 01:00:55, FastEthernet0/1.7  
> O E2 172.16.2.40/30 [110/20] via 172.16.2.34, 01:00:55, FastEthernet0/1.7  
> O E2 172.16.2.44/30 [110/20] via 172.16.2.34, 01:00:55, FastEthernet0/1.7  
> C 172.16.2.128/30 is directly connected, FastEthernet0/1.8  
> O 172.16.2.160/30 [110/2] via 172.16.2.130, 01:00:55, FastEthernet0/1.8  
> O 172.16.2.192/30 [110/2] via 172.16.2.197, 00:13:21, FastEthernet1/0.911  
> C 172.16.2.196/30 is directly connected, FastEthernet1/0.911  
> C 172.16.3.0/24 is directly connected, FastEthernet0/0.101  
> C 172.16.4.0/24 is directly connected, FastEthernet0/0.102  
> C 172.16.5.0/24 is directly connected, FastEthernet0/0.103  
> C 172.16.6.0/24 is directly connected, FastEthernet0/0.104  
> O 172.16.24.0/24 [110/2] via 172.16.2.18, 01:00:55, FastEthernet0/1.5  
> O 172.16.128.0/24 [110/2] via 172.16.2.130, 01:00:55, FastEthernet0/1.8  
> O 172.16.129.0/26 [110/2] via 172.16.2.130, 01:00:55, FastEthernet0/1.8  
> O 172.16.144.0/24 [110/3] via 172.16.2.130, 00:13:21, FastEthernet0/1.8  
> [110/3] via 172.16.2.197, 00:13:21, FastEthernet1/0.911  
> O 172.16.160.0/24 [110/2] via 172.16.2.197, 00:13:31, FastEthernet1/0.911  
> C 172.16.255.1/32 is directly connected, Loopback0  
> O 172.16.255.48/32 [110/2] via 172.16.2.18, 01:00:55, FastEthernet0/1.5  
> O E2 172.16.255.64/32 [110/20] via 172.16.2.34, 01:00:55, FastEthernet0/1.7  
> O E2 172.16.255.65/32 [110/20] via 172.16.2.34, 01:00:55, FastEthernet0/1.7  
> O E2 172.16.255.66/32 [110/20] via 172.16.2.34, 01:00:55, FastEthernet0/1.7  
> O 172.16.255.80/32 [110/2] via 172.16.2.130, 01:00:55, FastEthernet0/1.8  
> O 172.16.255.96/32 [110/3] via 172.16.2.130, 00:13:21, FastEthernet0/1.8  
> [110/3] via 172.16.2.197, 00:13:21, FastEthernet1/0.911  
> O 172.16.255.112/32 [110/2] via 172.16.2.197, 00:13:31, FastEthernet1/0.911  
> 198.51.100.0/28 is subnetted, 1 subnets  
> C 198.51.100.0 is directly connected, FastEthernet0/1.6  
> S* 0.0.0.0/0 [1/0] via 198.51.100.1

Вот те, что с меткой Е2 — новые импортированные маршруты. Е2 — означает, что это внешние маршруты 2-го типа ([External](http://habrahabr.ru/post/117099/)), то есть они были введены в процесс OSPF извне  

Теперь из OSPF в EIGRP. Это чуточку сложнее:  

    klgr-gw1(config)#router eigrp 1
    klgr-gw1(config-router)#redistribute ospf 1 metric 100000 20 255 1 1500 

Без указания метрики (вот этого длинного набора цифр) команда выполнится, но редистрибуции не произойдёт.  

Импортированные маршруты получают метку EX в таблице маршрутизации и административную дистанцию 170, вместо 90 для внутренних:  

> klgr-gw2#sh ip route  
>   
> Gateway of last resort is not set  
>   
> 172.16.0.0/16 is variably subnetted, 30 subnets, 4 masks  
> D **EX** 172.16.0.0/24 [**170**/33280] via 172.16.2.37, 00:00:07, FastEthernet0/0  
> D EX 172.16.1.0/24 [170/33280] via 172.16.2.37, 00:00:07, FastEthernet0/0  
> D EX 172.16.2.0/30 [170/33280] via 172.16.2.37, 00:00:07, FastEthernet0/0  
> D EX 172.16.2.4/30 [170/33280] via 172.16.2.37, 00:00:07, FastEthernet0/0  
> D EX 172.16.2.16/30 [170/33280] via 172.16.2.37, 00:00:07, FastEthernet0/0  
> D 172.16.2.32/30 [**90**/30720] via 172.16.2.37, 00:38:59, FastEthernet0/0  
> C 172.16.2.36/30 is directly connected, FastEthernet0/0  
> D 172.16.2.40/30 [90/30720] via 172.16.2.37, 00:38:59, FastEthernet0/0  
> [90/30720] via 172.16.2.46, 00:38:59, FastEthernet0/1  
> ….

Вот так, казалось бы незамысловато это делается, но простота поверхностная — редистрибуция таит в себе много тонких и неприятных [моментов](http://habrahabr.ru/post/117062/), когда добавляется хотя бы один избыточный линк между двумя разными доменами.  
Универсальный совет — старайтесь избегать редистрибуции, если это возможно. Тут работает главное жизненное правило — чем проще, тем лучше.  

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №5 (_нереализуема в РТ_)**](https://linkmeup.ru/blog/27.html)  
Маршрутизатор в Москве анонсирует всем остальным маршрутизаторам в сети маршрут по умолчанию. Но на все остальные маршрутизаторы он приходит с одинаковой метрикой равной 1 и метрика не увеличивается по пути передачи маршрута.  
Для удобства решено было изменить настройки по умолчанию таким образом, чтобы начальная метрика маршрута по умолчанию была 30 и по пути, с передачей маршрута по умолчанию по сети, к начальной метрике добавлялась стоимость пути. Кроме того, в дальнейшем возможно добавление резервного маршрутизатора в Москве, с которого на провайдера будет указывать ещё один маршрут по умолчанию. Резервный маршрутизатор будет использоваться только если пропадет основной, поэтому маршруты по умолчанию, которые они анонсируют должны быть с разными метриками.  
[Ответ](https://linkmeup.ru/blog/27.html)  

#### Маршрут по умолчанию

Теперь самое время проверить доступ в интернет. Из Москвы он прекрасно себе работает, а вот если проверить, например из Петербурга (помним, что мы удалили все статические маршруты):  

    PC>ping linkmeup.ru

    Pinging 192.0.2.2 with 32 bytes of data:

    Reply from 172.16.2.5: Destination host unreachable.
    Reply from 172.16.2.5: Destination host unreachable.
    Reply from 172.16.2.5: Destination host unreachable.
    Reply from 172.16.2.5: Destination host unreachable.

    Ping statistics for 192.0.2.2:
    Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),

Это связано с тем, что ни spb-ozerki-gw1, ни spb-vsl-gw1, ни кто-либо другой в нашей сети не знает о маршруте по умолчанию, кроме msk-arbat-gw1, на котором он настроен статически.  
Чтобы исправить эту ситуацию, нам достаточно дать одну команду в Москве:  

    msk-arbat-gw1(config)#router ospf 1 
    msk-arbat-gw1(config-router)#default-information originate 

После этого по сети лавинно распространяется информация о том, где находится шлюз последней надежды.  

Интернет теперь доступен:  

    PC>tracert linkmeup.ru

    Tracing route to 192.0.2.2 over a maximum of 30 hops: 

    1 3 ms 3 ms 3 ms 172.16.17.1
    2 4 ms 5 ms 12 ms 172.16.2.5
    3 14 ms 20 ms 9 ms 172.16.2.1
    4 17 ms 17 ms 19 ms 198.51.100.1
    5 22 ms 23 ms 19 ms 192.0.2.2

    Trace complete.

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №6 (_нереализуема в РТ_)**](https://linkmeup.ru/blog/30.html)  
На маршрутизаторе klgr-balt-gw1 настроено перераспределение маршрутов EIGRP в OSPF. Далее по сети маршруты передаются как внешние с метрикой 20, которая не увеличивается по пути передачи маршрута. Необходимо изменить настройки так, чтобы по пути, с передачей внешних маршрутов по сети, к метрике внешних маршрутов добавлялась стоимость пути.  
[Ответ](https://linkmeup.ru/blog/30.html)  

#### Полезные команды для траблшутинга

1) Список соседей и состояние связи с ними вызывается командой **show ip ospf neighbor**  

    msk-arbat-gw1:

    Neighbor ID Pri State Dead Time Address Interface
    172.16.255.32 1 FULL/DROTHER 00:00:33 172.16.2.2 FastEthernet0/1.4
    172.16.255.48 1 FULL/DR 00:00:34 172.16.2.18 FastEthernet0/1.5
    172.16.255.64 1 FULL/DR 00:00:33 172.16.2.34 FastEthernet0/1.7
    172.16.255.80 1 FULL/DR 00:00:33 172.16.2.130 FastEthernet0/1.8
    172.16.255.112 1 FULL/DR 00:00:33 172.16.2.197 FastEthernet1/0.911

2) Или для EIGRP: **show ip eigrp neighbors**  

    IP-EIGRP neighbors for process 1
    H Address Interface Hold Uptime SRTT RTO Q Seq
    (sec) (ms) Cnt Num
    0 172.16.2.38 Fa0/1 12 00:04:51 40 1000 0 54
    1 172.16.2.42 Fa0/0 13 00:04:51 40 1000 0 58

3) С помощью команды **show ip protocols** можно посмотреть информацию о запущенных протоколах динамической маршрутизации и их взаимосвязи.  

klgr-balt-gw1:  

    Routing Protocol is "EIGRP 1 " 
    Outgoing update filter list for all interfaces is not set 
    Incoming update filter list for all interfaces is not set 
    Default networks flagged in outgoing updates 
    Default networks accepted from incoming updates 
    EIGRP metric weight K1=1, K2=0, K3=1, K4=0, K5=0
    EIGRP maximum hopcount 100
    EIGRP maximum metric variance 1
    Redistributing: EIGRP 1, OSPF 1 
    Automatic network summarization is in effect 
    Automatic address summarization: 
    Maximum path: 4
    Routing for Networks: 
    172.16.0.0
    Routing Information Sources: 
    Gateway Distance Last Update 
    172.16.2.42 90 4 
    172.16.2.38 90 4 
    Distance: internal 90 external 170

    Routing Protocol is "OSPF 1"
    Outgoing update filter list for all interfaces is not set 
    Incoming update filter list for all interfaces is not set 
    Router ID 172.16.255.64
    It is an autonomous system boundary router
    Redistributing External Routes from,
    EIGRP 1 
    Number of areas in this router is 1\. 1 normal 0 stub 0 nssa
    Maximum path: 4
    Routing for Networks:
    172.16.2.32 0.0.0.3 area 0
    Routing Information Sources: 
    Gateway Distance Last Update 
    172.16.255.64 110 00:00:23
    Distance: (default is 110)

4) Для отладки и понимания работы протоколов будет полезно воспользоваться следующими командами:  
**debug ip OSPF events  
debug ip OSPF adj  
debug EIGRP packets**  

Попробуйте подёргать разные интерфейсы и посмотреть, что происходит в дебаге, какие сообщения летят.  

[![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9e219_a466f149_S.jpg)**Задача №7**](https://linkmeup.ru/blog/32.html)  
На последок комплесная задачка.  
На последнем совещании Лифт ми Ап было решено, что сеть Калининграда необходимо также переводить на OSPF.  
Переход должен быть совершен без разрывов связи. Было решено, что лучшим вариантом будет параллельно с EIGRP поднять OSPF на трёх маршрутизаторах Калининграда и после того, как будет проверено, что вся информация о маршрутах Калининграда распространилась по остальной сети и наоборот, отключить EIGRP.  
Но, так как сеть Калининграда достаточно большая, с большим количеством сетей, было решено, что необходимо отделить её от остальной сети так, чтобы изменения в сети Калининграда не приводили к запуску алгоритма SPF на других маршрутизаторах сети.  
[Ответ](https://linkmeup.ru/blog/32.html).  

#### Материалы выпуска

[Новый IP-план, планы коммутации по каждой точке и регламент](https://docs.google.com/spreadsheet/ccc?key=0AooexOHebRpTdGc1eFhvZHdBa0ZrTUljRG5lYVVQM0E&usp=sharing)  
[Файл РТ с лабораторной](https://www.dropbox.com/s/dj1rh5tklxzgyys/Lift-me-Up_v6.pkt?dl=0)  
[Конфигурация устройств](https://docs.google.com/document/pub?id=1kmcVYkJAymnj87VK0wreVU0jfv9o_ZC0KZJapmXff2k)  

#### Полезные ссылки

##### Наш большой помощник XGU.ru

[OSPF в cisco](http://xgu.ru/wiki/OSPF_%D0%B2_Cisco)  
[OSPF](http://xgu.ru/wiki/OSPF)  

##### Коллеги по хабру

[Inter-domain Routing Loops](http://habrahabr.ru/post/117062/)  
[Особенности работы External Type 1 и External Type 2 маршрутов в OSPF. Часть 1](http://habrahabr.ru/post/117099/)  
[Особенности работы External Type 1 и External Type 2 маршрутов в OSPF. Часть 2](http://habrahabr.ru/post/117110/)  

##### Другие

[Cisco](http://docwiki.cisco.com/wiki/Open_Shortest_Path_First)  
[В википедии](http://en.wikipedia.org/wiki/Open_Shortest_Path_First)  
[То же самое на русском](http://citforum.ru/nets/ito/25.shtml)  

> _**Минутка саморекламы**_  
> У Сетей для самых маленьких появился свой сайт — [linkmeup.ru](https://linkmeup.ru). Теперь читать и оставлять комментарии вы можете не только в ЖЖ, но и в личном [блоге](https://linkmeup.ru) этого цикла.

#### Авторы

Марат eucariot  
Максим aka gluck  

Слова благодарности хочу выразить Дмитрию JDima за правки и бесценные комментарии, неотразимой [Наташе Самойленко](http://xgu.ru/wiki/%D0%A3%D1%87%D0%B0%D1%81%D1%82%D0%BD%D0%B8%D0%BA:Nata) за предоставленные задачки. [Антону Автушко](http://habrahabr.ru/users/Antuan/) за программирование сайта для блога. И девушке со славным именем [Нина](http://nikosummerinspiration.blogspot.com/) за логотип сайта.  

P.S.  
Нашему будущему подкасту ЛинкМиАп требуется джингл и музыка на фон. Будем рады помощи, а имя композитора будет прославлено в веках.  

P.P.S  
Возможностей Packet Tracer нам уже не хватает. Следующий шаг — переход на что-то более серьёзное. Есть пожелания? Предлагаю устроить холивар в комментариях на тему IOU vs GNS.
